#!/usr/bin/env perl
# -*- cperl -*-

# $Id: batch.scheduler.list,v 1.1.2.1 2012/08/29 22:01:36 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to List Batch Scheduler Jobs in a Uniform Format
# ------------------------------------------------------------------------------
# afy    Ver   1.00  Copied from NCRC version (and modified)        August 12
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2012
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use File::Basename();
use Getopt::Long( ':config', 'no_ignore_case', 'no_auto_abbrev' );
use XML::LibXML();

{

    package batch_scheduler_list;

    use constant VERSION => 'v2.0.0_beta';

    use constant OPTLIST => (
        'help|h',          'name|n=s',  'feature|f=s', 'retries-number|N=i',
        'retry-delay|D=i', 'running|R', 'user|u=s',  'verbose|v+',
        'version|V', 'partitions|P=s', 'clusters|M=s'
    );

    use constant RETRIES_NUMBER => 60;
    use constant RETRY_DELAY    => 60;

    my $self = File::Basename::basename($0);

    sub Usage()

        # ------ arguments: none
    {
        my $rtn = RETRIES_NUMBER;
        my $rtd = RETRY_DELAY;
        return (
            "\n",
            "  Usage: $self [option] ...\n\n",
            "  Options:\n\n",
            "   -n STRING, --name=STRING          list jobs with name STRING\n",
            "   -f STRING, --feature=STRING       list jobs with the feature request STRING\n",
            "   -u STRING, --user=STRING          list jobs owned by a user STRING\n",
            "   -P STRING, --partitions STRING    list jobs in the partitions STRING\n",
            "   -R,        --running              list jobs in the running state only\n\n",
            "   -N NUM,    --retries-number=NUM   a number NUM of retries (default is '$rtn')\n",
            "   -D NUM,    --retry-delay=NUM      a delay NUM between retries (default is '$rtd'), in seconds\n\n",
            "   -h,        --help                 print the help message and exit\n",
            "   -V,        --version              print the tool version and exit\n",
            "   -v         --verbose              increase verbosity\n\n"
        );
    }

    sub Help()

        # ------ arguments: none
    {
        my @usage = Usage();
        return (
            "\n",
            "   Synopsis: The '$self' lists batch scheduler jobs in the standard format 'id,name,state,submitted-time,user'.\n",
            "@usage",
            "   Possible job states are ('blocked', 'completed', 'failed', 'running', 'waiting').\n\n"
        );
    }

    my @states = ( 'blocked', 'completed', 'failed', 'running', 'waiting' );

    my %state_mapping = (
        RESV_DEL_HOLD => 0,
        STOPPED       => 0,
        SUSPENDED     => 0,
        COMPLETED     => 1,
        BOOT_FAIL     => 2,
        CANCELLED     => 2,
        DEADLINE      => 2,
        FAILED        => 2,
        NODE_FAIL     => 2,
        OUT_OF_MEMORY => 2,
        PREEMPTED     => 2,
        REQUEUE_FED   => 2, # not sure- job is being run again with a new id but this one is a goner
        REQUEUE_HOLD  => 2, # same
        REQUEUED      => 2, # same
        REVOKED       => 2, # similar
        SPECIAL_EXIT  => 2,
        TIMEOUT       => 2,
        COMPLETING    => 3,
        RESIZING      => 3, # going to be resized, but presumably still running ok
        RUNNING       => 3,
        SIGNALING     => 3, # signalling doesn't sound good, but it's running now (I think)
        STAGE_OUT     => 3,
        CONFIGURING   => 4,
        PENDING       => 4,
    );

    sub State($)

        # ------ arguments: $jobState
    {
        my $s = shift;
        return $states[ $state_mapping{$s} ];
    }

}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

    my %opt = (
        'retries-number' => batch_scheduler_list::RETRIES_NUMBER,
        'retry-delay'    => batch_scheduler_list::RETRY_DELAY
    );

    Getopt::Long::GetOptions( \%opt, batch_scheduler_list::OPTLIST )
        or ( print batch_scheduler_list::Usage() and exit 1 );
    if ( $opt{version} ) { print batch_scheduler_list::VERSION, "\n" and exit 0; }
    if ( $opt{help} ) { print batch_scheduler_list::Help() and exit 0; }

    if ( scalar(@ARGV) == 0 ) {
        my $queryCall = 'squeue -h -o "%i,%j,%T,%V,%u,%f,%q"';
        $queryCall .= " -u $opt{user}"        if $opt{user};
        $queryCall .= " -t running"           if $opt{running};
        $queryCall .= " --clusters=$opt{clusters}" if $opt{clusters};
        $queryCall .= " --partitions=$opt{partitions}" if $opt{partitions};
        my $retry  = 0;
        while (1) {
            print STDERR "$queryCall\n" if $opt{verbose};
            chomp( my $res = qx($queryCall) );
            if ( $? == 0 ) {
                print STDERR "$res\n" if $opt{verbose} > 1;
                for ( split "\n", $res ) {
                    my ($id, $name, $state, $time, $user, $features, $qos) = split ',';
                    if ($id =~ /CLUSTER:/) {
                      next;
                    }
                    if ($opt{feature}) {
                        next unless $features =~ /\b$opt{feature}\b/;
                    }
                    if ($opt{name}) {
                        next unless $name eq $opt{name};
                    }
                    my $summary_state = batch_scheduler_list::State($state);
                    print "$id,$name,$summary_state,$time,$user,$qos\n";
                }
                exit 0;
            }
            elsif ( $retry < $opt{'retries-number'} ) {
                print STDERR "Retrying batch system query ($retry)...\n";
                sleep $opt{'retry-delay'};
                $retry++;
            }
            else {
                print STDERR "No more retries\n";
                exit 1;
            }
        } ## end while (1)
    } ## end if ( scalar(@ARGV) == ...)
    else {
        print STDERR "No extra arguments are allowed\n";
        exit 1;
    }

}
