#!/usr/bin/env perl
# -*- cperl -*-
#
# $Id: batch.scheduler.list,v 1.1.2.1.4.1 2014/01/16 15:57:09 Seth.Underwood Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to List Batch Scheduler Jobs in a Uniform Format
# ------------------------------------------------------------------------------
# afy    Ver   1.00  Initial version                                December 12
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2012
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use File::Basename();
use Getopt::Long(':config', 'no_ignore_case', 'no_auto_abbrev');
use XML::LibXML();

{

  package batch_scheduler_list;

  use constant VERSION => '$Id: batch.scheduler.list,v 1.1.2.1.4.1 2014/01/16 15:57:09 Seth.Underwood Exp $';

  use constant OPTLIST =>
  (
    'help|h',
    'name|n=s',
    'queue|q=s',
    'retries-number|N=i',
    'retry-delay|D=i',
    'running|R',
    'user|u=s',
    'verbose|v+',
    'version|V'
  );

  use constant RETRIES_NUMBER => 60;
  use constant RETRY_DELAY => 60;

  my $self = File::Basename::basename($0);

  sub Usage()
  # ------ arguments: none
  {
    my $rtn = RETRIES_NUMBER;
    my $rtd = RETRY_DELAY;
    return
    (
      "\n",
      "  Usage: $self [option] ...\n\n",
      "  Options:\n\n",
      "   -n STRING, --name=STRING          list jobs with name STRING\n",
      "   -q STRING, --queue=STRING         list jibs in the queue STRING\n",
      "   -u STRING, --user=STRING          list jobs owned by a user STRING\n",
      "   -R,        --running              list jobs in the running state only\n\n",
      "   -N NUM,    --retries-number=NUM   a number NUM of retries (default is '$rtn')\n", 
      "   -D NUM,    --retry-delay=NUM      a delay NUM between retries (default is '$rtd'), in seconds\n",
      "   -h,        --help                 print the help message and exit\n",
      "   -V,        --version              print the tool version and exit\n",
      "   -v         --verbose              increase verbosity\n\n"
    );
  }
  
  sub Help()
  # ------ arguments: none
  {
    my @usage = Usage();
    return
    (
      "\n",
      "   Synopsis: The '$self' lists batch scheduler jobs in the standard format 'gid,id,name,state,time'.\n",
      "@usage",
      "   Possible job states are ('blocked', 'completed', 'failed', 'running', 'waiting').\n\n"
    );
  }
  
  my @states = ('blocked', 'completed', 'failed', 'running', 'waiting');
  
  my %state_mapping =
  (
    BatchHold	=> 0,
    H           => 0,
    Canceling	=> 2,
    Completed	=> 1,
    E           => 1,
    C           => 1,
    Deferred	=> 0,
    Idle	=> 4,
    Q           => 4,
    Migrated	=> 4,
    T           => 4,
    NotQueued	=> 2,
    Removed	=> 2,
    Running	=> 3,
    R           => 3,
    Staging	=> 3,
    W           => 3,
    Starting	=> 3,
    Suspended	=> 0,
    S           => 0,
    SystemHold	=> 0,
    UserHold	=> 0,
    Vacated	=> 2
  );
  
  sub State($)
  # ------ arguments: $jobState
  {
    my $s = shift;
    return $states[$state_mapping{$s}];
  }
  
}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

  my %opt =
  (
    'retries-number'	=> batch_scheduler_list::RETRIES_NUMBER,
    'retry-delay'	=> batch_scheduler_list::RETRY_DELAY
  );
  
  Getopt::Long::GetOptions(\%opt, batch_scheduler_list::OPTLIST) or (print batch_scheduler_list::Usage() and exit 1);
  if ($opt{version}) {print batch_scheduler_list::VERSION,"\n" and exit 0;}
  if ($opt{help}) {print batch_scheduler_list::Help() and exit 0;}

  if (scalar(@ARGV) == 0)
  {
    my $showqCall = 'showq --xml';
    $showqCall .= " -w class=$opt{queue}" if $opt{queue};
    $showqCall .= " -u $opt{user}" if $opt{user};
    $showqCall .= " -r" if $opt{running};
    my $qstatCall = 'qstat -x -f';
    $qstatCall .= " -u $opt{user}" if $opt{user};
    my $parser = XML::LibXML->new();
    my $retry = 0;
    while (1)
    {
      print STDERR "$showqCall\n" if $opt{verbose};
      chomp(my $res = qx($showqCall));
      if ($? == 0)
      {
        print STDERR "$res\n" if $opt{verbose} > 1;
	my $root = $parser->parse_string($res)->documentElement();
	my $xpath = ($opt{name}) ? '/Data/queue/job[@JobName="' . $opt{name} . '"]' : '/Data/queue/job';
	my @showqJobs = $root->findnodes($xpath);
	if ( scalar(@showqJobs) > 0 )
	{
	  foreach my $job ($root->findnodes($xpath))
	  {
	    my $gid = $job->getAttribute('GJID') || 'NA';
	    my $id = $job->getAttribute('DRMJID');
	    my $name = $job->getAttribute('JobName');
	    my $state = batch_scheduler_list::State($job->getAttribute('State'));
	    my $time = $job->getAttribute('SubmissionTime');
	    my $user = $job->getAttribute('User');
	    print "$gid,$id,$name,$state,$time,$user\n";
	  }
	  exit 0;
	}
	else
	{
	  chomp($res = qx($qstatCall));
	  $root = $parser->parse_string($res)->documentElement();
	  $xpath = ($opt{name}) ? '/Data/Job/Job_Name[text()="' . $opt{name} .'"]' : '/Data/Job';
	  @showqJobs = $root->findnodes($xpath);
	  foreach my $job (@showqJobs)
	  {
	    my $pNode = $job->parentNode;
	    my $id = $pNode->findvalue('Job_Id') . "a";
	    my @gid = $pNode->findvalue('Job_Id') =~ m/(\d+)/;
	    my $name = $pNode->findvalue('Job_Name');
	    my $state = batch_scheduler_list::State($pNode->findvalue('job_state'));
	    my $time = $pNode->findvalue('qtime');
	    my $user = $pNode->findvalue('Job_Owner');
	    print "$gid[0],$id,$name,$state,$time,$user\n";
	  }
	  exit 0;
	}
      }
      elsif ($retry < $opt{'retries-number'})
      {
	print STDERR "Retrying showq ($retry)...\n";
	sleep $opt{'retry-delay'};
	$retry++;
      }
      else
      {
	print STDERR "No more showq retries\n";
	exit 1;
      }
    }
  }
  else
  {
    print STDERR "No extra arguments are allowed\n";
    exit 1;
  }
  
}
