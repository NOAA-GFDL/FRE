#!/usr/bin/env perl
# -*- cperl -*-

# $Id: batch.scheduler.fre.usage,v 1.1.2.6 2012/10/24 18:14:02 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to Report the FRE Usage
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2012
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use File::Basename();
use File::Spec();
use Getopt::Long( ':config', 'no_ignore_case', 'no_auto_abbrev' );

{

    package batch_scheduler_fre_usage;

    use constant VERSION =>
        '$Id: batch.scheduler.fre.usage,v 1.1.2.6 2012/10/24 18:14:02 afy Exp $';

    use constant OPTLIST => ( 'help|h', 'partition|P=s', 'state|s=s', 'verbose|v', 'version|V' );

    use constant PARTITIONS => ( 'c3:c4', 'c3', 'c4' );
    use constant PARTITION_DEFAULT => 'c3:c4';

    use constant VALID_STATES => ( 'running', 'waiting' );

    my $self = File::Basename::basename($0);

    sub Usage()

        # ------ arguments: none
    {
        my $par = PARTITION_DEFAULT;
        return (
            "\n",
            "  Usage: $self [option]...\n\n",
            "  Options:\n\n",
            "   -h,        --help                 print the help message and exit\n",
            "   -P STRING, --partition=STRING     report usage in the partition STRING (default is '$par')\n",
            "   -s,        --state=STRING         check job in states.  Comma separated list, only \"running\"\n",
            "                                     and \"waiting\" are valid states.  (default is \"running\")\n",
            "   -V,        --version              print the tool version and exit\n",
            "   -v         --verbose              increase verbosity\n\n"
        );
    }

    sub Help()

        # ------ arguments: none
    {
        my @usage = Usage();
        return (
            "\n",
            "   Synopsis: The '$self' outputs a number of currently running jobs per user per FRE version\n",
            "@usage"
        );
    }

    sub Add($$$)

        # ------ arguments: $refToHash $version $user
    {
        my ( $r, $k, $v ) = @_;
        if ( exists( $r->{$k} ) ) {
            $r->{$k}->{$v}++;
        }
        else {
            $r->{$k}->{$v} = 1;
        }
    }

    sub Out($)

        # ------ arguments: $refToHash
    {
        my $r = shift;
        foreach my $version ( sort( keys( %{$r} ) ) ) {
            my @versionUsage = ();
            my %versionUsers = %{ $r->{$version} };
            foreach my $versionUser ( sort(keys(%versionUsers)) ) {
                push @versionUsage, "$versionUser($versionUsers{$versionUser})";
            }
            my $versionUsage = join( ', ', @versionUsage );
            printf "%-56s%s\n", $version, $versionUsage;
        }
    }

    # Return valid states from the state string passed in.
    sub get_valid_job_states($)

            # ------ arguments: $string

    {
      my $inStates = lc shift;
      # Return the intersection of VALID_STATES with the state list passed in
      return map {my $b = $_; grep { $_ eq $b } split(',',$inStates) } batch_scheduler_fre_usage::VALID_STATES;
    }
}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{
    # Default partition and job states to check for reporting
    my %opt = ( partition => batch_scheduler_fre_usage::PARTITION_DEFAULT,
                state => 'running' );

    Getopt::Long::GetOptions( \%opt, batch_scheduler_fre_usage::OPTLIST )
        or ( print STDERR batch_scheduler_fre_usage::Usage() and exit 1 );
    if ( $opt{version} ) { print STDERR batch_scheduler_fre_usage::VERSION, "\n" and exit 0; }
    if ( $opt{help} ) { print STDERR batch_scheduler_fre_usage::Help() and exit 0; }

    if ( scalar( grep( $_ eq $opt{partition}, batch_scheduler_fre_usage::PARTITIONS ) ) == 0 ) {
        print STDERR "The option --partition=$opt{partition} is invalid\n";
        if ( scalar(batch_scheduler_fre_usage::PARTITIONS) > 1 ) {
            my $partitions = join( "', '", batch_scheduler_fre_usage::PARTITIONS );
            print STDERR "Allowed partitions are '$partitions'\n";
        }
        else {
            my $partitionDefault = batch_scheduler_fre_usage::PARTITION_DEFAULT;
            print STDERR "Allowed partition is '$partitionDefault' only\n";
        }
        exit 1;
    }

    # Check if states passed in are valid
    my @checkStates = batch_scheduler_fre_usage::get_valid_job_states($opt{state});
    if (scalar(@checkStates) == 0) {
      print STDERR "The states requested \"$opt{states}\" is not valid.  Expected at";
      print STDERR "least one of \"" . join(", ", batch_scheduler_fre_usage::VALID_STATES) . "\".\n";
    }

    my ( $binDir, $lines, $status ) = ( File::Basename::dirname($0), '', 0 );
    foreach my $partition ( split( /:/, $opt{partition} ) ) {
        my $listCommand = "$binDir/batch.scheduler.list --partition=$partition";
        $listCommand .= " --verbose" if $opt{verbose};
        $lines .= qx($listCommand);
        $status += $?;
    }

    if ( $status == 0 ) {
        my %res = ();
        chomp($lines);
        my @lines = split( /\n/, $lines );
        foreach my $line (@lines) {
            my @out = split( /,/, $line );
            my ( $gid, $id, $name, $state, $user ) = ( $out[0], $out[1], $out[2], $out[3], $out[5] );
            if ( $name ne 'STDIN' && grep(/$state/,@checkStates) ) {
                if ($gid) {
                    if ( $gid =~ /^gaea/ )    # any gaea site is OK
                    {
                        my $checkCommand = "checkjob $gid -v -v -v";
                        chomp( my $checkCommandOutput = qx($checkCommand) );
                        if ( $? == 0 ) {
                            my @checkCommandOutput = split( /\n/, $checkCommandOutput );
                            if ( scalar(@checkCommandOutput) > 0 ) {
                                my @frerunCalls = grep( /bin\/frerun/, @checkCommandOutput );
                                if ( scalar(@frerunCalls) > 0
                                    && $frerunCalls[0] =~ m/(\S+)\/bin\/frerun/ ) {
                                    batch_scheduler_fre_usage::Add( \%res, $1, $user );
                                }
                                else {
                                    batch_scheduler_fre_usage::Add( \%res, 'unknown', $user );
                                }
                            }
                            else {
                                print STDERR
                                    "The job '$gid' info from the Moab is empty - ignored...\n"
                                    if $opt{verbose};
                            }
                        }
                        else {
                            print STDERR
                                "Can't get the job '$gid' info from the Moab - ignored...\n"
                                if $opt{verbose};
                        }
                    } ## end if ( $gid =~ /^gaea/ )
                    else {
                        print STDERR "The job '$gid' has a wrong prefix - ignored...\n"
                            if $opt{verbose};
                    }
                } ## end if ($gid)
                else {
                    print STDERR
                        "The job global id is empty (it is probably starting now) - ignored...\n"
                        if $opt{verbose};
                }
            } ## end if ( $name ne 'STDIN' )
            else {
                print STDERR "The job '$id' is interactive - ignored...\n" if $opt{verbose};
            }
        } ## end foreach my $line (@lines)
        batch_scheduler_fre_usage::Out( \%res );
    } ## end if ( $status == 0 )
    else {
        print STDERR "Can't get the job list from the Moab\n";
        exit 1;
    }

}
