#!/usr/bin/env perl
# -*- cperl -*-

# $Id: batch.scheduler.fre.usage,v 1.1.2.6 2012/10/24 18:14:02 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to Report the FRE Usage
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2012
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use File::Basename();
use File::Spec();
use Getopt::Long(':config', 'no_ignore_case', 'no_auto_abbrev');

{

  package batch_scheduler_fre_usage;

  use constant VERSION => '$Id: batch.scheduler.fre.usage,v 1.1.2.6 2012/10/24 18:14:02 afy Exp $';

  use constant OPTLIST =>
  (
    'help|h',
    'partition|P=s',
    'verbose|v',
    'version|V'
  );
  
  use constant PARTITIONS => ('c1:c2:c3', 'c1', 'c2', 'c3', 't1');
  use constant PARTITION_DEFAULT => 'c1:c2:c3'; 
  
  my $self = File::Basename::basename($0);

  sub Usage()
  # ------ arguments: none
  {
    my $par = PARTITION_DEFAULT;
    return
    (
      "\n",
      "  Usage: $self [option]...\n\n",
      "  Options:\n\n",
      "   -h,        --help                 print the help message and exit\n",
      "   -P STRING, --partition=STRING     report usage in the partition STRING (default is '$par')\n",
      "   -V,        --version              print the tool version and exit\n",
      "   -v         --verbose              increase verbosity\n\n"
    );
  }
  
  sub Help()
  # ------ arguments: none
  {
    my @usage = Usage();
    return
    (
      "\n",
      "   Synopsis: The '$self' outputs a number of currently running jobs per user per FRE version\n",
      "@usage"
    );
  }
  
  sub Add($$$)
  # ------ arguments: $refToHash $version $user
  {
    my ($r, $k, $v) = @_;
    if (exists($r->{$k}))
    {
      $r->{$k}->{$v}++;
    }
    else
    {
      $r->{$k}->{$v} = 1;
    }
  }
  
  sub Out($)
  # ------ arguments: $refToHash
  {
    my $r = shift;
    foreach my $version (sort(keys(%{$r})))
    {
      my @versionUsage = ();
      my %versionUsers = %{$r->{$version}};
      foreach my $versionUser (keys(%versionUsers))
      {
        push @versionUsage, "$versionUser($versionUsers{$versionUser})"
      }
      my $versionUsage = join(', ', @versionUsage);
      printf "%-56s%s\n", $version, $versionUsage;
    }
  }
  
}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

  my %opt =
  (
    partition => batch_scheduler_fre_usage::PARTITION_DEFAULT
  );
  
  Getopt::Long::GetOptions(\%opt, batch_scheduler_fre_usage::OPTLIST) or (print STDERR batch_scheduler_fre_usage::Usage() and exit 1);
  if ($opt{version}) {print STDERR batch_scheduler_fre_usage::VERSION,"\n" and exit 0;}
  if ($opt{help}) {print STDERR batch_scheduler_fre_usage::Help() and exit 0;}
  
  if (scalar(grep($_ eq $opt{partition}, batch_scheduler_fre_usage::PARTITIONS)) == 0)
  {
    print STDERR "The option --partition=$opt{partition} is invalid\n";
    if (scalar(batch_scheduler_fre_usage::PARTITIONS) > 1)
    {
      my $partitions = join("', '", batch_scheduler_fre_usage::PARTITIONS);
      print STDERR "Allowed partitions are '$partitions'\n";
    }
    else
    {
      my $partitionDefault = batch_scheduler_fre_usage::PARTITION_DEFAULT;
      print STDERR "Allowed partition is '$partitionDefault' only\n";
    }
    exit 1;
  }
  
  my ($binDir, $lines, $status) = (File::Basename::dirname($0), '', 0);
  foreach my $partition (split(/:/, $opt{partition}))
  {
    my $listCommand = "$binDir/batch.scheduler.list --partition=$partition --running";
    $listCommand .= " --verbose" if $opt{verbose};
    $lines .= qx($listCommand);
    $status += $?;
  }
  
  if ($status == 0)
  {
    my %res = ();
    chomp($lines);
    my @lines = split(/\n/, $lines);
    foreach my $line (@lines)
    {
      my @out = split(/,/, $line);
      my ($gid, $id, $name, $user) = ($out[0], $out[1], $out[2], $out[5]);
      if ($name ne 'STDIN')
      {
	if ($gid)
	{
	  if ($gid =~ /^gaea/)  # any gaea site is OK
	  {
            my $checkCommand = "checkjob $gid -v -v -v";
	    chomp(my $checkCommandOutput = qx($checkCommand));
	    if ($? == 0)
	    {
	      my @checkCommandOutput = split(/\n/, $checkCommandOutput);
	      if (scalar(@checkCommandOutput) > 0)
	      {
		my @frerunCalls = grep(/bin\/frerun/, @checkCommandOutput);
		if (scalar(@frerunCalls) > 0 && $frerunCalls[0] =~ m/(\S+)\/bin\/frerun/)
		{
        	  batch_scheduler_fre_usage::Add(\%res, $1, $user);
		}
		else
		{
		  batch_scheduler_fre_usage::Add(\%res, 'unknown', $user); 
		}
	      }
	      else
	      {
        	print STDERR "The job '$gid' info from the Moab is empty - ignored...\n" if $opt{verbose};
	      }
	    }
	    else
	    {
              print STDERR "Can't get the job '$gid' info from the Moab - ignored...\n" if $opt{verbose};
	    }
	  }
	  else
	  {
            print STDERR "The job '$gid' has a wrong prefix - ignored...\n" if $opt{verbose};
	  }
	}
        else
        {
          print STDERR "The job global id is empty (it is probably starting now) - ignored...\n" if $opt{verbose};
        }
      }
      else
      {
        print STDERR "The job '$id' is interactive - ignored...\n" if $opt{verbose};
      }
    }
    batch_scheduler_fre_usage::Out(\%res);
  }
  else
  {
    print STDERR "Can't get the job list from the Moab\n";
    exit 1;
  }

}
