#!/bin/csh -f
#FRE scheduler-options
# 
# $Id: runscript.template.main,v 18.0.2.14 2010/10/18 02:34:54 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Runscript Template - GFDL Version
# ------------------------------------------------------------------------------
# arl    Ver   18.0  Merged revision 17.0.2.19 onto trunk           March 10
# afy -------------- Branch 18.0.2 -------------------------------- March 10
# afy    Ver   1.00  Modify ascii/histx files saving (hsmput)       March 10
# afy    Ver   1.01  Modify history files online saving (hsmput)    March 10
# afy    Ver   1.02  Add flagArchive settable constant              March 10
# afy    Ver   1.03  Modify alias "hsmput" (use flagArchive)        March 10
# afy    Ver   2.00  Modify patternGrepRegion                       March 10
# afy    Ver   3.00  Modify region files processing (renaming)      March 10
# afy    Ver   4.00  Source the "fre.cshrc" file                    April 10
# afy    Ver   4.01  Remove FREROOT settable constant               April 10
# afy    Ver   4.02  Modify aliases (use `which` instead of prefix) April 10
# afy    Ver   4.03  Add alias "slmnccombine"                       April 10
# afy    Ver   4.04  Add stdoutDir settable constant                April 10
# afy    Ver   4.05  Add flagOutputType settable constant           April 10
# afy    Ver   4.06  Add flagOutputPostProcess settable constant    April 10
# afy    Ver   4.07  Use prepare_dir.csh to handle directories      April 10
# afy    Ver   4.08  Modify history files saving                    April 10
# afy    Ver   5.00  Remove flagRemake settable constant            May 10
# afy    Ver   5.01  Remove siteDir settable constant               May 10
# afy    Ver   5.02  Modify hsmget/hsmput aliases (use hsmSiteDir)  May 10
# afy    Ver   5.03  Add freCommandsHomeDir settable constant       May 10
# afy    Ver   5.04  Add environment settings for FRE submodules    May 10
# afy    Ver   6.00  Don't allow to redefine the FRE_COMMANDS_HOME  May 10
# afy    Ver   6.01  Set the FREROOT variable (temporarily?)        May 10
# afy    Ver   7.00  Add timeStampFormat settable constant          June 10
# afy    Ver   7.01  Modify alias "time_stamp"                      June 10
# afy    Ver   8.00  Process variables FRE_STAGE/FRE_INPUT_DIR      June 10
# afy    Ver   8.01  Add modules initialization                     June 10
# afy    Ver   8.02  Add check for 'fre-transfer' module            June 10
# afy    Ver   8.03  Add check for 'fre-nctools' module             June 10
# afy    Ver   9.00  Fix check for 'fre-transfer' module            August 10
# afy    Ver   9.01  Fix check for 'fre-nctools' module             August 10
# afy    Ver  10.00  Balance 'set echo'/'unset echo'                August 10
# afy    Ver  10.01  Disable echo around modules initialization     August 10
# afy    Ver  10.02  Disable echo around platform csh               August 10
# afy    Ver  10.03  Fix offline/staged history saving              August 10
# afy    Ver  11.00  Add restart archives checking                  August 10
# afy    Ver  11.01  Add alias 'ardiff'                             August 10
# afy    Ver  11.02  Add flagOutputCheck settable constant          August 10
# afy    Ver  11.03  Add constant 'patternSedRestartProduction'     August 10
# afy    Ver  11.04  Add constant 'patternSedRestartRegression'     August 10
# afy    Ver  11.05  Cosmetics in Mail calls (no inline data)       August 10
# afy    Ver  11.06  New pragmas for flags/constants/variables      August 10
# afy    Ver  11.07  Modify alias 'frusavehist' (add option -eht)   August 10
# afy    Ver  11.08  Change 'frusavehist' location                  August 10
# afy    Ver  12.00  Rename 'frusavehist' => 'fresavehist'          August 10
# afy    Ver  13.00  Modify 'npes' type (const => var)              October 10
# afy    Ver  13.01  Add alias 'submit'                             October 10
# afy    Ver  13.02  Don't adjust 'ptmpDir' from FRE_INPUT_DIR      October 10
# afy    Ver  13.03  Add branch for FRE_STAGE == CHAIN              October 10
# afy    Ver  13.04  Modify restarts checking (polling for ok-file) October 10
# afy    Ver  13.05  Modify region files combining (use children)   October 10
# afy    Ver  13.06  Modify online combining (exit, fix uncombined) October 10
# afy    Ver  14.00  Modify gridSpec/initCond loading (branch 'nc') October 10
# afy    Ver  14.01  Modify all 'find' calls (no -exec/-regex)      October 10
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2010
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
# 

#===============================================================================
#FRE version-info
#===============================================================================

  echo "Starting on `date`"
  echo $HOST $HOSTNAME
  set echo
  unalias *

################################################################################
#---------------- global constants and variables, set by frerun ----------------
################################################################################

  #FRE const(name)
  #FRE const(rtsxml)
  #FRE const(freCommandsHomeDir)
  #FRE const(stdoutDir)
  #FRE const(workDir)
  #FRE const(archiveDir)
  #FRE const(scriptName)
  #FRE const(ppRefineDiagScriptNames)
  #FRE const(executable)
  #FRE const(getFmsData)
  #FRE const(segmentsPerSimulation)
  #FRE const(segmentsPerJob)
  #FRE const(jobsPerSimulation)
  #FRE const(combineFreq)
  #FRE const(monthslist)
  #FRE const(dayslist)
  #FRE const(timeStampFormat)
  #FRE const(baseDate)

  #FRE flag(flagRunType)
  #FRE flag(flagLogging)
  #FRE flag(flagOutputType)
  #FRE flag(flagOutputFormat)
  #FRE flag(flagOutputCombineType)
  #FRE flag(flagOutputCombine)
  #FRE flag(flagOutputArchive)
  #FRE flag(flagOutputPostProcess)
  #FRE flag(flagOutputCheck)

  #FRE var(npes)
  #FRE var(ptmpDir)
  #FRE var(outputDir)
  #FRE var(gridSpec)
  #FRE var(initCond)

################################################################################
#------------------------ global environment settings --------------------------
################################################################################

  # ---------------- FRE environment variables, which have to be set after the platform csh:

  # FRE_TRANSFER_HOME	- root of the fre-transfer module
  # FRE_NCTOOLS_HOME	- toot of the fre-nctools module

  # ---------------- FRE scripts/executables, which have to be accessible via the PATH after the platform csh:

  # ardiff		- part of the fre-commands module
  # combine-ncc		- part of the fre-nctools module
  # frepp		- part of the fre-commands module
  # hsmget		- part of the fre-transfer module 
  # hsmput		- part of the fre-transfer module
  # mppnccombine	- part of the fre-nctools module
  # prepare_dir.csh	- part of the fre-commands module
  # time_stamp.csh	- part of the fre-commands module

  # ---------------- initialize environment modules

  unset echo
  source $MODULESHOME/init/tcsh
  set echo

  # ---------------- commands, copied from XML (setup/platform/csh)

  unset echo
  #FRE setup-platform-csh
  set echo

  # ---------------- exit if no fre-transfer module is loaded

  if ( ! $?FRE_TRANSFER_HOME ) then
    unset echo
    echo "ERROR: The script '$scriptName' must load a 'fre-transfer' module"
    set echo
    exit 1
  endif

  # ---------------- exit if no fre-nctools module is loaded

  if ( ! $?FRE_NCTOOLS_HOME ) then
    unset echo
    echo "ERROR: The script '$scriptName' must load a 'fre-nctools' module"
    set echo
    exit 1
  endif

  # ---------------- the settings below aren't changeable (FREROOT is for compatibility only)

  setenv FRE_COMMANDS_HOME $freCommandsHomeDir
  setenv PATH $FRE_COMMANDS_HOME/bin:$PATH
  setenv FREROOT $FRE_COMMANDS_HOME

################################################################################
#------------------------ global constants and aliases -------------------------
################################################################################

  # ---------------- for compatibility only
  set -r work = $workDir

  # ---------------- HSM site-dependent directory
  set -r hsmSiteDir = $FRE_TRANSFER_HOME/site/hpcs

  # ---------------- top directory for all the HSM-copied files
  set -r hsmDir = $workDir/hsm

  # ---------------- selection patterns for grep
  set -r patternGrepTail = '\.[0-9]{4}$'
  set -r patternGrepAscii = '\<out\>|\<results\>'
  set -r patternGrepHistx = '^hi\.'
  set -r patternGrepRestarts = '\<res\>'
  set -r patternGrepRestartsOrNC = '\<res\>|\<nc\>'
  set -r patternGrepRegion = '^rregion'
  set -r patternGrepNC = '\<nc\>'

  # ---------------- replacement patterns for sed
  set -r patternSedRestartProduction = 's/\/[0-9]+(\/restart\/[0-9]+\.cpio)$/\1/'
  set -r patternSedRestartRegression = 's/pe[0-9]+(\/restart\/[0-9]+\.cpio)$/pe\1/'

  # ---------------- FRE string date generation for file name labels
  alias timeStamp `which time_stamp.csh` -f $timeStampFormat

  # ---------------- FRE directory making/cleaning utility
  alias prepareDir `which prepare_dir.csh`

  # ---------------- FRE archives comparing utility
  alias ardiff `which ardiff`

  # ---------------- FRE data copying old way (deprecated)
  alias get_fms_data $getFmsData

  # ---------------- FRE postprocessing utility
  alias frepp `which frepp` -v -c split -s

  # ---------------- FRE data copying between work directory and archive directory via ptmp directory
  alias hsmget `which hsmget` -q -t -m $hsmSiteDir/hsmget.mk -w $hsmDir -p '$ptmpDir' -a /

  if ( $?flagOutputArchiveOn ) then
    alias hsmput `which hsmput` -q -t -m $hsmSiteDir/hsmput.mk -w $hsmDir -p '$ptmpDir' -a / -s cpio
  else
    alias hsmput `which hsmput` -q -t -m $hsmSiteDir/hsmput.mk -w $hsmDir -p '$ptmpDir' -a /
  endif

  # ---------------- FRE netCDF files combining utilities

  if ( $?flagOutputFormat64Bit ) then
    alias mppnccombine `which mppnccombine` -64
    alias slmnccombine `which combine-ncc`
  else if ( $?flagOutputFormatHDF5 ) then
    alias mppnccombine `which mppnccombine` -n4
    alias slmnccombine `which combine-ncc`
  else
    alias mppnccombine `which mppnccombine`
    alias slmnccombine `which combine-ncc`
  endif

  # ---------------- FRE output stager
  alias outputStager $freCommandsHomeDir/site/hpcs/fresavehist -eht

  # ---------------- batch scheduler submit command
  alias submit `which qsub`

  # ---------------- fast CXFS copy command
  alias cp `which cxfscp` -t 1 -b 8 -s 65000

################################################################################
#------------------------------ environment checks -----------------------------
################################################################################

  # ---------------- some global configuration

  limit
      
  # ---------------- exit if not running on hpcs

  set machine = `uname -m`

  if ( $machine != 'ia64' ) then
    unset echo
    echo "ERROR: The script '$scriptName' is intended for platform ia64"
    set echo
    exit 1
  endif

  unset machine

  # ---------------- exit if number of days/months/hours is not equal to number of segments per job

  if ( $#dayslist != $segmentsPerJob || $#monthslist != $segmentsPerJob) then
    unset echo
    echo "ERROR: dayslist and monthslist must be equal to a number of segments per job"
    set echo
    exit 1
  endif

  if ( $?hourslist ) then
    if ( $#hourslist != $segmentsPerJob ) then
      unset echo
      echo "ERROR: hourslist must be equal to a number of segments per job"
      set echo
      exit 1
    endif
  endif

################################################################################
#----------------------------- global variables --------------------------------
################################################################################

  if ( $?FRE_PROJECT ) then
    set project = $FRE_PROJECT
  else
    set project = ""
  endif

  set combineList = ( )

  @ ireload = 1
  @ irun = 1

################################################################################
#--------------------------- before the main loop ------------------------------
################################################################################

  # ---------------- print the script parameters

  unset echo
  echo $name
  echo ${npes}pe_${segmentsPerJob}run
  set echo

  # ---------------- commands, copied from XML (experiment/runtime/csh)

  #FRE experiment-runtime-csh

  # ---------------- initialize reloading (production runs only)

  if ( $?flagRunTypeProduction ) then

    set reload_file = $outputDir/ascii/reload_commands

    if ( -f $reload_file ) then
      if ( -r $reload_file ) then
	source $reload_file
      else
	unset echo
	echo "ERROR: reload file is not readable: $reload_file"
        set echo
	exit 1
      endif
    endif

    @ currentSeg = ( $ireload - 1 ) * $segmentsPerJob + $irun

    @ alloc = $jobsPerSimulation - 1
    @ windf = 0

    set queue_file = $outputDir/ascii/queue_commands

    if ( -f $queue_file ) then
      if ( -r $queue_file ) then
	source $queue_file
      else
	unset echo
	echo "ERROR: queue file is not readable: $queue_file"
        set echo
	exit 1
      endif
    endif

    if ( $?stop ) then
      unset echo
      echo "NOTE: Stopping execution"
      set echo
      exit 0
    endif

  endif

  # ---------------- set up working directory structure

  prepareDir $workDir		|| exit 1
  prepareDir $workDir/INPUT	|| exit 1
  prepareDir $workDir/RESTART	|| exit 1

  # ---------------- input data loading

  cd $workDir

#fmsDataSets_from_xml

  if ( $status ) then
    unset echo
    echo "ERROR: get_fms_data failed"
    set echo
    exit 1
  endif

  set dataFilesNotOK = ()

#dataFiles_from_xml

  if ( $#dataFilesNotOK > 0) then
    unset echo
    foreach dataFile ( $dataFilesNotOK )
      echo "A problem with the data file: $dataFile"
    end
    echo "ERROR: Failed to copy data files"
    set echo
    exit 1
  endif

  @ gridSpecStatus = 0

  if ( ( $gridSpec:e == 'cpio' || $gridSpec:e == 'tar' ) && $gridSpec:r:e == 'nc' ) then
    hsmget $gridSpec:r:r:s+/++/\* && \
    find $hsmDir$gridSpec:r:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( ( $gridSpec:e == 'cpio' || $gridSpec:e == 'tar' ) && $gridSpec:r:e != 'nc' ) then
    hsmget $gridSpec:r:s+/++/\* && \
    find $hsmDir$gridSpec:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( $gridSpec:e == 'nc' ) then
    hsmget $gridSpec:s+/++ && \
    ln -f $hsmDir/$gridSpec:s+/++ $workDir/INPUT/grid_spec.nc
    @ gridSpecStatus = $status
  else if ( $gridSpec != "" && -d "$gridSpec" ) then
    hsmget $gridSpec:s+/++/\* && \
    find $hsmDir$gridSpec -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( $gridSpec != "" && -f "$gridSpec" ) then
    hsmget $gridSpec:s+/++ && \
    ln -f $hsmDir/$gridSpec:s+/++ $workDir/INPUT/grid_spec.nc
    @ gridSpecStatus = $status
  endif

  if ( $gridSpecStatus ) then
    unset echo
    echo "ERROR: Failed to copy grid specification"
    set echo
    exit 1
  endif

  unset gridSpecStatus 

  @ initCondStatus = 0 

  if ( ( $initCond:e == 'cpio' || $initCond:e == 'tar' ) && $initCond:r:e == 'nc' ) then
    hsmget $initCond:r:r:s+/++/\* && \
    find $hsmDir$initCond:r:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( ( $initCond:e == 'cpio' || $initCond:e == 'tar' ) && $initCond:r:e != 'nc' ) then
    hsmget $initCond:r:s+/++/\* && \
    find $hsmDir$initCond:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( $initCond:e == 'nc' ) then
    hsmget $initCond:s+/++ && \
    ln -f $hsmDir/$initCond:s+/++ $workDir/INPUT/.
    @ initCondStatus = $status
  else if ( $initCond != "" && -d "$initCond" ) then
    hsmget $initCond:s+/++/\* && \
    find $hsmDir$initCond -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( $initCond != "" && -f "$initCond" ) then
    hsmget $initCond:s+/++ && \
    ln -f $hsmDir/$initCond:s+/++ $workDir/INPUT/.
    @ initCondStatus = $status
  endif

  if ( $initCondStatus ) then
    unset echo
    echo "ERROR: Failed to copy initial conditions"
    set echo
    exit 1
  endif

  unset initCondStatus 

  # ---------------- commands, copied from XML (experiment/input/csh[not(@type="always") and not(@type="postInit")])

  #FRE experiment-input-csh-init

  cd $workDir

  # ---------------- list files in the INPUT directory

  unset echo
  ls -l INPUT/*
  set echo

  # ---------------- normal exit if in the input data staging mode

  if ( $?FRE_STAGE ) then
    if ( $FRE_STAGE == 'INPUT' ) then
      unset echo
      echo end_of_input
      echo "NOTE: Natural end-of-input for $scriptName."
      set echo
      exit 0
    else if ( $FRE_STAGE == 'CHAIN' ) then
      if ( "$project" != "" ) then
        submit -P $project -v FRE_PROJECT=$project $scriptName
      else
        submit $scriptName
      endif
      unset echo
      echo end_of_chaining
      echo "NOTE: Natural end-of-chaining for $scriptName."
      set echo
      exit 0
    endif
  endif 

  # ---------------- executable and tables loading

  cp -p $executable $executable:t

#diagTable_from_xml
#fieldTable_from_xml

  touch data_table

#dataTable_from_xml
#tracerTreeTable_from_xml
#tracerTreeInit_from_xml

  # ---------------- check and prepare refine diagnostics scripts

  if ( $?flagOutputCombineTypeStaged || $?flagOutputCombineTypeBySegment ) then

    if ( $#ppRefineDiagScriptNames > 0 ) then

      set ppRefineDiagScriptNamesList = ""
      set ppRefineDiagScriptNamesNotOK = ()

      foreach ppRefineDiagScriptName ( $ppRefineDiagScriptNames )
	if ( -f $ppRefineDiagScriptName && -r $ppRefineDiagScriptName ) then
          if ( $ppRefineDiagScriptNamesList == "" ) then
            set ppRefineDiagScriptNamesList = $ppRefineDiagScriptName
          else
            set ppRefineDiagScriptNamesList = $ppRefineDiagScriptNamesList,$ppRefineDiagScriptName
          endif
	else
          set ppRefineDiagScriptNamesNotOK = ( $ppRefineDiagScriptNamesNotOK $ppRefineDiagScriptName)
	endif
      end

      if ( $#ppRefineDiagScriptNamesNotOK > 0 ) then
	unset echo
	foreach ppRefineDiagScriptName ( $ppRefineDiagScriptNamesNotOK )
          echo "A problem with the refine diagnostics script: $ppRefineDiagScriptName"
	end
	echo "ERROR: Failed to access refine diagnostics scripts"
        set echo
	exit 1
      endif

    endif

  endif

################################################################################
#------------------------------- the main loop ---------------------------------
################################################################################

  while ( $irun <= $segmentsPerJob )

    # ------------------------------------------------ restart passage for SGE

    if ( $?flagLoggingOn ) then

      set logTimestamp = ( `date +"%m/%d/%Y %H:%M:%S"` )

      if ( ! $?SGE_LOCAL_LOG ) then
	set logFile = /home/gfdl/SGElogs/SGElogfile
      else
	set logFile = $SGE_LOCAL_LOG
      endif

      set logFile = ${logFile}.`date +"%Y-%m-%d"`

      if ( ! -f $logFile ) then
	touch $logFile
	chmod 666 $logFile
      endif

      set logTmpJFile = /dev/cpuset/sge/${JOB_ID}.1/cpus

      if ( -f $logTmpJFile ) then
	set logProcessors = `cat /dev/cpuset/sge/${JOB_ID}.1/cpus`
      else
	set logProcessors = 'UNKNOWN'
      endif

      if ( ! $?SGE_STDOUT_PATH ) then
	set logStdout = 'terminal'
      else
	set logStdout = $SGE_STDOUT_PATH
      endif

      echo "PASS_RESTART $JOB_ID $USER $JOB_NAME ${HOST}.gfdl.noaa.gov $QUEUE $NSLOTS $logProcessors $logTimestamp $logStdout" >> $logFile

    endif

    # ---------------- checkpoint - if system requests exit, then resubmit and exit

    if ( -f /home/gfdl/flags/fre.checkpoint.$HOSTNAME || -f /home/gfdl/flags/fre.checkpoint.all || -f /home/gfdl/flags/jobs/fre.checkpoint.$JOB_ID || -f $HOME/fre.checkpoint.$JOB_ID ) then

      unset echo
      echo "Exiting early by HPCS request, resubmitting at `date +%s`"

      set msg = "Your FRE job '$JOB_ID' has been checkpointed and resubmitted to the batch queue.\n"
      set msg = "${msg}It will be re-run by the system as soon as possible.\n\n"
      set msg = "${msg}Job details:\n"
      set msg = "${msg}'$name' (run $ireload, loop $irun) running on '$HOST'\n"
      set msg = "${msg}Batch job stdout:\n"
      set msg = "${msg}$SGE_STDOUT_PATH"
      echo $msg | Mail -s "job '$JOB_ID' '$name' has been checkpointed and resubmitted" $USER
      unset msg

      sleep 30
      set echo
      exit 99

    endif

    # ---------------- commands, copied from XML (experiment/input/csh[@type="always" or @type="postInit"])

    #FRE experiment-input-csh-always-or-postinit

    cd $workDir

    # ---------------- set timing parameters

    set months = $monthslist[$irun]
    set days = $dayslist[$irun]

    # ---------------- include namelists from XML

#namelists_from_xml

    # ---------------- print run parameters

    unset echo
    echo loop_$irun/$segmentsPerJob
    echo run
    set echo

    # ---------------- print a list of free and used memory of the current cpuset

    /home/fms/perform/cpusetmem/cpusetmeminfo

    # ---------------- prepare MPI call, execute it, analyze results

    if ( ! $?MPIRUN_EXEC_PREFIX ) setenv MPIRUN_EXEC_PREFIX 

#parlib_run_from_xml

    if ( $status ) then
      @ cores_dumped = 0
      foreach corefile ( `ls core*` )
        echo "dump of core file $corefile" > $corefile.out
        idb $executable:t $corefile >> $corefile.out &
        @ cores_dumped++
      end
      unset echo
      wait
      set MPI_FAIL
      set outputDir = ${outputDir}_crash
      prepareDir $outputDir/ascii || exit 1
      if ( $cores_dumped > 0 ) then
        cat core*.out >> fms.out
        cat core*.out
        echo "ERROR: in mpirun, core dumped: run $ireload, loop $irun" 
      else
        set cdsize = `limit coredumpsize`
        echo "ERROR: in mpirun, no cores produced: run $ireload, loop $irun"
        echo "NOTE: You are using $cdsize"
      endif
      set echo
    endif

    # ---------------- generate date for file names

    set begindate = `timeStamp -b`
    if ( $begindate == 'no_time_stamp' ) set begindate = tmp`date '+%j%H%M%S'`
    set enddate = `timeStamp -e`
    if ( $enddate == 'no_time_stamp' ) set enddate = tmp`date '+%j%H%M%S'`
    set fyear = `echo $enddate | cut -c -4`

    # ---------------- commands, copied from XML (experiment/postProcess/csh)

    #FRE experiment-postprocess-csh

    cd $workDir

    # ---------------- remove time_stamp.out file

    if ( -f time_stamp.out ) rm -f time_stamp.out

    # ---------------- save ascii files

    set asciiFiles = ( `ls -1 | egrep "$patternGrepAscii"` )

    if ( $#asciiFiles > 0 ) then

      set asciiArchDir = $outputDir/ascii/$begindate.ascii_out
      set asciiWorkDir = $hsmDir$asciiArchDir

      prepareDir $asciiWorkDir || exit 1 

      foreach file ( $asciiFiles )
	mv $file $asciiWorkDir/$begindate.$file
      end

      hsmput $asciiArchDir:s+/++

      if ( $status ) then
        unset echo
        echo "ERROR: Can't save the $asciiArchDir"
        set echo
        exit 1
      endif

      rm -rf $asciiWorkDir

      unset asciiWorkDir
      unset asciiArchDir

    endif

    # ---------------- save histx files

    set histxFiles = ( `ls -1 | egrep "$patternGrepHistx"` )

    if ( $#histxFiles > 0 ) then

      set histxArchDir = $outputDir/ascii/$begindate.hi
      set histxWorkDir = $hsmDir$histxArchDir

      prepareDir $histxWorkDir || exit 1 

      foreach file ( $histxFiles )
	mv $file $histxWorkDir/$file
      end

      hsmput $histxArchDir:s+/++

      if ( $status ) then
        unset echo
        echo "ERROR: Can't save the $histxArchDir"
        set echo
        exit 1
      endif

      rm -rf $histxWorkDir

      unset histxWorkDir
      unset histxArchDir

    endif

    # ---------------- save restart files, namelist, tables etc. and move them from RESTART to INPUT

    pushd $workDir/RESTART

    set restartFiles = ( `ls -1 | egrep "$patternGrepRestartsOrNC"` )

    if ( $#restartFiles > 0 ) then

      set restartArchDir = $outputDir/restart/$enddate
      set restartWorkDir = $hsmDir$restartArchDir

      prepareDir $restartWorkDir || exit 1 

      cp -p $restartFiles	$restartWorkDir
      cp -p $workDir/input.nml	$restartWorkDir
      cp -p $workDir/*_table	$restartWorkDir
      cp -p $rtsxml		$restartWorkDir
      cp -p $scriptName		$restartWorkDir

      hsmput $restartArchDir:s+/++

      if ( $status ) then
        unset echo
        echo "ERROR: Can't save the $restartArchDir"
        set echo
        exit 1
      endif

      if ( $?flagRunTypeProduction ) then
        rm -rf $restartWorkDir
      endif

      if ( $irun < $segmentsPerJob ) then
        find $workDir/INPUT   -maxdepth 1 -type f | egrep "$patternGrepRestarts" | xargs -r rm -f
        find $workDir/RESTART -maxdepth 1 -type f | egrep "$patternGrepRestarts" | xargs -r mv -f -t ../INPUT
        find $workDir/RESTART -maxdepth 1 -type f | egrep "$patternGrepNC"       | xargs -r mv -f -t ../INPUT
      endif

      if ( $?flagOutputCheckOn ) then

        set restartArchive = $restartArchDir.cpio

        if ( -f $restartArchive.ok && -f $restartArchive && -r $restartArchive ) then

          if ( $?flagRunTypeProduction ) then
            set restartArchiveMain = `echo $restartArchive | sed -r "$patternSedRestartProduction"`
          else
            set restartArchiveMain = `echo $restartArchive | sed -r "$patternSedRestartRegression"`
          endif

          @ retry = 0
          while ( 1 )
            if ( -f $restartArchiveMain.ok && -f $restartArchiveMain && -r $restartArchiveMain ) then
              set restartArchiveMainFound
              break
            else if ( $retry < 10 ) then
              sleep 30
              @ retry++
            else
              unset restartArchiveMainFound
              break
            endif
          end
          unset retry

          if ( $?restartArchiveMainFound ) then
            ls -1 $restartArchiveMain $restartArchive | ardiff
            if ( $status ) then
              unset echo
              echo "WARNING: Restart archives '$restartArchiveMain' and '$restartArchive' don't match!"
              set msg = "Restart archives '$restartArchiveMain' and '$restartArchive' don't match!\n\n"
	      set msg = "${msg}Job details:\n"
	      set msg = "${msg}'$name' (run $ireload, loop $irun) running on '$HOST'\n"
	      set msg = "${msg}Batch job stdout:\n"
	      set msg = "${msg}$SGE_STDOUT_PATH"
              echo $msg | Mail -s "job '$JOB_ID' '$name' - restart archives don't match!" $USER
              unset msg
              set echo
            else
              unset echo
              echo "NOTE: Restart archives '$restartArchiveMain' and '$restartArchive' match..."
              set echo
            endif
          else
            unset echo
            echo "WARNING: The restart archive '$restartArchiveMain' doesn't exist or isn't readable"
            set echo
          endif

          unset restartArchiveMainFound
          unset restartArchiveMain

        else
          unset echo
          echo "WARNING: The restart archive '$restartArchive' doesn't exist or isn't readable"
          set echo
        endif

        unset restartArchive

      endif

    endif

    popd

    # ---------------- combine region files

    set regionFiles = ( `ls -1 | egrep "$patternGrepRegion.*$patternGrepTail" | sed -r "s/$patternGrepTail//g" | sort -u` )

    if ( $#regionFiles > 0 ) then

      set filesNotOK = ()

      foreach file ( $regionFiles )
	set inputFiles = ( `ls -1 | egrep "$file$patternGrepTail"` )
	if ( $#inputFiles > 0 ) then
          ( mppnccombine $file $inputFiles || set filesNotOK = ( $filesNotOK $file ) ; mv -f $file `echo $file | sed "s/$patternGrepRegion//"` && rm -f $inputFiles ) &
	endif
      end
      wait

      if ( $#filesNotOK > 0) then
	unset echo
	foreach file ( $filesNotOK )
	  echo "A problem during combining the region file: $file"
	end
	echo "ERROR: Failed to combine region files"
	set echo
	exit 1
      endif

      unset filesNotOK 

    endif

    # ---------------- combine, save and post-process history files: online

    if ( $?flagOutputCombineTypeOnline ) then

      if ( $?flagOutputCombineOn ) then

	set historyFiles = ( `ls -1 | egrep "$patternGrepNC.*$patternGrepTail" | sed -r "s/$patternGrepTail//g" | sort -u` )

        if ( $#historyFiles > 0 ) then

          set filesNotOK = ()

	  foreach file ( $historyFiles )
            set inputFiles = ( `ls -1 | egrep "$file$patternGrepTail"` )
            if ( $#inputFiles > 0) then
	      ( mppnccombine $file $inputFiles || set filesNotOK = ( $filesNotOK $file ) ; test -s $file && rm -f $inputFiles ) &
            endif
	  end
	  wait

	  if ( $#filesNotOK > 0) then
	    unset echo
	    foreach file ( $filesNotOK )
	      echo "A problem during combining the history file: $file"
	    end
	    echo "ERROR: Failed to combine history files"
	    set echo
	    exit 1
	  endif

          unset filesNotOK

        endif

      endif

      set historyCombinedFiles = ( `ls -1 | egrep "$patternGrepNC"$` )

      if ( $#historyCombinedFiles > 0 ) then

	if ( $#combineList > 0 ) then
          set historyCombinedArchDir = $outputDir/history/$combineList[1]:r
        else
          set historyCombinedArchDir = $outputDir/history/$begindate.nc
        endif

        set historyCombinedWorkDir = $hsmDir$historyCombinedArchDir

	prepareDir $historyCombinedWorkDir || exit 1 

        if ( -f $historyCombinedArchDir.cpio ) then
          hsmget $historyCombinedArchDir:s+/++/\*
        endif

	foreach file ( $historyCombinedFiles )
	  mv $file $historyCombinedWorkDir/$begindate.$file
	end
      
        hsmput $historyCombinedArchDir:s+/++

	if ( $status ) then
          unset echo
          echo "ERROR: Can't save the $historyCombinedArchDir"
          set echo
          exit 1
	endif

	set combineList = ( $combineList $historyCombinedArchDir:t.cpio )

        rm -fr $historyCombinedWorkDir

        unset historyCombinedWorkDir
        unset historyCombinedArchDir

      endif

      set historyUncombinedFiles = ( `ls -1 | egrep "$patternGrepNC.*$patternGrepTail"` )

      if ( $#historyUncombinedFiles > 0 ) then

        set historyUncombinedArchDir = $outputDir/history/$begindate.nc.0000
        set historyUncombinedWorkDir = $hsmDir$historyUncombinedArchDir

	prepareDir $historyUncombinedWorkDir || exit 1 

	foreach file ( $historyUncombinedFiles )
	  mv $file $historyUncombinedWorkDir/$begindate.$file
	end

        hsmput $historyUncombinedArchDir:s+/++

	if ( $status ) then
          unset echo
          echo "ERROR: Can't save the $historyUncombinedArchDir"
          set echo
          exit 1
	endif

        rm -fr $historyUncombinedWorkDir

        unset historyUncombinedWorkDir
        unset historyUncombinedArchDir

      endif

      if ( $?flagRunTypeProduction ) then
	if ( ( $combineFreq > 0 && $#combineList == $combineFreq ) || $currentSeg == $segmentsPerSimulation || $#restartFiles == 0 ) then
	  if ( $#combineList > 0 ) then
            set firstdate = `echo $combineList[1] | cut -c -8`
	  else
            set firstdate = $begindate
	  endif
          if ( $?flagOutputPostProcessOn ) then
	    frepp -t $firstdate -d $outputDir/history -x $rtsxml $name
          endif
	  set combineList = ( )
          unset firstdate
        endif
      endif

    endif

    # ---------------- combine, save and post-process history files: offline

    if ( $?flagOutputCombineTypeOffline ) then

      set historyFiles = ( `ls -1 | egrep "$patternGrepNC"` )

      if ( $#historyFiles > 0 ) then

	set historyArchDir = $outputDir/history/$begindate.nc.0000
        set historyWorkDir = $hsmDir$historyArchDir

	prepareDir $historyWorkDir || exit 1 

	foreach file ( `ls -1 | egrep "$patternGrepNC"` )
	  mv $file $historyWorkDir/$begindate.$file
	end

	hsmput $historyArchDir:s+/++

	if ( $status ) then
          unset echo
          echo "ERROR: Can't save the $historyArchDir"
          set echo
          exit 1
	endif

	set combineList = ( $combineList $historyArchDir:t.cpio )

	if ( $?flagRunTypeProduction ) then
	  if ( ( $combineFreq > 0 && $#combineList == $combineFreq ) || $currentSeg == $segmentsPerSimulation || $#restartFiles == 0 ) then
	    if ( $#combineList > 0 ) then
              set firstdate = `echo $combineList[1] | cut -c -8`
	    else
              set firstdate = $begindate
	    endif
	    frepp -t $firstdate -d $outputDir/history -x $rtsxml -f "$combineList" $name
	    set combineList = ( )
            unset firstdate
          endif
        else
          unset echo
          echo "WARNING: Offline combining of history files isn't supported in regression tests"
          set echo
	endif

        rm -rf $historyWorkDir

        unset historyWorkDir
        unset historyArchDir

      endif

    endif

    # ---------------- combine, save and post-process history files: staged

    if ( $?flagOutputCombineTypeStaged ) then

      set combineListSaved = ( $combineList )

      if ( $?flagRunTypeProduction ) then
	if ( $#combineListSaved + 1 == $combineFreq || $currentSeg == $segmentsPerSimulation || $#restartFiles == 0 ) then
	  if ( $#combineListSaved > 0 ) then
            set firstdate = `echo $combineListSaved[1] | cut -c -8`
	  else
            set firstdate = $begindate
	  endif
          if ( $?ppRefineDiagScriptNamesList ) then
	    set PPcmd = "`alias frepp` -t $firstdate -D $ppRefineDiagScriptNamesList -d $outputDir/history -x $rtsxml $name"
          else
	    set PPcmd = "`alias frepp` -t $firstdate -d $outputDir/history -x $rtsxml $name"
          endif
          unset firstdate
	else
          set PPcmd = ""
	endif
      else
        set PPcmd = ""
      endif

      set MPPcmd = `alias mppnccombine`

      if ( $?prevdate ) then
        set saveHistOptions = "-g $prevdate"
      else
        set saveHistOptions = ""
      endif

      if ( $?flagOutputPostProcessOn ) then
        set combineListNew = `outputStager -b $begindate -o $outputDir -m "$MPPcmd" -c "$combineListSaved" -p "$PPcmd" $saveHistOptions`
      else
        set combineListNew = `outputStager -b $begindate -o $outputDir -m "$MPPcmd" -c "$combineListSaved" $saveHistOptions`
      endif

      unset combineListSaved
      unset saveHistOptions
      unset MPPcmd

      if ( "$PPcmd" == "" ) then
	set combineList = ( $combineListNew )
	set prevdate = $begindate
      else
	set combineList = ( )
	unset prevdate
      endif

      unset combineListNew
      unset PPcmd

    endif

    # ---------------- combine, save and post-process history files: bySegment

    if ( $?flagOutputCombineTypeBySegment ) then

      if ( $?ppRefineDiagScriptNamesList ) then
        set PPcmd = "`alias frepp` -t $begindate -D $ppRefineDiagScriptNamesList -d $outputDir/history -x $rtsxml $name"
      else
        set PPcmd = "`alias frepp` -t $begindate -d $outputDir/history -x $rtsxml $name"
      endif

      set MPPcmd = `alias mppnccombine`

      if ( $?flagOutputPostProcessOn ) then
        outputStager -b $begindate -o $outputDir -m "$MPPcmd" -c "" -p "$PPcmd"
      else
        outputStager -b $begindate -o $outputDir -m "$MPPcmd" -c ""
      endif

    endif

    # ---------------- terminate script if mpirun crashed

    if ( $?MPI_FAIL ) then

      unset echo
      echo "ERROR: in mpirun, core dumped: run $ireload, loop $irun" 
      echo "ERROR: Any output that may have been generated is in $outputDir" 

      if ( $?flagRunTypeProduction ) then
        if ( $ireload > 1 ) then
          set lc = `wc -l $SGE_STDOUT_PATH | awk '{print $1}'`
          set msg = "Reloaded batch job failed near line '$lc'\n\n"
	  set msg = "${msg}Job details:\n"
	  set msg = "${msg}'$name' (run $ireload, loop $irun) running on '$HOST'\n"
	  set msg = "${msg}Batch job stdout:\n"
	  set msg = "${msg}$SGE_STDOUT_PATH"
          echo $msg | Mail -s "$HOST $JOB_ID $USER $name (run $ireload, loop $irun) $SGE_STDOUT_PATH" oar.gfdl.failedbatchjobs@noaa.gov
          unset msg
          unset lc
        endif
      endif

      sleep 30
      set echo
      exit 1

    endif

    # ---------------- terminate script if there are no restart files

    if ( $#restartFiles == 0 ) then
      unset echo
      echo "ERROR: no restart files exist, run $ireload, loop $irun"
      set echo
      exit 1
    endif

    # ---------------- increment the loop counter

    @ irun++

    # ---------------- write new reload information (production runs only)

    if ( $?flagRunTypeProduction ) then

      if ( ! -w $reload_file:h ) then

	unset echo
	echo "Exiting early, the archive is unavailable, resubmitting at `date +%s`"

        set msg = "Your FRE job '$JOB_ID' has been stopped and resubmitted to the batch queue.\n"
        set msg = "${msg}Your output directory is not writeable, which implies the archive is not available.\n"
        set msg = "${msg}Your job will be re-run by the system as soon as possible.\n\n"
	set msg = "${msg}Job details:\n"
	set msg = "${msg}'$name' (run $ireload, loop $irun) running on '$HOST'\n"
	set msg = "${msg}Batch job stdout:\n"
	set msg = "${msg}$SGE_STDOUT_PATH"
        echo $msg | Mail -s "job '$JOB_ID' '$name' has been stopped and resubmitted" $USER
        unset msg

	sleep 30
        set echo
	exit 99

      endif

      unset echo
      echo "Writing reload information to $reload_file at `date +%s`"
      set echo 

      if ( -f $reload_file ) then
	mv -f $reload_file ${reload_file}_prev
      endif

      if ( $irun <= $segmentsPerJob ) then
	echo "@ irun          =   $irun"		>  $reload_file
      else
	@ ireload++
	echo "@ irun          =   1"			>  $reload_file
      endif

      echo   "@ ireload       =   $ireload"		>> $reload_file
      echo   "set initCond    =   $restartArchDir.cpio"	>> $reload_file
      echo   "set combineList = ( $combineList )"	>> $reload_file
      echo   "set fyear       =   $fyear"		>> $reload_file

    endif

    # ---------------- check if simulation complete

    if ( $?flagRunTypeProduction ) then
      @ currentSeg++
      if ( $currentSeg > $segmentsPerSimulation ) break
    endif

  end

################################################################################
#--------------------------- after the main loop -------------------------------
################################################################################

  # ---------------- reload and resubmit if needed (production runs only)

  if ( $?flagRunTypeProduction ) then

    if ( $ireload <= $jobsPerSimulation && $currentSeg <= $segmentsPerSimulation ) then

      if ( -f $queue_file ) then
	if ( -r $queue_file ) then
          source $queue_file
	else
          unset echo
          echo "ERROR: queue file is not readable: $queue_file"
          set echo
          exit 1
	endif
      endif

      if ( $alloc > 0 ) then
        unset echo
	echo reloading
        set echo
	set peToResubmit = "-pe ic.alloc $npes"
	@ alloc--
      else if ( $windf > 0 ) then
	set projlist = ( `qconf -sprjl` )
	set firstc = `echo $project | sed 's/.* //' | sed 's/\(.*\)\(.$\)/\1/'`
	set lastc  = `echo $project | sed 's/.* //' | sed 's/\(.*\)\(.$\)/\2/'`
	if ( "$lastc" == 'p' ) then
          foreach p ( $projlist )
            if ( $p == "${firstc}d" || $p == "$firstc" ) set project = $p
          end
	endif
        unset echo
	echo reloading
        set echo
	set peToResubmit = "-pe ic.windf $npes"
	@ windf--
      else
	unset echo
        echo "WARNING: Have not reached $jobsPerSimulation submissions, but no queue time remaining"
        set echo
	unset peToResubmit
      endif

      if ( -f $queue_file ) rm -f $queue_file

      echo   "@ alloc     = $alloc"   >  $queue_file
      echo   "@ windf     = $windf"   >> $queue_file

      if ( "$project" != "" ) then
	echo "set project = $project" >> $queue_file
      endif

      chmod 664 $queue_file

      if ( $?stop ) then 
	echo "set stop"               >> $queue_file
	unset echo
	echo "NOTE: Stopping execution"
        set echo
	exit 0
      endif

      if ( -f $scriptName ) then
	if ( $?peToResubmit ) then
          if ( "$project" != "" ) then
            submit $peToResubmit -P $project -v FRE_PROJECT=$project $scriptName
          else
            submit $peToResubmit $scriptName
          endif
        endif
      else
	unset echo
	echo "WARNING: The script '$scriptName' does not exist (run $ireload, loop $irun) - it can't be resubmitted"
        set echo
      endif

    endif

  endif

  # ---------------- combine distributed restart files (regression runs only)

  if ( $?flagRunTypeRegression ) then

    pushd $restartWorkDir

    set restartFiles = ( `ls -1 | egrep "$patternGrepRestartsOrNC.*$patternGrepTail" | sed -r "s/$patternGrepTail//g" | sort -u` )

    foreach file ( $restartFiles )
      set inputFiles = ( `ls -1 | egrep "$file$patternGrepTail"` )
      if ( $#inputFiles > 0 ) then
	set compressed = `ncdump -h $inputFiles[1] | grep 'tile_index:compress' | wc -l`
	if ( $compressed > 0 ) then
          slmnccombine $inputFiles $file && rm -f $inputFiles
          if ( $status ) then
            unset echo
            echo "ERROR: in execution of slmnccombine on restarts"
            set echo
            exit 1
          endif
	else
          mppnccombine $file $inputFiles && rm -f $inputFiles
          if ( $status ) then
            unset echo
            echo "ERROR: in execution of mppnccombine on restarts"
            set echo
            exit 1
          endif
	endif
      endif
    end

    hsmput $restartArchDir:s+/++

    if ( $status ) then
      unset echo
      echo "ERROR: Can't save the $restartArchDir"
      set echo
      exit 1
    endif

    popd

  endif

  # ---------------- normal end of script 

  unset echo
  echo end_of_run
  echo "NOTE: Natural end-of-script for $scriptName."
  exit 0
