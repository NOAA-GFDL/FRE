#!/bin/csh -f
#FRE scheduler-options
# 
# $Id: runscript.template.main,v 1.1.2.9 2012/02/21 17:06:51 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Runscript Template - GFDL Workstations Version
# ------------------------------------------------------------------------------
# afy    Ver   1.00  Initial version (copied from GFDL version)     January 11
# afy    Ver   1.01  Remove all the job scheduling stuff            March 11
# afy    Ver   1.02  Add settable alias 'runCommand'                March 11
# afy    Ver   1.03  Modify hsmSiteDir (gfdl -> gfdl-ws)            March 11
# afy    Ver   2.00  Remove 'fmsDataSets_from_xml' placeholder      March 11
# afy    Ver   2.01  Prepend 'cp -p' calls by 'ln -f' calls         March 11
# afy    Ver   2.02  Remove 'fre-transfer' submodule                March 11
# afy    Ver   2.03  Remove 'FREROOT' environment variable          March 11
# afy    Ver   3.00  Add settable constant 'hourslist'              September 11
# afy    Ver   3.01  Rename 'timeStampFormat' => 'timeStampOptions' September 11
# afy    Ver   3.02  Add settable constant 'FRE_JOBID'              September 11
# afy    Ver   3.03  Add settable constant 'stateDir'               September 11
# afy    Ver   3.04  Add settable flag 'flagCheckSum'               September 11
# afy    Ver   3.05  Add settable flag 'flagOutputCompress*'        September 11
# afy    Ver   3.06  Use the 'expand_variables' utility             September 11
# afy    Ver   3.07  Use the 'is_compressed' utility                September 11
# afy    Ver   3.08  Add the 'queue_commands' file reading/writing  September 11
# afy    Ver   3.09  Redesign logics after the MPI fail             September 11
# afy    Ver   3.10  Move restarts combining into the loop          September 11
# afy    Ver   3.11  Remove separate region files processing        September 11
# afy    Ver   3.12  Fix errors reporting during combining          September 11
# afy    Ver   3.13  Simplify the irunNext logic                    September 11
# afy    Ver   3.14  Modify the 'patternGrepAscii' (more files)     September 11
# afy    Ver   4.00  Rename 'combineFreq' => 'segmentsPerPPCall'    September 11
# afy    Ver   4.01  Don't call the 'frepp', echo only              September 11
# afy    Ver   4.02  Add the $freCommandsHomeDir/sbin to the PATH   September 11
# afy    Ver   4.03  More strict condition to post-process          September 11
# afy    Ver   5.00  Replace 'setenv' by 'env --unset=TERMCAP'      October 11
# afy    Ver   5.01  Remove all the post-processing-related code    October 11
# afy    Ver   5.02  Rename region files separately                 October 11
# afy    Ver   6.00  Fix region files renaming                      October 11
# afy    Ver   7.00  Replace 'moduleInitDir' => 'modulesHomeDir'    November 11
# afy    Ver   7.01  Add settable constant 'freModuleFilesDir'      November 11
# afy    Ver   8.00  Add settable flag 'flagWorkDirClean'           February 12
# afy    Ver   8.01  Improve after-the-MPI-crash message            February 12
# afy    Ver   8.02  Add version string to the first message        February 12
# afy    Ver   8.03  Use xargs to hardlink restarts                 February 12
# afy    Ver   8.04  Use xargs to move history files                February 12
# afy    Ver   9.00  Move constants/aliases to the beginning        February 12
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2012
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

#===============================================================================
#FRE version-info
#===============================================================================

  set -r echoOn = $?echo
  set -r runtimeBeg = `date "+%s"`

  if ( $echoOn ) unset echo
  echo '<NOTE> : ====== FRE RUNSCRIPT $Id: runscript.template.main,v 1.1.2.9 2012/02/21 17:06:51 afy Exp $ ======'
  echo "<NOTE> : Starting at $HOST on `date`"
  if ( $echoOn ) set echo

  unalias *

  # ---------------- initialize environment modules

  if ( $echoOn ) unset echo
  #FRE const(modulesHomeDir)
  source $modulesHomeDir/init/tcsh
  setenv COLUMNS 148
  if ( $echoOn ) set echo

  # ---------------- define constants

  set -r FRE_JOBID = $0:t.o`date +%s`

  # ---------------- print starting banner

  banner $FRE_JOBID

################################################################################
#---------------- global constants and variables, set by frerun ----------------
################################################################################

  #FRE const(platform)
  #FRE const(target)
  #FRE const(name)
  #FRE const(rtsxml)
  #FRE const(freModuleFilesDir)
  #FRE const(freCommandsHomeDir)
  #FRE const(stdoutDir)
  #FRE const(stateDir)
  #FRE const(workDir)
  #FRE const(ptmpDir)
  #FRE const(archiveDir)
  #FRE const(scriptName)
  #FRE const(ppRefineDiagScriptNames)
  #FRE const(executable)
  #FRE const(segmentsPerSimulation)
  #FRE const(segmentsPerJob)
  #FRE const(jobsPerSimulation)
  #FRE const(monthslist)
  #FRE const(dayslist)
  #FRE const(hourslist)
  #FRE const(timeStampOptions)
  #FRE const(baseDate)

  #FRE flag(flagRunType)
  #FRE flag(flagCheckSum)
  #FRE flag(flagWorkDirClean)
  #FRE flag(flagOutputType)
  #FRE flag(flagOutputFormat)
  #FRE flag(flagOutputCombineHistory)
  #FRE flag(flagOutputCompressAscii)
  #FRE flag(flagOutputCompressRestart)
  #FRE flag(flagOutputCompressHistory)
  #FRE flag(flagOutputArchive)
  #FRE flag(flagOutputCheck)

  #FRE var(npes)
  #FRE var(outputDir)
  #FRE var(gridSpec)
  #FRE var(initCond)

  #FRE alias(runCommand)

################################################################################
#------------------------ global constants and aliases -------------------------
################################################################################

  # ---------------- machine architecture

  set -r architecture = 'i686'

  # ---------------- for compatibility only

  set -r work = $workDir

  # ---------------- HSM site-dependent directory

  set -r hsmSiteDir = $freCommandsHomeDir/site/gfdl-ws

  # ---------------- top directory for all the HSM-copied files

  set -r hsmDir = $workDir/hsm

  # ---------------- top directory for all the temporary output files 

  set -r tmpOutputDir = $workDir/output.stager

  # ---------------- file to save shell plus environment variables

  set -r envFile = /tmp/shell.variables.$FRE_JOBID
  set -r envFileDelay = 2

  # ---------------- selection patterns for grep

  set -r patternGrepTail = '\.[0-9]{4}$'
  set -r patternGrepAscii = '\<out\>|\<results\>|\<timestats\>|\<velocity_truncations\>'
  set -r patternGrepRestart = '\<res\>|\<nc\>|\.input.\tgz$'
  set -r patternGrepRestartNextDrop = '\<res\>'
  set -r patternGrepRestartNextMove = '\<res\>|\<nc\>'
  set -r patternGrepHistory = '\<nc\>'
  set -r patternGrepRegion = '^rregion'

  # ---------------- selection patterns for combining errors reporting

  set -r tagFail = 'fail'
  set -r patternGrepFail = '\.'$tagFail'$'

  # ---------------- archive extension

  set -r archExt = 'tar'

  # ---------------- FRE data copying between work directory and archive directory via ptmp directory

  alias hsmget $freCommandsHomeDir/bin/hsmget --quiet --time --makefile $hsmSiteDir/hsmget.mk --workroot $hsmDir --ptmproot $ptmpDir --archroot /

  if ( $?flagOutputArchiveOn ) then
    alias hsmput $freCommandsHomeDir/bin/hsmput --quiet --time --makefile $hsmSiteDir/hsmput.mk --workroot $tmpOutputDir --ptmproot $tmpOutputDir --archroot / --store $archExt
  else
    alias hsmput $freCommandsHomeDir/bin/hsmput --quiet --time --makefile $hsmSiteDir/hsmput.mk --workroot $tmpOutputDir --ptmproot $ptmpDir --archroot /
  endif

  if ( $?flagCheckSumOn ) alias hsmput `alias hsmput` --checksum

  # ---------------- FRE runscript site-independent helper scripts

  alias compareDual $freCommandsHomeDir/sbin/compare_dual.csh
  alias expandVariables $freCommandsHomeDir/sbin/expand_variables --verbose
  alias prepareDir $freCommandsHomeDir/sbin/prepare_dir.csh
  alias timeStamp $freCommandsHomeDir/sbin/time_stamp.csh $timeStampOptions

################################################################################
#--------------------------------- environment ---------------------------------
################################################################################

  # ---------------- commands, copied from XML (setup/platform/csh)

  if ( $echoOn ) unset echo
  #FRE setup-platform-csh
  module list
  if ( $echoOn ) set echo

  # ---------------- exit if no fre-nctools module is loaded

  if ( $?FRE_NCTOOLS_HOME ) then
    if ( $echoOn ) unset echo
    echo "<NOTE> : Using the 'fre-nctools' home directory '$FRE_NCTOOLS_HOME'..."
    if ( $echoOn ) set echo
  else
    if ( $echoOn ) unset echo
    echo "*ERROR*: The script '$scriptName' must load a 'fre-nctools' module"
    if ( $echoOn ) set echo
    exit 1
  endif

  # ---------------- the settings below aren't changeable

  setenv FRE_COMMANDS_HOME $freCommandsHomeDir

  if ( $?PATH ) then
    setenv PATH $freCommandsHomeDir/bin:$freCommandsHomeDir/sbin:$PATH
  else
    setenv PATH $freCommandsHomeDir/bin:$freCommandsHomeDir/sbin
  endif

  # ---------------- some global configuration

  limit stacksize unlimited
  limit coredumpsize unlimited
  limit
      
  # ---------------- exit if not running on right machine architecture

  set machine = `uname -m`

  if ( $machine != $architecture ) then
    if ( $echoOn ) unset echo
    echo "*ERROR*: The script '$scriptName' is intended for the machine architecture '$architecture'"
    if ( $echoOn ) set echo
    exit 1
  endif

  unset machine

  # ---------------- exit if number of days/months/hours is not equal to number of segments per job

  if ( $#dayslist != $segmentsPerJob || $#monthslist != $segmentsPerJob || $#hourslist != $segmentsPerJob ) then
    if ( $echoOn ) unset echo
    echo "*ERROR*: dayslist, monthslist and hourslist lengths must be equal to a number of segments per job"
    if ( $echoOn ) set echo
    exit 1
  endif

################################################################################
#------------------ FRE netCDF files combining utilities -----------------------
################################################################################

  if ( $?flagOutputFormat64Bit ) then
    alias mppnccombine `which mppnccombine` -r -64 -h 16384
  else if ( $?flagOutputFormatHDF5 ) then
    alias mppnccombine `which mppnccombine` -r -n4 -h 16384
  else
    alias mppnccombine `which mppnccombine` -r -h 16384
  endif

  alias slmnccombine `which combine-ncc`
  alias slmnccompressed `which is-compressed`

################################################################################
#----------------------------- global variables --------------------------------
################################################################################

  set continueFlag = 1

  @ ireload = 1
  @ irun = 1

################################################################################
#--------------------------- before the main loop ------------------------------
################################################################################

  # ---------------- commands, copied from XML (experiment/runtime/csh)

  #FRE experiment-runtime-csh

  # ---------------- initialize reloading (production runs only)

  if ( $?flagRunTypeProduction ) then

    prepareDir $stateDir || exit 1

    set reload_file = $stateDir/reload_commands

    if ( -f $reload_file ) then
      if ( -r $reload_file ) then
	source $reload_file
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The reload file '$reload_file' is not readable"
        if ( $echoOn ) set echo
	exit 1
      endif
    endif

    set queue_file = $stateDir/queue_commands

    if ( -f $queue_file ) then
      if ( -r $queue_file ) then
	source $queue_file
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The queue file '$queue_file' is not readable"
        if ( $echoOn ) set echo
	exit 1
      endif
    endif

    if ( ! $continueFlag ) then
      if ( $echoOn ) unset echo
      echo "<NOTE> : Stopping execution"
      if ( $echoOn ) set echo
      exit 0
    endif

  endif

  # ---------------- absolute segment number

  @ currentSeg = ( $ireload - 1 ) * $segmentsPerJob + $irun

  # ---------------- set up working directory structure

  prepareDir $workDir 'clean'		|| exit 1
  prepareDir $workDir/INPUT 'clean'	|| exit 1
  prepareDir $workDir/RESTART 'clean'	|| exit 1

  # ---------------- input data loading

  cd $workDir

  set dataFilesNotOK = ( )

#dataFiles_from_xml

  if ( $#dataFilesNotOK > 0 ) then
    if ( $echoOn ) unset echo
    foreach dataFile ( $dataFilesNotOK )
      echo "*ERROR*: A problem with the data file: $dataFile"
    end
    echo "*ERROR*: Failed to copy data files"
    if ( $echoOn ) set echo
    exit 1
  endif

  @ gridSpecStatus = 0

  if ( ( $gridSpec:e == 'cpio' || $gridSpec:e == 'tar' ) && $gridSpec:r:e == 'nc' ) then
    hsmget $gridSpec:r:r:s+/++/\* && \
    find $hsmDir$gridSpec:r:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( ( $gridSpec:e == 'cpio' || $gridSpec:e == 'tar' ) && $gridSpec:r:e != 'nc' ) then
    hsmget $gridSpec:r:s+/++/\* && \
    find $hsmDir$gridSpec:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( $gridSpec:e == 'nc' ) then
    hsmget $gridSpec:s+/++ && \
    ln -f $hsmDir/$gridSpec:s+/++ $workDir/INPUT/grid_spec.nc
    @ gridSpecStatus = $status
  else if ( $gridSpec != "" && -d "$gridSpec" ) then
    hsmget $gridSpec:s+/++/\* && \
    find $hsmDir$gridSpec -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( $gridSpec != "" && -f "$gridSpec" ) then
    hsmget $gridSpec:s+/++ && \
    ln -f $hsmDir/$gridSpec:s+/++ $workDir/INPUT/grid_spec.nc
    @ gridSpecStatus = $status
  endif

  if ( $gridSpecStatus ) then
    if ( $echoOn ) unset echo
    echo "*ERROR*: Failed to copy grid specification"
    if ( $echoOn ) set echo
    exit 1
  endif

  unset gridSpecStatus 

  @ initCondStatus = 0 

  if ( ( $initCond:e == 'cpio' || $initCond:e == 'tar' ) && $initCond:r:e == 'nc' ) then
    hsmget $initCond:r:r:s+/++/\* && \
    find $hsmDir$initCond:r:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( ( $initCond:e == 'cpio' || $initCond:e == 'tar' ) && $initCond:r:e != 'nc' ) then
    hsmget $initCond:r:s+/++/\* && \
    find $hsmDir$initCond:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( $initCond:e == 'nc' ) then
    hsmget $initCond:s+/++ && \
    ln -f $hsmDir/$initCond:s+/++ $workDir/INPUT/.
    @ initCondStatus = $status
  else if ( $initCond != "" && -d "$initCond" ) then
    hsmget $initCond:s+/++/\* && \
    find $hsmDir$initCond -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( $initCond != "" && -f "$initCond" ) then
    hsmget $initCond:s+/++ && \
    ln -f $hsmDir/$initCond:s+/++ $workDir/INPUT/.
    @ initCondStatus = $status
  endif

  if ( $initCondStatus ) then
    if ( $echoOn ) unset echo
    echo "*ERROR*: Failed to copy initial conditions"
    if ( $echoOn ) set echo
    exit 1
  endif

  unset initCondStatus

  # ---------------- the executable loading

  hsmget $executable:s+/++

  # ---------------- commands, copied from XML (experiment/input/csh[not(@type="always") and not(@type="postInit")])

  #FRE experiment-input-csh-init

  cd $workDir

  # ---------------- list files in the INPUT directory

  if ( $echoOn ) unset echo
  ls -l INPUT/*
  if ( $echoOn ) set echo

  # ---------------- executable and tables loading

  ln -f $ptmpDir$executable . || cp -pf $ptmpDir$executable .

  if ( $status == 0 ) then
    if ( $echoOn ) unset echo
    echo "<NOTE> : Using the executable '$ptmpDir$executable'"
    if ( $echoOn ) set echo
  else
    if ( $echoOn ) unset echo
    echo "*ERROR*: Failed to copy the executable"
    if ( $echoOn ) set echo
    exit 1
  endif

#diagTable_from_xml
#fieldTable_from_xml

  touch data_table

#dataTable_from_xml
#tracerTreeTable_from_xml
#tracerTreeInit_from_xml
#namelists_from_xml

  # ---------------- expand namelists 

  set months = $monthslist[1]
  set days = $dayslist[1]
  set hours = $hourslist[$irun]

  set | sort > $envFile
  sleep $envFileDelay
  set -r | sort >> $envFile
  sleep $envFileDelay
  env --unset=TERMCAP | sort >> $envFile

  expandVariables $envFile < input.nml.unexpanded > input.nml || exit 1

  rm -f $envFile

  # ---------------- normal exit if in the input data staging mode

  if ( $?FRE_STAGE ) then
    if ( $FRE_STAGE == 'DEBUG' ) then
      if ( $echoOn ) unset echo
      echo "<NOTE> : The working directory '$workDir' is ready for debugging"
      echo "<NOTE> : Natural end-of-debug-staging for '$scriptName'"
      if ( $echoOn ) set echo
      exit 0
    else
      rm -fr $workDir
      if ( $echoOn ) unset echo
      echo "<NOTE> : Natural end-of-input-staging for '$scriptName'"
      if ( $echoOn ) set echo
      exit 0
    endif
  endif 

################################################################################
#------------------------------- the main loop ---------------------------------
################################################################################

  while ( $irun <= $segmentsPerJob && $currentSeg <= $segmentsPerSimulation )

    banner $currentSeg/$segmentsPerSimulation

    # ---------------- reload the queue file and exit if it has been requested

    if ( $?flagRunTypeProduction ) then

      if ( -f $queue_file ) then
	if ( -r $queue_file ) then
	  source $queue_file
	else
	  if ( $echoOn ) unset echo
	  echo "*ERROR*: The queue file '$queue_file' is not readable"
          if ( $echoOn ) set echo
	  exit 1
	endif
      endif

      if ( ! $continueFlag ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : Stopping execution"
	if ( $echoOn ) set echo
	exit 0
      endif

    endif

    # ---------------- commands, copied from XML (experiment/input/csh[@type="always" or @type="postInit"])

    #FRE experiment-input-csh-always-or-postinit

    cd $workDir

    # ---------------- expand namelists

    set months = $monthslist[$irun]
    set days = $dayslist[$irun]
    set hours = $hourslist[$irun]

    set | sort > $envFile
    sleep $envFileDelay
    set -r | sort >> $envFile
    sleep $envFileDelay
    env --unset=TERMCAP | sort >> $envFile

    expandVariables $envFile < input.nml.unexpanded > input.nml || exit 1

    rm -f $envFile

    # ---------------- prepare MPI call, execute it, analyze results

    if ( $target =~ '*openmp*' ) then
      if ( ! $?OMP_NUM_THREADS ) setenv OMP_NUM_THREADS 1
    else
      unsetenv OMP_NUM_THREADS
    endif 

    runCommand |& tee fms.out

    if ( $status == 0 ) then

      if ( $echoOn ) unset echo
      echo "<NOTE> : Normal exit from the runCommand..."
      if ( $echoOn ) set echo

    else

      set msg =       "*ERROR*: Automatic message from the job '$FRE_JOBID'\n"
      set msg = "${msg}*ERROR*: -----------------------------------------------------------------------\n"
      set msg = "${msg}*ERROR*: The MPI launcher has failed...\n"
      set msg = "${msg}*ERROR*: \n"
      set msg = "${msg}*ERROR*: The job stdout:\n"
      set msg = "${msg}*ERROR*: \n"
      set msg = "${msg}*ERROR*: \t$stdoutDir/$FRE_JOBID\n"
      set msg = "${msg}*ERROR*: \n"

      set coreFiles = ( `ls core*` )

      if ( $#coreFiles > 0 ) then

	if ( ! $?MPI_COREDUMP_DEBUGGER ) setenv MPI_COREDUMP_DEBUGGER 'idb'

        set coreFileFirst = $coreFiles[1]
        echo "Dump of the core file '$coreFileFirst'" > $coreFileFirst.out
        $MPI_COREDUMP_DEBUGGER $executable:t $coreFileFirst >> $coreFileFirst.out
        cat $coreFileFirst.out >> fms.out
        cat $coreFileFirst.out
        unset coreFileFirst

        set msg = "${msg}*ERROR*: Your job has produced $#coreFiles core files (run $ireload, loop $irun)\n"
        set msg = "${msg}*ERROR*: Please go to the working directory '$workDir' and issue the following command for each core file there:\n"
        set msg = "${msg}*ERROR*: \n"

        @ count = 0
        @ countMax = 20

        foreach coreFile ( $coreFiles )
          set msg = "${msg}*ERROR*: \t$MPI_COREDUMP_DEBUGGER $executable:t $coreFile >> $coreFile.out\n"
          if ( $count < $countMax ) then
            @ count++
          else
            break
          endif
        end

        set msg = "${msg}*ERROR*: \n"
        set msg = "${msg}*ERROR*: FRE has executed the command above for one core file and echoed the result to the job stdout.\n"

        if ( $count == $countMax ) then
          set msg = "${msg}*ERROR*: In order to save space only the first $countMax core files are presented in this list.\n"
          set msg = "${msg}*ERROR*: \n"
        endif

        unset countMax
        unset count

      else

        set cdsize = `limit coredumpsize`
        set msg = "${msg}*ERROR*: No core files produced (run $ireload, loop $irun)\n"
        set msg = "${msg}*ERROR*: You are using the $cdsize\n"
        set msg = "${msg}*ERROR*: \n"
        unset cdsize

      endif

      set msg = "${msg}*ERROR*: -----------------------------------------------------------------------\n"
      set msg = "${msg}*ERROR*: This message has been generated by FRE\n"
      set msg = "${msg}*ERROR*: `date`"

      if ( $echoOn ) unset echo
      printf "$msg"
      if ( $echoOn ) set echo

      unset coreFiles
      unset msg

      set outputDir = ${outputDir}_crash

      set MPI_FAIL

    endif

    # ---------------- generate date for file names

    set begindate = `timeStamp -b`
    if ( $begindate == 'no_time_stamp' ) set begindate = tmp`date '+%j%H%M%S'`
    set enddate = `timeStamp -e`
    if ( $enddate == 'no_time_stamp' ) set enddate = tmp`date '+%j%H%M%S'`
    set fyear = `echo $enddate | cut -c -4`

    # ---------------- commands, copied from XML (experiment/postProcess/csh)

    #FRE experiment-postprocess-csh

    cd $workDir

    # ---------------- remove time_stamp.out file

    if ( -f time_stamp.out ) rm -f time_stamp.out

    # ---------------- save ascii files

    set asciiFiles = ( `ls -1 | egrep "$patternGrepAscii"` )

    if ( $#asciiFiles > 0 ) then

      set asciiSuffix = ascii/$begindate.ascii_out
      set asciiArchDir = $outputDir/$asciiSuffix
      set asciiWorkDir = $tmpOutputDir$asciiArchDir

      prepareDir $asciiWorkDir 'clean' || exit 1 

      foreach file ( $asciiFiles )
	mv -f $file $asciiWorkDir/$begindate.$file
      end

      if ( $?flagOutputCompressAsciiOn ) then
        hsmput --zip $asciiArchDir:s+/++
      else
        hsmput $asciiArchDir:s+/++
      endif

      if ( $status == 0 ) then
        if ( $echoOn ) unset echo
        echo "<NOTE> : The ascii directory '$asciiArchDir' has been processed successfully"
        if ( $echoOn ) set echo
      else
        if ( $echoOn ) unset echo
        echo "*ERROR*: Can't process the ascii directory '$asciiArchDir'"
        if ( $echoOn ) set echo
        exit 1
      endif

      rm -fr $asciiWorkDir

      unset asciiWorkDir
      unset asciiArchDir
      unset asciiSuffix

    endif

    unset asciiFiles

    # ---------------- save restart files, namelist, tables etc. and move them from RESTART to INPUT

    pushd $workDir/RESTART

    set restartFiles = ( `ls -1 | egrep "$patternGrepRestart"` )

    if ( $#restartFiles > 0 ) then

      set restartSuffix = restart/$enddate
      set restartArchDir = $outputDir/$restartSuffix
      set restartWorkDir = $tmpOutputDir$restartArchDir

      prepareDir $restartWorkDir 'clean' || exit 1 

      ls -1 | egrep "$patternGrepRestart" | xargs ln --force --target-directory=$restartWorkDir

      cp --force --preserve=mode,ownership,timestamps $workDir/input.nml	$restartWorkDir
      cp --force --preserve=mode,ownership,timestamps $workDir/*_table		$restartWorkDir
      cp --force --preserve=mode,ownership,timestamps $rtsxml			$restartWorkDir
      cp --force --preserve=mode,ownership,timestamps $scriptName		$restartWorkDir

      if ( $?flagRunTypeRegression && $irun == $segmentsPerJob ) then

	pushd $restartWorkDir

        set filesToCombine = ( `ls -1 | egrep "($patternGrepRestart).*$patternGrepTail" | sed -r "s/$patternGrepTail//g" | sort -u` )

	if ( $#filesToCombine > 0 ) then
          set combineTimeBeg = `date "+%s"`
	  foreach file ( $filesToCombine )
	    set inputFiles = ( `ls -1 | egrep "^$file$patternGrepTail"` )
	    if ( $#inputFiles > 0 ) then
	      slmnccompressed $inputFiles[1]
              if ( $status == 0 ) then
        	( slmnccombine $inputFiles $file && rm -f $inputFiles || touch $file.$tagFail ) &
              else
        	( mppnccombine $file $inputFiles || touch $file.$tagFail ) &
              endif
	    endif
            unset inputFiles
	  end
          wait
        endif

        unset filesToCombine

	set filesNotOK = ( `ls -1 | egrep "$patternGrepFail"` )

	if ( $#filesNotOK > 0 ) then
	  if ( $echoOn ) unset echo
	  foreach file ( $filesNotOK )
	    echo "*ERROR*: A problem during combining the restart file '$file:r'"
            rm -f $file
	  end
	  echo "*ERROR*: Failed to combine restart files"
	  if ( $echoOn ) set echo
	  exit 1
	else if ( $?combineTimeBeg ) then
	  set combineTimeEnd = `date "+%s"`
	  set combineTime = `echo "$combineTimeEnd - $combineTimeBeg" | bc -l`
	  if ( $echoOn ) unset echo
	  echo "<NOTE> : All the restart files have been combined successfully"
	  echo "<NOTE> : Time to combine = '$combineTime' (seconds)"
	  if ( $echoOn ) set echo
          unset combineTime
          unset combineTimeEnd
          unset combineTimeBeg 
	else
	  if ( $echoOn ) unset echo
	  echo "<NOTE> : No uncombined restart files have been found"
	  if ( $echoOn ) set echo
	endif

	unset filesNotOK 

	popd

      endif

      if ( $?flagOutputCompressRestartOn ) then
        hsmput --zip $restartArchDir:s+/++
      else
        hsmput $restartArchDir:s+/++
      endif

      if ( $status == 0 ) then
        if ( $echoOn ) unset echo
        echo "<NOTE> : The restart directory '$restartArchDir' has been processed successfully"
        if ( $echoOn ) set echo
      else
        if ( $echoOn ) unset echo
        echo "*ERROR*: Can't process the restart directory '$restartArchDir'"
        if ( $echoOn ) set echo
        exit 1
      endif

      if ( $?flagOutputCheckOn ) then
        compareDual $name 0 $restartArchDir.$archExt
      endif

      if ( $irun < $segmentsPerJob ) then
        find $workDir/INPUT   -maxdepth 1 -type f | egrep "$patternGrepRestartNextDrop" | xargs -r rm -f
        find $workDir/RESTART -maxdepth 1 -type f | egrep "$patternGrepRestartNextMove" | xargs -r mv -f -t ../INPUT
      endif

      rm -fr $restartWorkDir

      unset restartWorkDir
      unset restartSuffix

    endif

    popd

    # ---------------- rename region history files

    set regionHistoryFiles = ( `ls -1 | egrep "$patternGrepRegion"` )

    if ( $#regionHistoryFiles > 0 ) then
      foreach file ( $regionHistoryFiles )
        mv -f $file `echo $file | sed -r "s/$patternGrepRegion//"`
      end
    endif

    unset regionHistoryFiles

    # ---------------- combine and save history files

    set historyFiles = ( `ls -1 | egrep "$patternGrepHistory"` )

    if ( $#historyFiles > 0 ) then

      set historySuffix = history/$begindate.nc
      set historyArchDir = $outputDir/$historySuffix
      set historyWorkDir = $tmpOutputDir$historyArchDir

      prepareDir $historyWorkDir 'clean' || exit 1

      ls -1 | egrep "$patternGrepHistory" | xargs -I'{}' mv --force '{}' $historyWorkDir/$begindate.'{}'

      if ( $?flagOutputCombineHistoryOn ) then

        pushd $historyWorkDir

	set filesToCombine = ( `ls -1 | egrep "($patternGrepHistory).*$patternGrepTail" | sed -r "s/$patternGrepTail//g" | sort -u` )

        if ( $#filesToCombine > 0 ) then
          set combineTimeBeg = `date "+%s"`
	  foreach file ( $filesToCombine )
            set inputFiles = ( `ls -1 | egrep "^$file$patternGrepTail"` )
            if ( $#inputFiles > 0 ) then
       	      ( mppnccombine $file $inputFiles || touch $file.$tagFail ) &
            endif
            unset inputFiles
	  end
	  wait
        endif

        unset filesToCombine

	set filesNotOK = ( `ls -1 | egrep "$patternGrepFail"` )

	if ( $#filesNotOK > 0 ) then
	  if ( $echoOn ) unset echo
	  foreach file ( $filesNotOK )
	    echo "*ERROR*: A problem during combining the history file '$file:r'"
            rm -f $file
	  end
	  echo "*ERROR*: Failed to combine history files"
	  if ( $echoOn ) set echo
	  exit 1
	else if ( $?combineTimeBeg ) then
	  set combineTimeEnd = `date "+%s"`
	  set combineTime = `echo "$combineTimeEnd - $combineTimeBeg" | bc -l`
	  if ( $echoOn ) unset echo
	  echo "<NOTE> : All the history files have been combined successfully"
	  echo "<NOTE> : Time to combine = '$combineTime' (seconds)"
	  if ( $echoOn ) set echo
          unset combineTime
          unset combineTimeEnd
          unset combineTimeBeg 
	else
	  if ( $echoOn ) unset echo
	  echo "<NOTE> : No uncombined history files have been found"
	  if ( $echoOn ) set echo
	endif

	unset filesNotOK 

        popd

      endif

      if ( $?flagOutputCompressHistoryOn ) then
        hsmput --zip $historyArchDir:s+/++
      else
        hsmput $historyArchDir:s+/++
      endif

      if ( $status == 0 ) then
        if ( $echoOn ) unset echo
        echo "<NOTE> : The history directory '$historyArchDir' has been processed succesfully"
        if ( $echoOn ) set echo
      else
        if ( $echoOn ) unset echo
        echo "*ERROR*: Can't process the history directory '$historyArchDir'"
        if ( $echoOn ) set echo
        exit 1
      endif

      if ( $?flagOutputCheckOn ) then
        compareDual $name 0 $historyArchDir.$archExt
      endif

      rm -fr $historyWorkDir

      unset historyWorkDir
      unset historyArchDir
      unset historySuffix

    endif

    unset historyFiles

    # ---------------- terminate script if MPI failed

    if ( $?MPI_FAIL ) then

      if ( $echoOn ) unset echo
      echo "*ERROR*: The MPI failed (run $ireload, loop $irun)"
      echo "*ERROR*: Any output that may have been generated is in the '$outputDir'"
      echo "*ERROR*: The '$workDir' is being kept for possible debugging"
      if ( $echoOn ) set echo

      exit 1

    endif

    # ---------------- terminate script if there are no restart files

    if ( $#restartFiles == 0 ) then

      if ( $echoOn ) unset echo
      echo "*ERROR*: no restart files exist (run $ireload, loop $irun)"
      if ( $echoOn ) set echo

      exit 1

    endif

    # ---------------- write new reload information (production runs only)

    if ( $?flagRunTypeProduction ) then

      if ( $irun < $segmentsPerJob ) then
	@ irunNext = $irun + 1
      else
	@ ireload++
	@ irunNext = 1
      endif

      if ( -f $reload_file ) mv -f $reload_file ${reload_file}_prev
      touch $reload_file

      if ( $status == 0 ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : Writing reload information to the reload file '$reload_file' at `date +%s`"
	if ( $echoOn ) set echo
	echo "@ ireload       =   $ireload"			>> $reload_file
	echo "@ irun          =   $irunNext"			>> $reload_file
	echo "set initCond    =   $restartArchDir.$archExt"	>> $reload_file
	echo "set fyear       =   $fyear"			>> $reload_file
        chmod 644 $reload_file
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The reload file '$reload_file' can't be saved"
        if ( $echoOn ) set echo
        exit 1
      endif

      unset irunNext

    endif

    # ---------------- unset remaining restart variables

    unset restartArchDir
    unset restartFiles

    # ---------------- increment loop counters

    @ currentSeg++
    @ irun++

  end

################################################################################
#--------------------------- after the main loop -------------------------------
################################################################################

  banner ending

  # ---------------- reload and resubmit if needed (production runs only)

  if ( $?flagRunTypeProduction ) then

    if ( $ireload <= $jobsPerSimulation && $currentSeg <= $segmentsPerSimulation ) then

      if ( -f $queue_file ) then
	if ( -r $queue_file ) then
	  source $queue_file
	else
	  if ( $echoOn ) unset echo
	  echo "*ERROR*: The queue file '$queue_file' is not readable"
          if ( $echoOn ) set echo
	  exit 1
	endif
      endif

      if ( ! $continueFlag ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : Stopping execution"
	if ( $echoOn ) set echo
	exit 0
      endif

      if ( -f $scriptName ) then
        batch -f $scriptName
      else
	if ( $echoOn ) unset echo
	echo "WARNING: The script '$scriptName' does not exist (run $ireload, loop $irun) - it can't be resubmitted"
        if ( $echoOn ) set echo
      endif

      if ( -f $queue_file ) mv -f $queue_file ${queue_file}_prev
      touch $queue_file

      if ( $status == 0 ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : Writing queue information to the queue file '$queue_file' at `date +%s`"
	if ( $echoOn ) set echo
        echo "set continueFlag = $continueFlag" >> $queue_file
        chmod 644 $queue_file
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The queue file '$queue_file' can't be saved"
        if ( $echoOn ) set echo
        exit 1
      endif

    endif

  endif

  # ---------------- working directory cleaning

  if ( $?flagWorkDirCleanOn ) then
    rm -fr $workDir
  endif

  # ---------------- normal end of script 

  set -r runtimeEnd = `date "+%s"`
  set -r runtime = `echo "$runtimeEnd - $runtimeBeg" | bc -l`

  if ( $echoOn ) unset echo
  echo "<NOTE> : Finishing on `date`"
  echo "<NOTE> : Runtime = '$runtime' (seconds)"
  echo "<NOTE> : Natural end-of-script for '$scriptName'"
  if ( $echoOn ) set echo

  exit 0
