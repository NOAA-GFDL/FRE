#!/bin/csh -fx
#FRE scheduler-options
# 
# $Id: runscript.template.main,v 1.1.4.84.4.1.2.2.2.1 2013/01/04 01:12:15 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Runscript Template - NCRC Version
# ------------------------------------------------------------------------------
# arl    Ver   1.00  Copied from the NCCS version                   July 10
# afy -------------- Branch 1.1.4 --------------------------------- August 10
# afy    Ver   1.00  Cosmetics                                      August 10
# afy    Ver   1.01  Fix check for 'fre-transfer' module            August 10
# afy    Ver   1.02  Fix check for 'fre-nctools' module             August 10
# afy    Ver   1.03  Revive sending ascii/restarts to the GFDL      August 10
# afy    Ver   2.00  Balance 'set echo'/'unset echo'                August 10
# afy    Ver   2.01  Make online combining similar to the GFDL one  August 10
# afy    Ver   2.02  Modify alias 'send_file'                       August 10
# afy    Ver   2.03  Rename alias 'qsub' => 'submit'                August 10
# afy    Ver   2.04  Modify alias 'submit' (add option -V)          August 10
# afy    Ver   2.05  Modify call to 'combine*' (add 'stdout')       August 10
# afy    Ver   2.06  Add alias 'tar'                                August 10
# afy    Ver   3.00  Add flagOutputCheck settable constant          August 10
# afy    Ver   3.01  Add constant 'patternSedRestartProduction'     August 10
# afy    Ver   3.02  Add constant 'patternSedRestartRegression'     August 10
# afy    Ver   3.03  Add restart archives checking                  August 10
# afy    Ver   3.04  New pragmas for flags/constants/variables      August 10
# afy    Ver   3.05  Merge flagTransfer* settable constants         August 10
# afy    Ver   3.06  Fix ascii/restart directories creation         August 10
# afy    Ver   3.07  Fix multi-segment restarts/history creation    August 10
# afy    Ver   3.08  Remove combineList variable                    August 10
# afy    Ver   4.00  Rename combine_parallel.csh => fresavehist     August 10
# afy    Ver   5.00  Fix a problem with flagOutputTransfer          August 10
# afy    Ver   5.01  Cosmetics in the output stager call            August 10
# afy    Ver   6.00  Add refine diagnostics scripts processing      August 10
# afy    Ver   6.01  Cosmetics in file sender calls                 August 10
# afy    Ver   6.02  Revive combineList variable                    August 10
# afy    Ver   6.03  Modify region files combining (use children)   August 10
# afy    Ver   6.04  Modify online combining (exit, send, frepp)    August 10
# afy    Ver   6.05  Modify staged combining (check, frepp)         August 10
# afy    Ver   6.06  Add offline/bySegment combining (stub for now) August 10
# afy    Ver   7.00  Fix constant 'patternSedRestartProduction'     August 10
# afy    Ver   7.01  Fix constant 'patternSedRestartRegression'     August 10
# afy    Ver   7.02  Add alias 'ardiff'                             August 10
# afy    Ver   7.03  Unique filenames to avoid partial comparison   August 10
# afy    Ver   7.04  Add alias 'unique'                             August 10
# afy    Ver   7.05  Modify restarts checking (add polling/delay)   August 10
# afy    Ver   7.06  Fix staged combining (frepp condition)         August 10
# afy    Ver   7.07  Fix output stager calls (frepp parameter)      August 10
# afy    Ver   8.00  Modify alias 'submit' (use msub!)              September 10
# afy    Ver   8.01  Add alias 'submitFileSender'                   September 10
# afy    Ver   9.00  Add a check for the PBS_O_WORKDIR presence     September 10
# afy    Ver   9.01  Remove all the references to the PBS_QUEUE     September 10
# afy    Ver   9.02  Add default PBS_JOBNAME, adjust it later       September 10
# afy    Ver   9.03  Modify alias 'submitFileSender' (use qsub!)    September 10
# afy    Ver  10.00  Modify alias 'submitFileSender' (msub -q ldtn) September 10
# afy    Ver  11.00  Modify alias 'submitFileSender' (gaea!, size)  September 10
# afy    Ver  11.01  Add alias 'submitOutputStager'                 September 10
# afy    Ver  12.00  Add constants 'fileSender(Partition|Queue)'    October 10
# afy    Ver  12.01  Modify alias 'submitFileSender' (use ^)        October 10
# afy    Ver  12.02  Add constants 'outputStager(Partition|Queue)'  October 10
# afy    Ver  12.03  Modify alias 'submitOutputStager' (use ^)      October 10
# afy    Ver  13.00  Modify 'npes' type (const => var)              October 10
# afy    Ver  13.01  Add settable constants 'outputStager*'         October 10
# afy    Ver  13.02  Add settable constants 'fileSender*'           October 10
# afy    Ver  13.03  Don't adjust 'ptmpDir' from FRE_INPUT_DIR      October 10
# afy    Ver  13.04  Add branch for FRE_STAGE == CHAIN              October 10
# afy    Ver  13.05  Add alias 'frepp'                              October 10
# afy    Ver  13.06  Modify alias 'submit' (remove option -V)       October 10
# afy    Ver  13.07  Use shortened PBS_JOBID in filenames           October 10
# afy    Ver  14.00  Modify gridSpec/initCond loading (branch 'nc') October 10
# afy    Ver  14.01  Remove work directory in staging mode          October 10
# afy    Ver  14.02  Modify all 'find' calls (no -exec/-regex)      October 10
# afy    Ver  14.03  Add alias 'find' (= lfs find)                  October 10
# afy    Ver  14.04  Modify submitOutputStager (size: 1 => 48)      October 10
# afy    Ver  15.00  Add settable constant 'platform'               October 10
# afy    Ver  15.01  Modify output stager submitting (parameters)   October 10
# afy    Ver  16.00  Modify restarts combining (check, pattern)     October 10
# afy    Ver  17.00  Add settable constant 'target'                 October 10
# afy    Ver  17.01  Adjust OMP_NUM_THREADS based on target         October 10
# afy    Ver  18.00  Add 'unsetenv PBS_SERVER' (to fix Moab bug)    November 10
# afy    Ver  18.01  Modify submitOutputStager (walltime: 4 => 16)  November 10
# afy    Ver  19.00  Maximize the walltime for all file senders     November 10
# afy    Ver  19.01  Modify submitOutputStager (size => nodes:ppn)  November 10
# afy    Ver  20.00  Rename flag*CombineType => flag*StagingType    November 10
# afy    Ver  20.01  Rename flag*Combine => flag*CombineHistory     November 10
# afy    Ver  20.02  Use hsmget to copy the executable              November 10
# afy    Ver  20.03  Use compare_dual.csh to check restarts         November 10
# afy    Ver  20.04  Use compare_dual.csh to check history (new!)   November 10
# afy    Ver  20.05  Add banners (prologue/irun/epilogue)           November 10
# afy    Ver  20.06  Use 'hsmput' to save ascii/restarts/history    November 10
# afy    Ver  20.07  Add alias 'aprun' (temporarily)                November 10
# afy    Ver  21.00  Rename alias 'aprun' => 'runCommand'           November 10
# afy    Ver  22.00  Modify alias 'submitOutputStager' (16 => 12)   November 10
# afy    Ver  22.01  Modify banners (prologue => PBS_JOBNAME)       November 10
# afy    Ver  23.00  Modify fileSenderTime* constants (16 => 12)    November 10
# afy    Ver  24.00  Modify aliases 'submit*' (add -m abe)          November 10
# afy    Ver  25.00  Standardize the script beginning               December 10
# afy    Ver  25.01  Make all the '*Time' constants settable        December 10
# afy    Ver  25.02  Add settable constant 'mailMode'               December 10
# afy    Ver  26.00  Don't check presence of refine scripts         January 11
# afy    Ver  27.00  Improve the 'reload_commands' file handling    February 11
# afy    Ver  27.01  Add the 'queue_commands' file processing       February 11
# afy    Ver  28.00  Fix loop counters incrementing                 February 11
# afy    Ver  28.01  Don't remove state files                       February 11
# afy    Ver  29.00  Add alias 'submitNext'                         March 11
# afy    Ver  30.00  Add settable alias 'runCommand'                March 11
# afy    Ver  31.00  Prepend 'cp -p' calls by 'ln -f' calls         March 11
# afy    Ver  31.01  Remove 'fre-transfer' submodule                March 11
# afy    Ver  31.02  Remove 'FREROOT' environment variable          March 11
# afy    Ver  31.03  Add aliases '(set|get)StripingMode'            March 11
# afy    Ver  32.00  Modify alias 'mppnccombine' (aprun)            May 11
# afy    Ver  32.01  Modify alias 'slmnccombine' (aprun)            May 11
# afy    Ver  33.00  Revamping to adapt to the new output stager    May 11
# afy    Ver  33.01  Add work directory cleaner call/submitting     May 11
# afy    Ver  33.02  Remove Globus settings (!?)                    May 11
# afy    Ver  33.03  Absolute segment number printing               May 11
# afy    Ver  33.04  Call the script with -fx options               May 11
# afy    Ver  33.05  Conditional unset echo/set echo                May 11
# afy    Ver  33.06  Standardize jobName/jobNameFull determination  May 11
# afy    Ver  33.07  Redesign post-processing starter submitting    May 11
# afy    Ver  34.00  Add settable constant 'stateDir'               May 11
# afy    Ver  34.01  Use new 'prepare_dir.csh' helper script        May 11
# afy    Ver  34.02  Add alias 'gcp'                                May 11
# afy    Ver  35.00  Use new 'output.stager' (saveOn => ptmpOn)     May 11
# afy    Ver  35.01  Elaborate restarts saving                      May 11
# afy    Ver  35.02  Don't chmod the stdout file                    May 11
# afy    Ver  35.03  Simplify aliases 'submit*'                     May 11
# afy    Ver  36.00  Use dummy file to create the remote stdoutDir  May 11
# afy    Ver  36.01  Copy the XML file with mirroring               May 11
# afy    Ver  37.00  More careful XML file copying (with backup)    May 11
# afy    Ver  38.00  Modify alias 'gcp' (no --create-dirs)          May 11
# afy    Ver  39.00  Clarifications in the XML copying              May 11
# afy    Ver  40.00  Don't copy the XML file (temporarily?)         May 11
# afy    Ver  41.00  Modify patternSed(Home|FS|LTFS) (destination)  May 11
# afy    Ver  41.01  Replicate the XML file (rather sync?)          May 11
# afy    Ver  42.00  Modify pp.starter submission (add target)      May 11
# afy    Ver  43.00  New constant FRE_JOBID (used in workDir)       June 11
# afy    Ver  44.00  New separator '&' for PP refine diag scripts   June 11
# afy    Ver  45.00  Add settable constant 'project'                June 11
# afy    Ver  45.01  Revamp all the Moab submission options         June 11
# afy    Ver  45.02  Use the wrapper 'batch.scheduler.submit' (!)   June 11
# afy    Ver  45.03  Make pp.starter depend on ALL history jobs     June 11
# afy    Ver  45.04  Make next job depend on the last restart       June 11
# afy    Ver  45.05  Check status after ALL submissions             June 11
# afy    Ver  46.00  Fix job id assigment after the 'msub' fail     June 11
# afy    Ver  46.01  Load module XML-LibXML (for helper scripts)    June 11
# afy    Ver  47.00  Get remote environment string in two steps     June 11
# afy    Ver  48.00  Fix the 'ppOptions' variable evaluation        June 11
# afy    Ver  49.00  Add 'DEBUG' input staging                      June 11
# afy    Ver  49.01  Move the input staging control section         June 11
# afy    Ver  50.00  Split restarts output staging into two steps   June 11
# afy    Ver  50.01  Save 'reload_commands' in the job end only     June 11
# afy    Ver  50.02  Fix the remote environment packing             June 11
# afy    Ver  50.03  Rename output stager jobs                      June 11
# afy    Ver  51.00  Protect 'msub' options by combined quotes      June 11
# afy    Ver  51.01  Modify the after-MPI-crash section             June 11
# afy    Ver  52.00  Files/dirs for pp starter in a separate job    June 11
# afy    Ver  53.00  Save unexpanded namelists, then expand them    June 11
# afy    Ver  53.01  Process the *OutputHashing* flag               June 11
# afy    Ver  53.02  Redesign constants 'patternGrep*'              June 11
# afy    Ver  53.03  Modify patternGrepAscii (add three patterns)   June 11
# afy    Ver  53.04  Modify patternGrepRestart (add pattern)        June 11
# afy    Ver  54.00  Rename 'flagOutputHashing' => 'flagCheckSum'   June 11
# afy    Ver  55.00  Split ascii/history outstaging in two steps    June 11
# afy    Ver  55.01  Don't use the Moab option -V                   June 11
# afy    Ver  55.02  Add delay before the second $envFile update    June 11
# afy    Ver  55.03  Modify the $envFile location                   June 11
# afy    Ver  55.04  Modify remote output directory after crash     June 11
# afy    Ver  56.00  Don't pass the whole PATH to subjobs           July 11
# afy    Ver  56.01  Don't use the HOSTNAME variable                July 11
# afy    Ver  56.02  Process multi-part XML files                   July 11
# afy    Ver  57.00  Don't prepend the PERL5LIB variable            July 11
# afy    Ver  57.01  Don't load module XML-LibXML                   July 11
# afy    Ver  57.02  Add saving 'set -r' into the $envFile          July 11
# afy    Ver  57.03  Add settable constant 'flagArgFiles'           July 11
# afy    Ver  57.04  Add settable constants 'flagOutputCache*'      July 11
# afy    Ver  57.05  Add settable constants 'flagOutputCompress*'   July 11
# afy    Ver  57.06  Implement arguments passing via argFiles       July 11
# afy    Ver  57.07  Set remote output directories based on flags   July 11
# afy    Ver  58.00  Fix a bug with 'set -r'                        July 11
# afy    Ver  59.00  Allow caching for history only                 July 11
# afy    Ver  60.00  Don't exit after fail to submit pp.starter     August 11
# afy    Ver  61.00  Add settable constant 'hourslist'              August 11
# afy    Ver  61.01  Rename 'timeStampFormat' => 'timeStampOptions' August 11
# afy    Ver  61.02  Remove settable constant 'flagArgFiles'        August 11
# afy    Ver  61.03  Save intermediate restarts                     August 11
# afy    Ver  61.04  Simplify the irunNext logic                    August 11
# afy    Ver  62.00  Remove separate region files processing        August 11
# afy    Ver  62.01  Redesign logics after the aprun fail           August 11
# afy    Ver  62.02  Call output stager with argfile in online mode August 11
# afy    Ver  62.03  Pass the compress option to the output stager  August 11
# afy    Ver  62.04  Don't pass the user path to the output stager  August 11
# afy    Ver  62.05  Don't pass the user path to the pp preparer    August 11
# afy    Ver  63.00  Fix emailing from the runscript                September 11
# afy    Ver  64.00  Fix emailing from the runscript (printf)       September 11
# arl    Ver  65.00  Better wording for after-the-crash email       September 11
# arl    Ver  66.00  Add stdout to the after-crash email            September 11
# arl    Ver  67.00  Modify the 'patternGrepAscii' (more files)     September 11
# afy    Ver  68.00  Fix emailing from the runscript                September 11
# afy    Ver  68.01  Rename 'combineFreq' => 'segmentsPerPPCall'    September 11
# afy    Ver  68.02  Rename '*Transfer*' => '*Xfer*'                September 11
# afy    Ver  68.03  Tweak the 'gcpInfo' (use 'find_module_info')   September 11
# afy    Ver  68.04  Tweak the 'envRemote' (prepend $ by backslash) September 11
# afy    Ver  68.05  Modify the ppRefineDiag* separator (& => +)    September 11
# afy    Ver  68.06  Move the ppPreparer logics to the outStager    September 11
# afy    Ver  68.07  Implement the 'chained' output staging (!)     September 11
# afy    Ver  68.08  Add the $freCommandsHomeDir/sbin to the PATH   September 11
# afy    Ver  68.09  More strict condition to post-process          September 11
# afy    Ver  69.00  Remove striping parameters/commands            October 11
# afy    Ver  69.01  Add settable constant 'modulesHomeDir'         October 11
# afy    Ver  69.02  Add settable constant 'stdoutDirRemote'        October 11
# afy    Ver  69.03  Add settable constant 'stmpDirRemote'          October 11
# afy    Ver  69.04  Add settable constant 'archiveDirRemote'       October 11
# afy    Ver  69.05  Add settable constant 'platformRemote'         October 11
# afy    Ver  69.06  Add settable constant 'envRemote'              October 11
# afy    Ver  69.07  Don't call 'frelist' to get remote settings    October 11
# afy    Ver  69.08  Replace 'setenv' by 'env --unset=TERMCAP'      October 11
# afy    Ver  69.09  Rename region files separately                 October 11
# afy    Ver  70.00  Rename 'gcpModule*' => 'xferToolModule*'       October 11
# afy    Ver  70.01  Switch to 'stdoutDir' before submission        October 11
# afy    Ver  71.00  Rename 'xferTool*Dir' => 'xferTool*FilesDir'   November 11
# afy    Ver  71.01  Add settable constant 'freModuleFilesDir'      November 11
# afy    Ver  71.02  Cosmetics in messages                          November 11
# afy    Ver  72.00  Load 'XML-LibXML' (for the msub wrapper)       November 11
# afy    Ver  73.00  Add the 'freTempDir' argument for outstager    January 12
# afy    Ver  73.01  Add settable flag 'flagWorkDirClean'           January 12
# afy    Ver  74.00  Don't remove the output stager tempDir         January 12
# afy    Ver  74.01  Add checkpointing into the loop beginning      January 12
# afy    Ver  74.02  Improve after-the-MPI-crash message            January 12
# afy    Ver  74.03  Don't echo history files moving                January 12
# afy    Ver  74.04  Add version string to the first message        January 12
# afy    Ver  75.00  Remove version string from the first message   January 12
# afy    Ver  76.00  Fix version string in the first message        January 12
# afy    Ver  76.01  Don't start post-processing after crash        January 12
# afy    Ver  77.00  Set memory option (-l mem) for saving jobs     February 12
# afy    Ver  77.01  Improve after-the-MPI-crash message            February 12
# afy    Ver  78.00  Don't checkpoint in interactive mode           February 12
# afy    Ver  79.00  Fix a typo in checkpointing                    February 12
# afy    Ver  80.00  Use xargs to hardlink restarts                 February 12
# afy    Ver  80.01  Use xargs to move history files                February 12
# afy    Ver  81.00  Use hsmput to save end-of-job restarts         February 12
# afy    Ver  81.01  Add modulefiles directory for 'banner'         February 12
# afy    Ver  82.00  Modify 'submitOptionsCommon' (add -S)          February 12
# afy    Ver  83.00  Modify project/partition/queue initialization  February 12
# afy    Ver  83.01  Add settable constant 'stdoutTmpDir'           February 12
# afy    Ver  83.02  Add settable constants 'finisher*'             February 12
# afy    Ver  83.03  Move constants/aliases to the beginning        February 12
# afy    Ver  83.04  Add (conditional) finisher submission          February 12
# afy    Ver  83.05  Don't pushd into stdoutDir before submission   February 12
# afy    Ver  84.00  Recreate INPUT/RESTART for doublestarts        February 12
# afy -------------- Branch 1.1.4.84.4 ---------------------------- August 12
# afy    Ver   1.00  Load default 'banner' module                   August 12
# afy -------------- Branch 1.1.4.84.4.1.2.2.2 -------------------- January 13
# afy    Ver   1.00  Add settable constants 'windfall*'             January 13
# afy    Ver   1.01  Add variable 'windfallFlag'                    January 13
# afy    Ver   1.02  Add variable 'submitOptionsWindfall'           January 13
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2013
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

#===============================================================================
#FRE version-info
#===============================================================================

  set -r echoOn = $?echo
  set -r runtimeBeg = `date "+%s"`

  if ( $echoOn ) unset echo
  echo '<NOTE> : ====== FRE RUNSCRIPT $Id: runscript.template.main,v 1.1.4.84.4.1.2.2.2.1 2013/01/04 01:12:15 afy Exp $ ======'
  echo "<NOTE> : Starting at $HOST on `date`"
  if ( $echoOn ) set echo

  unalias *

  # ---------------- initialize environment modules

  if ( $echoOn ) unset echo
  #FRE const(modulesHomeDir)
  source $modulesHomeDir/init/tcsh
  module load banner
  setenv COLUMNS 148
  if ( $echoOn ) set echo

  # ---------------- define constants

  if ( $?MOAB_BATCH ) then
    set -r FRE_JOBID = $PBS_JOBNAME:t.o`echo $PBS_JOBID | sed -r 's/^([0-9]+).*$/\1/'`
    set -r projectInit = $MOAB_ACCOUNT
    set -r queueInit = $MOAB_CLASS
    set -r batch 
  else
    set -r FRE_JOBID = $0:t.o`date +%s`
    set -r projectInit = ""
    set -r queueInit = 'batch'
  endif

  # ---------------- print starting banner

  banner $FRE_JOBID

################################################################################
#---------------- global constants and variables, set by frerun ----------------
################################################################################

  #FRE const(windfallFlagInit)

  #FRE const(platform)
  #FRE const(target)
  #FRE const(name)
  #FRE const(rtsxml)
  #FRE const(freModuleFilesDir)
  #FRE const(freCommandsHomeDir)
  #FRE const(stdoutDir)
  #FRE const(stdoutTmpDir)
  #FRE const(stateDir)
  #FRE const(workDir)
  #FRE const(ptmpDir)
  #FRE const(archiveDir)
  #FRE const(scriptName)
  #FRE const(ppRefineDiagScriptNames)
  #FRE const(executable)
  #FRE const(segmentsPerSimulation)
  #FRE const(segmentsPerPPCall)
  #FRE const(segmentsPerJob)
  #FRE const(jobsPerSimulation)
  #FRE const(monthslist)
  #FRE const(dayslist)
  #FRE const(hourslist)
  #FRE const(timeStampOptions)
  #FRE const(baseDate)
  #FRE const(mailMode)
  #FRE const(windfallOptionsSet)
  #FRE const(windfallOptionsUnset)

  #FRE const(stdoutDirRemote)
  #FRE const(stmpDirRemote)
  #FRE const(archiveDirRemote)
  #FRE const(platformRemote)
  #FRE const(envRemote)

  #FRE const(outputStagerSavePartition)
  #FRE const(outputStagerSaveQueue)
  #FRE const(outputStagerSaveCoreSpec)
  #FRE const(outputStagerSaveRuntimeAscii)
  #FRE const(outputStagerSaveRuntimeRestart)
  #FRE const(outputStagerSaveRuntimeHistory)

  #FRE const(outputStagerXferPartition)
  #FRE const(outputStagerXferQueue)
  #FRE const(outputStagerXferCoreSpec)
  #FRE const(outputStagerXferRuntimeAscii)
  #FRE const(outputStagerXferRuntimeRestart)
  #FRE const(outputStagerXferRuntimeHistory)

  #FRE const(workDirCleanerPartition)
  #FRE const(workDirCleanerQueue)
  #FRE const(workDirCleanerCoreSpec)
  #FRE const(workDirCleanerRuntime)

  #FRE const(finisherPartition)
  #FRE const(finisherQueue)
  #FRE const(finisherCoreSpec)
  #FRE const(finisherRuntime)

  #FRE const(ppStarterPartition)
  #FRE const(ppStarterQueue)
  #FRE const(ppStarterCoreSpec)
  #FRE const(ppStarterRuntime)

  #FRE flag(flagRunType)
  #FRE flag(flagCheckSum)
  #FRE flag(flagWorkDirClean)
  #FRE flag(flagOutputType)
  #FRE flag(flagOutputFormat)
  #FRE flag(flagOutputStagingType)
  #FRE flag(flagOutputCacheHistory)
  #FRE flag(flagOutputCombineHistory)
  #FRE flag(flagOutputCompressAscii)
  #FRE flag(flagOutputCompressRestart)
  #FRE flag(flagOutputCompressHistory)
  #FRE flag(flagOutputArchive)
  #FRE flag(flagOutputPostProcess)
  #FRE flag(flagOutputXfer)
  #FRE flag(flagOutputCheck)

  #FRE var(npes)
  #FRE var(outputDir)
  #FRE var(gridSpec)
  #FRE var(initCond)

  #FRE alias(runCommand)

################################################################################
#------------------------ global constants and aliases -------------------------
################################################################################

  # ---------------- machine architecture

  set -r architecture = 'x86_64'

  # ---------------- for compatibility only

  set -r work = $workDir

  # ---------------- HSM site-dependent directory

  set -r hsmSiteDir = $freCommandsHomeDir/site/ncrc

  # ---------------- top directory for all the HSM-copied files

  set -r hsmDir = $workDir/hsm

  # ---------------- top directory for all the temporary output files 

  set -r tmpOutputDir = $workDir/output.stager

  # ---------------- checkpointing directory

  set -r checkPointDir = /usw/checkpoint

  # ---------------- file to save shell plus environment variables

  set -r envFile = /tmp/shell.variables.$FRE_JOBID
  set -r envFileDelay = 2

  # ---------------- selection patterns for grep

  set -r patternGrepTail = '\.[0-9]{4}$'
  set -r patternGrepAscii = '\<out\>|\<results\>|\<timestats\>|\<velocity_truncations\>'
  set -r patternGrepRestart = '\<res\>|\<nc\>|\.input.\tgz$'
  set -r patternGrepRestartNextDrop = '\<res\>'
  set -r patternGrepRestartNextMove = '\<res\>|\<nc\>'
  set -r patternGrepHistory = '\<nc\>'
  set -r patternGrepRegion = '^rregion'

  # ---------------- search and replacement patterns for sed

  set -r patternSedHome = 's/^\/(autofs|ncrc)\/.+\/'$USER'\//\/home\/'$USER'\/ncrc\//'
  set -r patternSedFS = 's/^\/lustre\/fs\/.+\/'$USER'\//\/home\/'$USER'\/ncrc\//'
  set -r patternSedLTFS = 's/^\/lustre\/ltfs\/.+\/'$USER'\//\/home\/'$USER'\/ncrc\//'

  # ---------------- archive extension

  set -r archExt = 'tar'

  # ---------------- batch scheduler output staging options

  set -r submitOptionsCommon = ( -m $mailMode -j oe -r y -W umask=026 -S /bin/tcsh )
  set -r submitOptionsOutputStagerSave = ( $submitOptionsCommon -d $stdoutDir -o $stdoutDir/ -l partition=$outputStagerSavePartition -q $outputStagerSaveQueue )
  set -r submitOptionsOutputStagerXfer = ( $submitOptionsCommon -d $stdoutDir -o $stdoutDir/ -l partition=$outputStagerXferPartition -q $outputStagerXferQueue )
  set -r submitOptionsWorkDirCleaner = ( $submitOptionsCommon -d $stdoutDir -o $stdoutDir/ -l partition=$workDirCleanerPartition -q $workDirCleanerQueue )
  set -r submitOptionsFinisher = ( $submitOptionsCommon -d $stdoutDir -o $stdoutDir/ -l partition=$finisherPartition -q $finisherQueue ) 
  set -r submitOptionsPPStarter = ( $submitOptionsCommon -l partition=$ppStarterPartition -q $ppStarterQueue )

  if ( "$projectInit" != "" ) then
    set submitOptionsProject = ( -A $projectInit )
  else
    set submitOptionsProject = ( )
  endif

  set submitOptionsQueue = ( -q $queueInit )

  # ---------------- output staging type as a string

  set -r outputStagingType = `set -r | grep '^flagOutputStagingType' | sed 's/flagOutputStagingType//'`

  # ---------------- FRE data copying between work directory and archive directory via ptmp directory

  alias hsmget $freCommandsHomeDir/bin/hsmget --quiet --time --makefile=$hsmSiteDir/hsmget.mk --workroot=$hsmDir --ptmproot=$ptmpDir --archroot=//
  alias hsmput $freCommandsHomeDir/bin/hsmput --quiet --time --makefile=$hsmSiteDir/hsmput.mk --workroot=$tmpOutputDir --ptmproot=$ptmpDir --archroot=//

  # ---------------- FRE runscript site-independent helper scripts

  alias expandVariables $freCommandsHomeDir/sbin/expand_variables --verbose
  alias findModuleInfo $freCommandsHomeDir/sbin/find_module_info --verbose
  alias findXIncludes $freCommandsHomeDir/sbin/find_xincludes --verbose
  alias memoryLimit $freCommandsHomeDir/sbin/memory_limit.csh
  alias prepareDir $freCommandsHomeDir/sbin/prepare_dir.csh
  alias timeStamp $freCommandsHomeDir/sbin/time_stamp.csh $timeStampOptions

  # ---------------- FRE runscript site-dependent helper scripts

  alias submit $freCommandsHomeDir/site/ncrc/bin/batch.scheduler.submit --verbose
  alias outputStager $freCommandsHomeDir/site/ncrc/bin/output.stager
  alias workDirCleaner $freCommandsHomeDir/site/ncrc/bin/workDir.cleaner
  alias finisher $freCommandsHomeDir/site/ncrc/bin/finisher

  set -r outputStager = `alias outputStager`
  set -r workDirCleaner = `alias workDirCleaner`
  set -r finisher = `alias finisher`

  # ---------------- library for the 'batch.scheduler.list' script

  if ( $echoOn ) unset echo
  module use $freModuleFilesDir
  module load XML-LibXML/1.70
  if ( $echoOn ) set echo

  # ---------------- finding command

  alias find `which lfs` find

################################################################################
#---------------------------------- finisher -----------------------------------
################################################################################

  if ( $?batch && ! $?FRE_STAGE && ( "$stdoutDir" != "$stdoutTmpDir" ) ) then

    set finisherOptions = ( $submitOptionsProject $submitOptionsFinisher )
    set finisherOptions = ( $finisherOptions -N $FRE_JOBID.finisher)
    set finisherOptions = ( $finisherOptions -l walltime=$finisherRuntime,$finisherCoreSpec )
    set finisherOptions = ( $finisherOptions -v src=$stdoutTmpDir/$FRE_JOBID,dstDir=$stdoutDir )
    set finisherOptions = ( $finisherOptions -l depend=afterany:$MOAB_JOBID )

    set finisherResult = `submit -O "$finisherOptions" $finisher`

    if ( $status == 0 ) then
      if ( $echoOn ) unset echo
      echo "<NOTE> : The finisher job '$finisherResult' has been submitted successfully"
      if ( $echoOn ) set echo
    else
      if ( $echoOn ) unset echo
      echo "WARNING: Can't submit the finisher job"
      if ( $echoOn ) set echo
    endif

    unset finisherResult
    unset finisherOptions

  endif

################################################################################
#--------------------------------- environment ---------------------------------
################################################################################

  # ---------------- commands, copied from XML (setup/platform/csh)

  if ( $echoOn ) unset echo
  #FRE setup-platform-csh
  module list
  if ( $echoOn ) set echo

  # ---------------- exit if no fre-nctools module is loaded

  if ( $?FRE_NCTOOLS_HOME ) then
    if ( $echoOn ) unset echo
    echo "<NOTE> : Using the 'fre-nctools' home directory '$FRE_NCTOOLS_HOME'..."
    if ( $echoOn ) set echo
  else
    if ( $echoOn ) unset echo
    echo "*ERROR*: The script '$scriptName' must load a 'fre-nctools' module"
    if ( $echoOn ) set echo
    exit 1
  endif

  # ---------------- the settings below aren't changeable

  setenv FRE_COMMANDS_HOME $freCommandsHomeDir

  if ( $?PATH ) then
    setenv PATH $freCommandsHomeDir/bin:$freCommandsHomeDir/sbin:$PATH
  else
    setenv PATH $freCommandsHomeDir/bin:$freCommandsHomeDir/sbin
  endif

  # ---------------- some global configuration

  limit stacksize unlimited
  limit coredumpsize unlimited
  limit
      
  # ---------------- exit if not running on right machine architecture

  set machine = `uname -m`

  if ( $machine != $architecture ) then
    if ( $echoOn ) unset echo
    echo "*ERROR*: The script '$scriptName' is intended for the machine architecture '$architecture'"
    if ( $echoOn ) set echo
    exit 1
  endif

  unset machine

  # ---------------- exit if number of days/months/hours is not equal to number of segments per job

  if ( $#dayslist != $segmentsPerJob || $#monthslist != $segmentsPerJob || $#hourslist != $segmentsPerJob ) then
    if ( $echoOn ) unset echo
    echo "*ERROR*: dayslist, monthslist and hourslist lengths must be equal to a number of segments per job"
    if ( $echoOn ) set echo
    exit 1
  endif

  # ---------------- determine the gcp info, exit if no gcp available

  set gcpInfo = ( `findModuleInfo 'gcp'` )

  if ( $status == 0 ) then
    set -r xferToolModuleFilesDir = $gcpInfo[1]
    set -r xferToolModuleFile = $gcpInfo[3]
    if ( $echoOn ) unset echo
    echo "<NOTE> : Using the 'gcp' module directory '$xferToolModuleFilesDir' and modulefile '$xferToolModuleFile'..."
    if ( $echoOn ) set echo
  else
    if ( $echoOn ) unset echo
    echo "*ERROR*: The script '$scriptName' must load a 'gcp' module"
    if ( $echoOn ) set echo
    exit 1
  endif

  unset gcpInfo

  # ---------------- determine the list of xml files, exit if not all of them available

  set xmlFiles = ( `findXIncludes $rtsxml` )

  if ( $status == 0 ) then
    if ( $echoOn ) unset echo
    echo "<NOTE> : All the needed pieces of the XML file have been found"
    if ( $echoOn ) set echo
  else
    if ( $echoOn ) unset echo
    echo "*ERROR*: Can't find all the needed pieces of the XML file"
    if ( $echoOn ) set echo
    exit 1
  endif

  # ---------------- setup the FRE temporary directory, exit if it's not defined

  if ( $?FRE_SYSTEM_TMP ) then
    set -r freTempDir = $FRE_SYSTEM_TMP
    if ( $echoOn ) unset echo
    echo "<NOTE> : Using the '$freTempDir' temporary directory"
    if ( $echoOn ) set echo
    prepareDir $freTempDir || exit 1
  else if ( $?FRE_AFY_SYSTEM_TMP ) then
    set -r freTempDir = $FRE_AFY_SYSTEM_TMP
    if ( $echoOn ) unset echo
    echo "<NOTE> : Using the '$freTempDir' temporary directory"
    if ( $echoOn ) set echo
    prepareDir $freTempDir || exit 1
  else
    if ( $echoOn ) unset echo
    echo "*ERROR*: The FRE temporary directory is not defined"
    if ( $echoOn ) set echo
    exit 1
  endif

################################################################################
#----------------------------- global variables --------------------------------
################################################################################

  set continueFlag = 1

  set windfallFlag = $windfallFlagInit
  set submitOptionsWindfall = ( )

  set combineList = ( )
  set saveJobIds = ( )

  @ ireload = 1
  @ irun = 1

################################################################################
#--------------------------- before the main loop ------------------------------
################################################################################

  # ---------------- commands, copied from XML (experiment/runtime/csh)

  #FRE experiment-runtime-csh

  # ---------------- initialize reloading (production runs only)

  if ( $?flagRunTypeProduction ) then

    prepareDir $stateDir || exit 1

    set reload_file = $stateDir/reload_commands

    if ( -f $reload_file ) then
      if ( -r $reload_file ) then
	source $reload_file
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The reload file '$reload_file' is not readable"
        if ( $echoOn ) set echo
	exit 1
      endif
    endif

    set queue_file = $stateDir/queue_commands

    if ( -f $queue_file ) then
      if ( -r $queue_file ) then
	source $queue_file
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The queue file '$queue_file' is not readable"
        if ( $echoOn ) set echo
	exit 1
      endif
    endif

    if ( ! $continueFlag ) then
      if ( $echoOn ) unset echo
      echo "<NOTE> : Stopping execution"
      if ( $echoOn ) set echo
      exit 0
    endif

  endif

  # ---------------- reassign the batch scheduler project and queue options

  if ( ${?queue} ) then
    set submitOptionsQueue = ( -q $queue )
  endif
  if ( ${?project} ) then
    if ( "${project}" != "" ) then
      set submitOptionsProject = ( -A $project )
    endif
  endif

  if ( $windfallFlag != $windfallFlagInit ) then
    if ( $windfallFlag ) then
      set submitOptionsWindfall = ( $windfallOptionsSet )
    else
      set submitOptionsWindfall = ( $windfallOptionsUnset )
    endif
  endif

  # ---------------- absolute segment number

  @ currentSeg = ( $ireload - 1 ) * $segmentsPerJob + $irun

  # ---------------- set up working directory structure

  if ( -e $workDir ) then
    if ( -d $workDir ) then
      if ( -r $workDir ) then
	if ( -w $workDir ) then
          ls -1 --directory --file-type $workDir/* | grep --fixed-strings --invert-match $tmpOutputDir | xargs rm --force --recursive
          prepareDir $workDir/INPUT 'clean'	|| exit 1
          prepareDir $workDir/RESTART 'clean'	|| exit 1
	else
	  if ( $echoOn ) unset echo
	  echo "*ERROR*: The directory '$workDir' exists, but is not writable"
	  if ( $echoOn ) set echo
	  exit 1
	endif
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The directory '$workDir' exists, but is not readable"
	if ( $echoOn ) set echo
	exit 1
      endif
    else
      if ( $echoOn ) unset echo
      echo "*ERROR*: The pathname '$workDir' exists, but is not a directory"
      if ( $echoOn ) set echo
      exit 1
    endif
  else
    prepareDir $workDir		|| exit 1
    prepareDir $workDir/INPUT	|| exit 1
    prepareDir $workDir/RESTART	|| exit 1
  endif

  # ---------------- input data loading

  cd $workDir

  set dataFilesNotOK = ( )

#dataFiles_from_xml

  if ( $#dataFilesNotOK > 0 ) then
    if ( $echoOn ) unset echo
    foreach dataFile ( $dataFilesNotOK )
      echo "*ERROR*: A problem with the data file: $dataFile"
    end
    echo "*ERROR*: Failed to copy data files"
    if ( $echoOn ) set echo
    exit 1
  endif

  @ gridSpecStatus = 0

  if ( ( $gridSpec:e == 'cpio' || $gridSpec:e == 'tar' ) && $gridSpec:r:e == 'nc' ) then
    hsmget $gridSpec:r:r:s+/++/\* && \
    find $hsmDir$gridSpec:r:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( ( $gridSpec:e == 'cpio' || $gridSpec:e == 'tar' ) && $gridSpec:r:e != 'nc' ) then
    hsmget $gridSpec:r:s+/++/\* && \
    find $hsmDir$gridSpec:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( $gridSpec:e == 'nc' ) then
    hsmget $gridSpec:s+/++ && \
    ln -f $hsmDir/$gridSpec:s+/++ $workDir/INPUT/grid_spec.nc
    @ gridSpecStatus = $status
  else if ( $gridSpec != "" && -d "$gridSpec" ) then
    hsmget $gridSpec:s+/++/\* && \
    find $hsmDir$gridSpec -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ gridSpecStatus = $status
  else if ( $gridSpec != "" && -f "$gridSpec" ) then
    hsmget $gridSpec:s+/++ && \
    ln -f $hsmDir/$gridSpec:s+/++ $workDir/INPUT/grid_spec.nc
    @ gridSpecStatus = $status
  endif

  if ( $gridSpecStatus ) then
    if ( $echoOn ) unset echo
    echo "*ERROR*: Failed to copy grid specification"
    if ( $echoOn ) set echo
    exit 1
  endif

  unset gridSpecStatus 

  @ initCondStatus = 0 

  if ( ( $initCond:e == 'cpio' || $initCond:e == 'tar' ) && $initCond:r:e == 'nc' ) then
    hsmget $initCond:r:r:s+/++/\* && \
    find $hsmDir$initCond:r:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( ( $initCond:e == 'cpio' || $initCond:e == 'tar' ) && $initCond:r:e != 'nc' ) then
    hsmget $initCond:r:s+/++/\* && \
    find $hsmDir$initCond:r -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( $initCond:e == 'nc' ) then
    hsmget $initCond:s+/++ && \
    ln -f $hsmDir/$initCond:s+/++ $workDir/INPUT/.
    @ initCondStatus = $status
  else if ( $initCond != "" && -d "$initCond" ) then
    hsmget $initCond:s+/++/\* && \
    find $hsmDir$initCond -maxdepth 1 -type f | xargs ln -f -t $workDir/INPUT
    @ initCondStatus = $status
  else if ( $initCond != "" && -f "$initCond" ) then
    hsmget $initCond:s+/++ && \
    ln -f $hsmDir/$initCond:s+/++ $workDir/INPUT/.
    @ initCondStatus = $status
  endif

  if ( $initCondStatus ) then
    if ( $echoOn ) unset echo
    echo "*ERROR*: Failed to copy initial conditions"
    if ( $echoOn ) set echo
    exit 1
  endif

  unset initCondStatus 

  # ---------------- the executable loading

  hsmget $executable:s+/++

  # ---------------- commands, copied from XML (experiment/input/csh[not(@type="always") and not(@type="postInit")])

  #FRE experiment-input-csh-init

  cd $workDir

  # ---------------- list files in the INPUT directory

  if ( $echoOn ) unset echo
  ls -l INPUT/*
  if ( $echoOn ) set echo

  # ---------------- executable and tables loading

  ln -f $ptmpDir$executable . || cp -pf $ptmpDir$executable .

  if ( $status == 0 ) then
    if ( $echoOn ) unset echo
    echo "<NOTE> : Using the executable '$ptmpDir$executable'"
    if ( $echoOn ) set echo
  else
    if ( $echoOn ) unset echo
    echo "*ERROR*: Failed to copy the executable"
    if ( $echoOn ) set echo
    exit 1
  endif

#diagTable_from_xml
#fieldTable_from_xml

  touch data_table

#dataTable_from_xml
#tracerTreeTable_from_xml
#tracerTreeInit_from_xml
#namelists_from_xml

  # ---------------- expand namelists 

  set months = $monthslist[1]
  set days = $dayslist[1]
  set hours = $hourslist[$irun]

  set | sort > $envFile
  sleep $envFileDelay
  set -r | sort >> $envFile
  sleep $envFileDelay
  env --unset=TERMCAP | sort >> $envFile

  expandVariables $envFile < input.nml.unexpanded > input.nml || exit 1

  rm -f $envFile

  # ---------------- normal exit if in the input data staging mode

  if ( $?FRE_STAGE ) then
    if ( $FRE_STAGE == 'CHAIN' ) then
      if ( -f $scriptName ) then
        if ( -r $scriptName ) then
	  set result = `submit $scriptName`
	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The job '$result' to run the '$scriptName' has been submitted successfully"
            if ( $echoOn ) set echo
	    workDirCleaner $workDir
	    if ( $echoOn ) unset echo
	    echo "<NOTE> : Natural end-of-input-chaining for '$scriptName'"
	    if ( $echoOn ) set echo
	    exit 0
	  else
	    workDirCleaner $workDir
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the '$scriptName'"
            if ( $echoOn ) set echo
            exit 1
	  endif
          unset result
        else
          workDirCleaner $workDir
	  if ( $echoOn ) unset echo
	  echo "*ERROR*: The script '$scriptName' exists, but is not readable - it can't be submitted"
          if ( $echoOn ) set echo
          exit 1
        endif
      else
        workDirCleaner $workDir
	if ( $echoOn ) unset echo
	echo "*ERROR*: The script '$scriptName' does not exist - it can't be submitted"
        if ( $echoOn ) set echo
        exit 1
      endif
    else if ( $FRE_STAGE == 'DEBUG' ) then
      if ( $echoOn ) unset echo
      echo "<NOTE> : The working directory '$workDir' is ready for debugging"
      echo "<NOTE> : Natural end-of-debug-staging for '$scriptName'"
      if ( $echoOn ) set echo
      exit 0
    else
      workDirCleaner $workDir
      if ( $echoOn ) unset echo
      echo "<NOTE> : Natural end-of-input-staging for '$scriptName'"
      if ( $echoOn ) set echo
      exit 0
    endif
  endif 

  # ---------------- prepare list of refine diagnostics scripts

  set -r ppRefineDiagScriptNamesList = `echo $ppRefineDiagScriptNames | tr ' ' '+'`

################################################################################
#------------------------------ remote settings --------------------------------
################################################################################

  # ---------------- remote output directories

  set outputDirRemoteAscii = $archiveDirRemote
  set outputDirRemoteRestart = $archiveDirRemote

  if ( $?flagOutputCacheHistoryOn ) then
    set outputDirRemoteHistory = $stmpDirRemote
  else
    set outputDirRemoteHistory = $archiveDirRemote
  endif

  # ---------------- remote XML files for post-processing
    
  if ( $?flagOutputXferOn && $?flagOutputPostProcessOn ) then
    set xmlFilesRemote = ( )
    foreach xmlFile ( $xmlFiles )
      set xmlFileRemote = `echo $xmlFile | sed -r "$patternSedHome;$patternSedFS;$patternSedLTFS"` 
      if ( $echoOn ) unset echo
      echo "<NOTE> : The file '$xmlFile' will be copied to the file '$xmlFileRemote' @ GFDL to be used in the post-processing..."
      if ( $echoOn ) set echo
      set xmlFilesRemote = ( $xmlFilesRemote $xmlFileRemote )
      unset xmlFileRemote
    end
    set -r xmlFilesRemote = ( $xmlFilesRemote )
  else
    set -r xmlFilesRemote = ( )
  endif

################################################################################
#------------------------------- the main loop ---------------------------------
################################################################################

  while ( $irun <= $segmentsPerJob && $currentSeg <= $segmentsPerSimulation )

    banner $currentSeg/$segmentsPerSimulation

    # ---------------- test checkpointing conditions and exit if it has been requested

    if ( $?batch ) then
      if ( -e $checkPointDir/all ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : The checkpointing condition 'all' is on - exiting..."
	if ( $echoOn ) set echo
	exit 99
      else if ( -e $checkPointDir/$MOAB_PARTITION ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : The checkpointing condition '$MOAB_PARTITION' is on - exiting..."
	if ( $echoOn ) set echo
	exit 99
      else if ( -e $checkPointDir/$MOAB_PARTITION-$MOAB_CLASS ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : The checkpointing condition '$MOAB_PARTITION-$MOAB_CLASS' is on - exiting..."
	if ( $echoOn ) set echo
	exit 99
      else if ( -e $checkPointDir/$MOAB_USER ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : The checkpointing condition '$MOAB_USER' is on - exiting..."
	if ( $echoOn ) set echo
	exit 99
      endif
    endif

    # ---------------- reload the queue file and exit if it has been requested

    if ( $?flagRunTypeProduction ) then

      if ( -f $queue_file ) then
	if ( -r $queue_file ) then
	  source $queue_file
	else
	  if ( $echoOn ) unset echo
	  echo "*ERROR*: The queue file '$queue_file' is not readable"
          if ( $echoOn ) set echo
	  exit 1
	endif
      endif

      if ( ! $continueFlag ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : Stopping execution"
	if ( $echoOn ) set echo
	exit 0
      endif

      if ( $windfallFlag != $windfallFlagInit ) then
	if ( $windfallFlag ) then
	  set submitOptionsWindfall = ( $windfallOptionsSet )
	else
	  set submitOptionsWindfall = ( $windfallOptionsUnset )
	endif
      else
	set submitOptionsWindfall = ( )
      endif

    endif

    # ---------------- commands, copied from XML (experiment/input/csh[@type="always" or @type="postInit"])

    #FRE experiment-input-csh-always-or-postinit

    cd $workDir

    # ---------------- expand namelists

    set months = $monthslist[$irun]
    set days = $dayslist[$irun]
    set hours = $hourslist[$irun]

    set | sort > $envFile
    sleep $envFileDelay
    set -r | sort >> $envFile
    sleep $envFileDelay
    env --unset=TERMCAP | sort >> $envFile

    expandVariables $envFile < input.nml.unexpanded > input.nml || exit 1

    rm -f $envFile

    # ---------------- prepare MPI call, execute it, analyze results

    if ( $target =~ '*openmp*' ) then
      if ( ! $?OMP_NUM_THREADS ) setenv OMP_NUM_THREADS 1
    else
      unsetenv OMP_NUM_THREADS
    endif 

    runCommand |& tee fms.out

    if ( $status == 0 ) then

      if ( $echoOn ) unset echo
      echo "<NOTE> : Normal exit from the runCommand..."
      if ( $echoOn ) set echo

    else

      set msg =       "*ERROR*: Automatic message from the job '$FRE_JOBID'\n"
      set msg = "${msg}*ERROR*: -----------------------------------------------------------------------\n"
      set msg = "${msg}*ERROR*: The MPI launcher has failed...\n"
      set msg = "${msg}*ERROR*: \n"
      set msg = "${msg}*ERROR*: The job stdout:\n"
      set msg = "${msg}*ERROR*: \n"
      set msg = "${msg}*ERROR*: \t$stdoutDir/$FRE_JOBID\n"
      set msg = "${msg}*ERROR*: \n"

      set coreFiles = ( `ls core*` )

      if ( $#coreFiles > 0 ) then

	if ( ! $?MPI_COREDUMP_DEBUGGER ) setenv MPI_COREDUMP_DEBUGGER 'gdb -batch'
        echo 'where' > .gdbinit

        set coreFileFirst = $coreFiles[1]
        echo "Dump of the core file '$coreFileFirst'" > $coreFileFirst.out
        $MPI_COREDUMP_DEBUGGER $executable:t $coreFileFirst >> $coreFileFirst.out
        cat $coreFileFirst.out >> fms.out
        cat $coreFileFirst.out
        unset coreFileFirst

        set msg = "${msg}*ERROR*: Your job has produced $#coreFiles core files (run $ireload, loop $irun)\n"
        set msg = "${msg}*ERROR*: Please go to the working directory '$workDir' and issue the following command for each core file there:\n"
        set msg = "${msg}*ERROR*: \n"

        @ count = 0
        @ countMax = 20

        foreach coreFile ( $coreFiles )
          set msg = "${msg}*ERROR*: \t$MPI_COREDUMP_DEBUGGER $executable:t $coreFile >> $coreFile.out\n"
          if ( $count < $countMax ) then
            @ count++
          else
            break
          endif
        end

        set msg = "${msg}*ERROR*: \n"
        set msg = "${msg}*ERROR*: FRE has executed the command above for one core file and echoed the result to the job stdout.\n"

        if ( $count == $countMax ) then
          set msg = "${msg}*ERROR*: In order to save space only the first $countMax core files are presented in this list.\n"
          set msg = "${msg}*ERROR*: \n"
        endif

        unset countMax
        unset count

      else

        set cdsize = `limit coredumpsize`
        set msg = "${msg}*ERROR*: No core files produced (run $ireload, loop $irun)\n"
        set msg = "${msg}*ERROR*: You are using the $cdsize\n"
        set msg = "${msg}*ERROR*: \n"
        unset cdsize

      endif

      set msg = "${msg}*ERROR*: -----------------------------------------------------------------------\n"
      set msg = "${msg}*ERROR*: This message has been generated by FRE\n"
      set msg = "${msg}*ERROR*: `date`"

      if ( $?batch ) then
        if ( $echoOn ) unset echo
        printf "$msg" | mailx -s "The MPI launcher has failed" $USER@noaa.gov
        printf "$msg"
        if ( $echoOn ) set echo
      endif

      unset coreFiles
      unset msg

      set outputDir = ${outputDir}_crash

      if ( $?flagOutputXferOn ) then
        set outputDirRemoteAscii = ${outputDirRemoteAscii}_crash
        set outputDirRemoteRestart = ${outputDirRemoteRestart}_crash
        set outputDirRemoteHistory = ${outputDirRemoteHistory}_crash
      endif

      set MPI_FAIL

    endif

    # ---------------- generate date for file names

    set begindate = `timeStamp -b`
    if ( $begindate == 'no_time_stamp' ) set begindate = tmp`date '+%j%H%M%S'`
    set enddate = `timeStamp -e`
    if ( $enddate == 'no_time_stamp' ) set enddate = tmp`date '+%j%H%M%S'`
    set fyear = `echo $enddate | cut -c -4`

    # ---------------- commands, copied from XML (experiment/postProcess/csh)

    #FRE experiment-postprocess-csh

    cd $workDir

    # ---------------- remove time_stamp.out file

    if ( -f time_stamp.out ) rm -f time_stamp.out

    # ---------------- save ascii files

    set asciiFiles = ( `ls -1 | egrep "$patternGrepAscii"` )

    if ( $#asciiFiles > 0 ) then

      set asciiSuffix = ascii/$begindate.ascii_out
      set asciiArchDir = $outputDir/$asciiSuffix
      set asciiWorkDir = $tmpOutputDir$asciiArchDir

      prepareDir $asciiWorkDir 'clean' || exit 1

      foreach file ( $asciiFiles )
	mv -f $file $asciiWorkDir/$begindate.$file
      end

      if ( $?flagOutputXferOn ) then
	if ( $?flagRunTypeRegression || $?flagOutputTypeUnique ) then
          set asciiOutputDirRemote = $outputDirRemoteAscii/$outputDir:t/$asciiSuffix
        else
          set asciiOutputDirRemote = $outputDirRemoteAscii/$asciiSuffix
        endif
      else
        set asciiOutputDirRemote = ""
      endif

      @ ptmpOn = ! $?flagOutputArchiveOn

      set asciiJobName = $FRE_JOBID.output.stager.$begindate.A
      set asciiArgFile = $stateDir/$asciiJobName.args

      set asciiSaveOptions = ( $submitOptionsProject $submitOptionsOutputStagerSave )
      set asciiSaveOptions = ( $asciiSaveOptions -N ${asciiJobName}S )
      set asciiSaveOptions = ( $asciiSaveOptions -l walltime=$outputStagerSaveRuntimeAscii,$outputStagerSaveCoreSpec,mem=1mb )

      set asciiXferOptions = ( $submitOptionsProject $submitOptionsOutputStagerXfer )
      set asciiXferOptions = ( $asciiXferOptions -N ${asciiJobName}T )
      set asciiXferOptions = ( $asciiXferOptions -l walltime=$outputStagerXferRuntimeAscii,$outputStagerXferCoreSpec )

      echo "set expName			=   $name"				 > $asciiArgFile
      echo "set type			=   ascii"				>> $asciiArgFile
      echo "set stagingType		=   $outputStagingType"			>> $asciiArgFile
      echo "set actionSaveOn		=   1"		 			>> $asciiArgFile
      echo "set actionXferOn		=   $?flagOutputXferOn"			>> $asciiArgFile
      echo "set paramArchiveOn		=   $?flagOutputArchiveOn"		>> $asciiArgFile
      echo "set paramPtmpOn		=   $ptmpOn"		 		>> $asciiArgFile
      echo "set paramCheckSumOn		=   $?flagCheckSumOn"			>> $asciiArgFile
      echo "set paramCompressOn		=   $?flagOutputCompressAsciiOn"	>> $asciiArgFile
      echo "set workDir			=   $tmpOutputDir"			>> $asciiArgFile
      echo "set ptmpDir			=   $ptmpDir"				>> $asciiArgFile
      echo "set archDir			=   $asciiArchDir"			>> $asciiArgFile
      echo "set outputDirRemote		=   $asciiOutputDirRemote"		>> $asciiArgFile
      echo "set saveOptions		= ( $asciiSaveOptions )"		>> $asciiArgFile
      echo "set xferOptions		= ( $asciiXferOptions )"		>> $asciiArgFile
      echo "set freModuleFilesDir       =   $freModuleFilesDir"			>> $asciiArgFile
      echo "set freCommandsHomeDir	=   $freCommandsHomeDir"		>> $asciiArgFile
      echo "set xferToolModuleFilesDir	=   $xferToolModuleFilesDir"		>> $asciiArgFile
      echo "set xferToolModuleFile	=   $xferToolModuleFile"		>> $asciiArgFile
      echo "set modulesHomeDir		=   $modulesHomeDir"			>> $asciiArgFile

      if ( $?flagOutputStagingTypeOnline ) then

        if ( $?MPICH_RANK_REORDER_METHOD ) then
          set mpiRankReorderMethod = $MPICH_RANK_REORDER_METHOD
          unsetenv MPICH_RANK_REORDER_METHOD
        endif

        outputStager $asciiArgFile

	if ( $status == 0 ) then
          if ( $echoOn ) unset echo
          echo "<NOTE> : The ascii directory '$asciiArchDir' has been processed successfully"
          if ( $echoOn ) set echo
        else
          if ( $echoOn ) unset echo
          echo "*ERROR*: Can't process the ascii directory '$asciiArchDir'"
          if ( $echoOn ) set echo
          exit 1
	endif

        if ( $?mpiRankReorderMethod ) then
          setenv MPICH_RANK_REORDER_METHOD $mpiRankReorderMethod
          unset $mpiRankReorderMethod
        endif

      else if ( $?flagOutputStagingTypeStaged ) then

        if ( $ptmpOn || $?flagOutputArchiveOn ) then

	  set asciiResult = `submit -O "$asciiSaveOptions -v argFile=$asciiArgFile" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$asciiResult' to process the '$asciiArchDir' (saving) has been submitted successfully"
            if ( $echoOn ) set echo
            set saveJobIds = ( $saveJobIds $asciiResult )
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$asciiArchDir' (saving)"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset asciiResult

        endif

        if ( $?flagOutputXferOn ) then

	  set asciiResult = `submit -O "$asciiXferOptions -v argFile=$asciiArgFile -l depend=afterok:$saveJobIds[$#saveJobIds]" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$asciiResult' to process the '$asciiArchDir' (transfer) has been submitted successfully"
            if ( $echoOn ) set echo
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$asciiArchDir' (transfer)"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset asciiResult

        endif

      else if ( $?flagOutputStagingTypeChained ) then

        if ( $ptmpOn || $?flagOutputArchiveOn || $?flagOutputXferOn ) then

	  set asciiResult = `submit -O "$asciiSaveOptions -v argFile=$asciiArgFile" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$asciiResult' to process the '$asciiArchDir' has been submitted successfully"
            if ( $echoOn ) set echo
            set saveJobIds = ( $saveJobIds $asciiResult )
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$asciiArchDir'"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset asciiResult

        endif

      endif

      unset asciiXferOptions
      unset asciiSaveOptions

      unset asciiArgFile
      unset asciiJobName

      unset ptmpOn

      unset asciiOutputDirRemote
      unset asciiWorkDir
      unset asciiArchDir
      unset asciiSuffix

    endif

    unset asciiFiles

    # ---------------- save restart files, namelist, tables etc. and move them from RESTART to INPUT

    pushd $workDir/RESTART

    set restartFiles = ( `ls -1 | egrep "$patternGrepRestart"` )

    if ( $#restartFiles > 0 ) then

      set restartSuffix = restart/$enddate
      set restartArchDir = $outputDir/$restartSuffix
      set restartWorkDir = $tmpOutputDir$restartArchDir

      prepareDir $restartWorkDir 'clean' || exit 1

      ls -1 | egrep "$patternGrepRestart" | xargs ln --force --target-directory=$restartWorkDir

      cp --force --preserve=mode,ownership,timestamps $workDir/input.nml	$restartWorkDir
      cp --force --preserve=mode,ownership,timestamps $workDir/*_table		$restartWorkDir
      cp --force --preserve=mode,ownership,timestamps $rtsxml			$restartWorkDir
      cp --force --preserve=mode,ownership,timestamps $scriptName		$restartWorkDir

      if ( $irun < $segmentsPerJob ) then

        find $workDir/INPUT   -maxdepth 1 -type f | egrep "$patternGrepRestartNextDrop" | xargs --no-run-if-empty rm --force
        find $workDir/RESTART -maxdepth 1 -type f | egrep "$patternGrepRestartNextMove" | xargs --no-run-if-empty mv --force --target-directory ../INPUT

      else if ( $currentSeg < $segmentsPerSimulation && ( $?flagOutputStagingTypeStaged || $?flagOutputStagingTypeChained ) ) then

        hsmput $restartArchDir:s+/++

	if ( $status == 0 ) then
          if ( $echoOn ) unset echo
          echo "<NOTE> : The restart directory '$restartArchDir' has been saved successfully"
          if ( $echoOn ) set echo
	else
	  if ( $echoOn ) unset echo
	  echo "*ERROR*: Can't save the restart directory '$restartArchDir'"
	  if ( $echoOn ) set echo
	  exit 1
	endif

      endif

      set restartCombineMemory = `memoryLimit $restartWorkDir`

      if ( $?flagOutputXferOn ) then
	if ( $?flagRunTypeRegression || $?flagOutputTypeUnique  ) then
          set restartOutputDirRemote = $outputDirRemoteRestart/$outputDir:t/$restartSuffix
	else
          set restartOutputDirRemote = $outputDirRemoteRestart/$restartSuffix
	endif
      else
        set restartOutputDirRemote = ""
      endif

      if ( $irun == $segmentsPerJob || $currentSeg == $segmentsPerSimulation ) then
        set combineOn	= $?flagRunTypeRegression
        set checkOn	= $?flagOutputCheckOn
        set ptmpOn	= 1
        set archiveOn	= $?flagOutputArchiveOn
        set checkSumOn	= $?flagCheckSumOn
        set compressOn  = $?flagOutputCompressRestartOn
        set xferOn	= $?flagOutputXferOn
      else
        set combineOn	= 0
        set checkOn	= $?flagOutputCheckOn
        set ptmpOn	= 1
        set archiveOn	= $?flagOutputArchiveOn
        set checkSumOn	= $?flagCheckSumOn
        set compressOn  = $?flagOutputCompressRestartOn
        set xferOn	= 0
      endif

      set restartJobName = $FRE_JOBID.output.stager.$enddate.R
      set restartArgFile = $stateDir/$restartJobName.args

      set restartSaveOptions = ( $submitOptionsProject $submitOptionsOutputStagerSave )
      set restartSaveOptions = ( $restartSaveOptions -N ${restartJobName}S )
      set restartSaveOptions = ( $restartSaveOptions -l walltime=$outputStagerSaveRuntimeRestart,$outputStagerSaveCoreSpec,mem=${restartCombineMemory}mb )

      set restartXferOptions = ( $submitOptionsProject $submitOptionsOutputStagerXfer )
      set restartXferOptions = ( $restartXferOptions -N ${restartJobName}T )
      set restartXferOptions = ( $restartXferOptions -l walltime=$outputStagerXferRuntimeRestart,$outputStagerXferCoreSpec )

      echo "set expName			=   $name"			 > $restartArgFile 
      echo "set type			=   restart"			>> $restartArgFile 
      echo "set stagingType		=   $outputStagingType"		>> $restartArgFile
      echo "set actionCombineOn		=   $combineOn"			>> $restartArgFile
      echo "set actionSaveOn		=   1"				>> $restartArgFile 
      echo "set actionCheckOn		=   $checkOn "			>> $restartArgFile
      echo "set actionXferOn		=   $xferOn"			>> $restartArgFile
      echo "set paramArchiveOn		=   $archiveOn"			>> $restartArgFile
      echo "set paramPtmpOn		=   $ptmpOn"			>> $restartArgFile 
      echo "set paramCheckSumOn		=   $checkSumOn"		>> $restartArgFile
      echo "set paramCompressOn		=   $compressOn"		>> $restartArgFile
      echo "set combineMemory		=   $restartCombineMemory"	>> $restartArgFile
      echo "set workDir			=   $tmpOutputDir"		>> $restartArgFile 
      echo "set ptmpDir			=   $ptmpDir"			>> $restartArgFile 
      echo "set archDir			=   $restartArchDir"		>> $restartArgFile 
      echo "set outputDirRemote		=   $restartOutputDirRemote"	>> $restartArgFile
      echo "set saveOptions		= ( $restartSaveOptions )"	>> $restartArgFile
      echo "set xferOptions		= ( $restartXferOptions )"	>> $restartArgFile
      echo "set freModuleFilesDir       =   $freModuleFilesDir"		>> $restartArgFile
      echo "set freCommandsHomeDir	=   $freCommandsHomeDir"	>> $restartArgFile
      echo "set freNCToolsHomeDir	=   $FRE_NCTOOLS_HOME"		>> $restartArgFile
      echo "set freTempDir		=   $freTempDir"		>> $restartArgFile
      echo "set xferToolModuleFilesDir	=   $xferToolModuleFilesDir"	>> $restartArgFile
      echo "set xferToolModuleFile	=   $xferToolModuleFile"	>> $restartArgFile
      echo "set modulesHomeDir		=   $modulesHomeDir"		>> $restartArgFile

      if ( $?flagOutputStagingTypeOnline ) then

        if ( $?MPICH_RANK_REORDER_METHOD ) then
          set mpiRankReorderMethod = $MPICH_RANK_REORDER_METHOD
          unsetenv MPICH_RANK_REORDER_METHOD
        endif

        outputStager $restartArgFile
 
	if ( $status == 0 ) then
          if ( $echoOn ) unset echo
          echo "<NOTE> : The restart directory '$restartArchDir' has been processed successfully"
          if ( $echoOn ) set echo
        else
          if ( $echoOn ) unset echo
          echo "*ERROR*: Can't save the restart directory '$restartArchDir'"
          if ( $echoOn ) set echo
          exit 1
	endif

        if ( $?mpiRankReorderMethod ) then
          setenv MPICH_RANK_REORDER_METHOD $mpiRankReorderMethod
          unset $mpiRankReorderMethod
        endif

      else if ( $?flagOutputStagingTypeStaged ) then

        if ( $combineOn || $checkOn || $ptmpOn || $archiveOn ) then

	  set restartResult = `submit -O "$restartSaveOptions -v argFile=$restartArgFile" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$restartResult' to process the '$restartArchDir' (saving) has been submitted successfully"
            if ( $echoOn ) set echo
            set saveJobIds = ( $saveJobIds $restartResult )
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$restartArchDir' (saving)"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset restartResult

        endif

        if ( $xferOn ) then

	  set restartResult = `submit -O "$restartXferOptions -v argFile=$restartArgFile -l depend=afterok:$saveJobIds[$#saveJobIds]" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$restartResult' to process the '$restartArchDir' (transfer) has been submitted successfully"
            if ( $echoOn ) set echo
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$restartArchDir' (transfer)"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset restartResult

        endif

      else if ( $?flagOutputStagingTypeChained ) then

        if ( $combineOn || $checkOn || $ptmpOn || $archiveOn || $xferOn ) then

	  set restartResult = `submit -O "$restartSaveOptions -v argFile=$restartArgFile" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$restartResult' to process the '$restartArchDir' has been submitted successfully"
            if ( $echoOn ) set echo
            set saveJobIds = ( $saveJobIds $restartResult )
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$restartArchDir'"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset restartResult

        endif

      endif

      unset restartXferOptions
      unset restartSaveOptions

      unset restartArgFile
      unset restartJobName

      unset xferOn
      unset compressOn
      unset checkSumOn
      unset ptmpOn
      unset archiveOn
      unset checkOn
      unset combineOn

      unset restartOutputDirRemote
      unset restartCombineMemory
      unset restartWorkDir
      unset restartSuffix

    endif

    popd

    # ---------------- rename region history files

    set regionHistoryFiles = ( `ls -1 | egrep "$patternGrepRegion"` )

    if ( $#regionHistoryFiles > 0 ) then
      foreach file ( $regionHistoryFiles )
        mv -f $file `echo $file | sed -r "s/$patternGrepRegion//"`
      end
    endif

    unset regionHistoryFiles

    # ---------------- combine, save and post-process history files

    set historyFiles = ( `ls -1 | egrep "$patternGrepHistory"` )

    if ( $#historyFiles > 0 ) then

      set historySuffix = history/$begindate.nc
      set historyArchDir = $outputDir/$historySuffix
      set historyWorkDir = $tmpOutputDir$historyArchDir

      prepareDir $historyWorkDir 'clean' || exit 1
      
      ls -1 | egrep "$patternGrepHistory" | xargs -I'{}' mv --force '{}' $historyWorkDir/$begindate.'{}'

      set historyCombineMemory = `memoryLimit $historyWorkDir`

      if ( $?flagOutputXferOn ) then
	if ( $?flagRunTypeRegression || $?flagOutputTypeUnique  ) then
          set historyOutputDirRemote = $outputDirRemoteHistory/$outputDir:t/$historySuffix
	else
          set historyOutputDirRemote = $outputDirRemoteHistory/$historySuffix
	endif
      else
        set historyOutputDirRemote = ""
      endif

      set combineList = ( $combineList $historyArchDir:t.tar )

      if ( $?flagOutputPostProcessOn && $?flagOutputXferOn && $segmentsPerPPCall > 0 && $#combineList == $segmentsPerPPCall && ! $?MPI_FAIL ) then
        set ppStartOn = 1
	if ( $#combineList > 0 ) then
          set firstDate = `echo $combineList[1] | cut -c -8`
	else
          set firstDate = $begindate
	endif
        set ppStarterOptions = ( $submitOptionsProject $submitOptionsPPStarter )
        set ppStarterOptions = ( $ppStarterOptions -N $FRE_JOBID.pp.starter.$firstDate )
        set ppStarterOptions = ( $ppStarterOptions -l walltime=$ppStarterRuntime,$ppStarterCoreSpec )
        set ppStarterOptions = ( $ppStarterOptions -v expName=$name,xmlFile=$xmlFilesRemote[1],platform=$platformRemote,target=$target,dir=$historyOutputDirRemote:h,firstDate=$firstDate,refineDiagList="'$ppRefineDiagScriptNamesList'",ppEnv="'$envRemote'" )
        set combineList = ( )
        unset firstDate
      else
        set ppStartOn = 0
        set ppStarterOptions = ( )
      endif

      @ ptmpOn = ! $?flagOutputArchiveOn

      set historyJobName = $FRE_JOBID.output.stager.$begindate.H
      set historyArgFile = $stateDir/$historyJobName.args

      set historySaveOptions = ( $submitOptionsProject $submitOptionsOutputStagerSave )
      set historySaveOptions = ( $historySaveOptions -N ${historyJobName}S )
      set historySaveOptions = ( $historySaveOptions -l walltime=$outputStagerSaveRuntimeHistory,$outputStagerSaveCoreSpec,mem=${historyCombineMemory}mb )

      set historyXferOptions = ( $submitOptionsProject $submitOptionsOutputStagerXfer )
      set historyXferOptions = ( $historyXferOptions -N ${historyJobName}T )
      set historyXferOptions = ( $historyXferOptions -l walltime=$outputStagerXferRuntimeHistory,$outputStagerXferCoreSpec )

      echo "set expName			=   $name"				 > $historyArgFile
      echo "set type			=   history"				>> $historyArgFile
      echo "set stagingType		=   $outputStagingType"			>> $historyArgFile
      echo "set actionCombineOn		=   $?flagOutputCombineHistoryOn"	>> $historyArgFile
      echo "set actionCheckOn		=   $?flagOutputCheckOn"		>> $historyArgFile
      echo "set actionSaveOn		=   1"					>> $historyArgFile
      echo "set actionXferOn		=   $?flagOutputXferOn"			>> $historyArgFile
      echo "set actionPPStartOn		=   $ppStartOn"				>> $historyArgFile
      echo "set paramArchiveOn		=   $?flagOutputArchiveOn"		>> $historyArgFile
      echo "set paramPtmpOn		=   $ptmpOn"				>> $historyArgFile
      echo "set paramCheckSumOn		=   $?flagCheckSumOn"			>> $historyArgFile
      echo "set paramCompressOn		=   $?flagOutputCompressHistoryOn"	>> $historyArgFile
      echo "set combineMemory		=   $historyCombineMemory"		>> $historyArgFile
      echo "set workDir			=   $tmpOutputDir"			>> $historyArgFile
      echo "set ptmpDir			=   $ptmpDir"				>> $historyArgFile
      echo "set archDir			=   $historyArchDir"			>> $historyArgFile
      echo "set outputDirRemote		=   $historyOutputDirRemote"		>> $historyArgFile
      echo "set saveOptions		= ( $historySaveOptions )"		>> $historyArgFile
      echo "set xferOptions		= ( $historyXferOptions )"		>> $historyArgFile
      echo "set xmlFiles		= ( $xmlFiles )"			>> $historyArgFile
      echo "set xmlFilesRemote		= ( $xmlFilesRemote )"			>> $historyArgFile
      echo "set ppStarterOptions	= ( $ppStarterOptions )"		>> $historyArgFile
      echo "set stdoutDirRemote		=   $stdoutDirRemote"			>> $historyArgFile
      echo "set freModuleFilesDir       =   $freModuleFilesDir"			>> $historyArgFile
      echo "set freCommandsHomeDir	=   $freCommandsHomeDir"		>> $historyArgFile
      echo "set freNCToolsHomeDir	=   $FRE_NCTOOLS_HOME"			>> $historyArgFile
      echo "set freTempDir		=   $freTempDir"			>> $historyArgFile
      echo "set xferToolModuleFilesDir	=   $xferToolModuleFilesDir"		>> $historyArgFile
      echo "set xferToolModuleFile	=   $xferToolModuleFile"		>> $historyArgFile
      echo "set modulesHomeDir		=   $modulesHomeDir"			>> $historyArgFile

      if ( $?flagOutputStagingTypeOnline ) then

        if ( $?MPICH_RANK_REORDER_METHOD ) then
          set mpiRankReorderMethod = $MPICH_RANK_REORDER_METHOD
          unsetenv MPICH_RANK_REORDER_METHOD
        endif

        outputStager $historyArgFile

	if ( $status == 0 ) then
          if ( $echoOn ) unset echo
          echo "<NOTE> : The history directory '$historyArchDir' has been processed successfully"
          if ( $echoOn ) set echo
        else
          if ( $echoOn ) unset echo
          echo "*ERROR*: Can't process the history directory '$historyArchDir'"
          if ( $echoOn ) set echo
          exit 1
	endif

        if ( $?mpiRankReorderMethod ) then
          setenv MPICH_RANK_REORDER_METHOD $mpiRankReorderMethod
          unset $mpiRankReorderMethod
        endif

      else if ( $?flagOutputStagingTypeStaged ) then

        if ( $?flagOutputCombineHistoryOn || $?flagOutputCheckOn || $ptmpOn || $?flagOutputArchiveOn ) then

	  set historyResult = `submit -O "$historySaveOptions -v argFile=$historyArgFile" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$historyResult' to process the '$historyArchDir' (saving) has been submitted successfully"
            if ( $echoOn ) set echo
            set saveJobIds = ( $saveJobIds $historyResult )
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$historyArchDir' (saving)"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset historyResult

        endif

        if ( $?flagOutputXferOn ) then

	  set historyResult = `submit -O "$historyXferOptions -v argFile=$historyArgFile -l depend=afterok:$saveJobIds[$#saveJobIds]" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$historyResult' to process the '$historyArchDir' (transfer) has been submitted successfully"
            if ( $echoOn ) set echo
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$historyArchDir' (transfer)"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset historyResult

        endif

      else if ( $?flagOutputStagingTypeChained ) then

        if ( $?flagOutputCombineHistoryOn || $?flagOutputCheckOn || $ptmpOn || $?flagOutputArchiveOn || $?flagOutputXferOn ) then

	  set historyResult = `submit -O "$historySaveOptions -v argFile=$historyArgFile" $outputStager`

	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The output stager job '$historyResult' to process the '$historyArchDir' has been submitted successfully"
            if ( $echoOn ) set echo
            set saveJobIds = ( $saveJobIds $historyResult )
          else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the output stager job to process the '$historyArchDir'"
            if ( $echoOn ) set echo
            exit 1
	  endif

          unset historyResult

        endif

      endif

      unset historyXferOptions
      unset historySaveOptions

      unset historyArgFile
      unset historyJobName

      unset ptmpOn
      unset ppStarterOptions
      unset ppStartOn

      unset historyOutputDirRemote
      unset historyCombineMemory
      unset historyWorkDir
      unset historyArchDir
      unset historySuffix

    endif

    unset historyFiles

    # ---------------- terminate script if MPI failed

    if ( $?MPI_FAIL ) then

      if ( $echoOn ) unset echo
      echo "*ERROR*: The MPI failed (run $ireload, loop $irun)"
      echo "*ERROR*: Any output that may have been generated is in the '$outputDir'"
      echo "*ERROR*: The '$workDir' is being kept for possible debugging"
      if ( $echoOn ) set echo

      exit 1

    endif

    # ---------------- terminate script if there are no restart files

    if ( $#restartFiles == 0 ) then

      if ( $echoOn ) unset echo
      echo "*ERROR*: no restart files exist (run $ireload, loop $irun)"
      if ( $echoOn ) set echo

      exit 1

    endif

    # ---------------- write new reload information (production runs only)

    if ( $?flagRunTypeProduction ) then

      if ( $irun < $segmentsPerJob ) then
        @ irunNext = $irun + 1
      else
        @ ireload++
        @ irunNext = 1
      endif

      if ( -f $reload_file ) mv -f $reload_file ${reload_file}_prev
      touch $reload_file

      if ( $status == 0 ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : Writing reload information to the reload file '$reload_file' at `date +%s`"
	if ( $echoOn ) set echo
	echo "@ ireload       =   $ireload"            		>> $reload_file
	echo "@ irun          =   $irunNext"           		>> $reload_file
	echo "set initCond    =   $restartArchDir.$archExt"	>> $reload_file
	echo "set combineList = ( $combineList )"      		>> $reload_file
	echo "set fyear       =   $fyear"              		>> $reload_file
        chmod 644 $reload_file
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The reload file '$reload_file' can't be saved"
        if ( $echoOn ) set echo
        exit 1
      endif

      unset irunNext

    endif

    # ---------------- unset remaining restart variables

    unset restartArchDir
    unset restartFiles

    # ---------------- increment loop counters

    @ currentSeg++
    @ irun++

  end

################################################################################
#--------------------------- after the main loop -------------------------------
################################################################################

  banner ending

  # ---------------- reload and resubmit if needed (production runs only)

  if ( $?flagRunTypeProduction ) then

    if ( $ireload <= $jobsPerSimulation && $currentSeg <= $segmentsPerSimulation ) then

      if ( -f $queue_file ) then
	if ( -r $queue_file ) then
	  source $queue_file
	else
	  if ( $echoOn ) unset echo
	  echo "*ERROR*: The queue file '$queue_file' is not readable"
          if ( $echoOn ) set echo
	  exit 1
	endif
      endif

      if ( ! $continueFlag ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : Stopping execution"
	if ( $echoOn ) set echo
	exit 0
      endif

      if ( $windfallFlag != $windfallFlagInit ) then
	if ( $windfallFlag ) then
	  set submitOptionsWindfall = ( $windfallOptionsSet )
	else
	  set submitOptionsWindfall = ( $windfallOptionsUnset )
	endif
      else
	set submitOptionsWindfall = ( )
      endif

      if ( -f $scriptName ) then
        if ( -r $scriptName ) then
          set nextOptions = ( $submitOptionsProject $submitOptionsQueue $submitOptionsWindfall )
          set result = `submit -O "$nextOptions" $scriptName`
	  if ( $status == 0 ) then
            if ( $echoOn ) unset echo
            echo "<NOTE> : The job '$result' to run the '$scriptName' has been submitted successfully"
            if ( $echoOn ) set echo
	  else
            if ( $echoOn ) unset echo
            echo "*ERROR*: Can't submit the '$scriptName'"
            if ( $echoOn ) set echo
            exit 1
	  endif
          unset result
          unset nextOptions
        else
	  if ( $echoOn ) unset echo
	  echo "WARNING: The script '$scriptName' exists, but is not readable (run $ireload, loop $irun) - it can't be resubmitted"
          if ( $echoOn ) set echo
        endif
      else
	if ( $echoOn ) unset echo
	echo "WARNING: The script '$scriptName' does not exist (run $ireload, loop $irun) - it can't be resubmitted"
        if ( $echoOn ) set echo
      endif

      if ( -f $queue_file ) mv -f $queue_file ${queue_file}_prev
      touch $queue_file

      if ( $status == 0 ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : Writing queue information to the queue file '$queue_file' at `date +%s`"
	if ( $echoOn ) set echo
        echo "set continueFlag = $continueFlag" >> $queue_file
        echo "set windfallFlag = $windfallFlag" >> $queue_file
        if ( ${?project} ) then
          echo "set project      = $project"      >> $queue_file
        endif
        if ( ${?queue} ) then
          echo "set queue        = $queue"        >> $queue_file
        endif
        chmod 644 $queue_file
      else
	if ( $echoOn ) unset echo
	echo "*ERROR*: The queue file '$queue_file' can't be saved"
        if ( $echoOn ) set echo
        exit 1
      endif

    endif

  endif

  # ---------------- working directory cleaning

  if ( $?flagWorkDirCleanOn ) then

    if ( $?flagOutputStagingTypeOnline ) then

      workDirCleaner $workDir

      if ( $status == 0 ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : The working directory has been cleaned successfully"
	if ( $echoOn ) set echo
      else
	if ( $echoOn ) unset echo
	echo "WARNING: Can't clean the working directory"
	if ( $echoOn ) set echo
      endif

    else if ( $?flagOutputStagingTypeStaged || $?flagOutputStagingTypeChained ) then

      set workDirCleanerOptions = ( $submitOptionsProject $submitOptionsWorkDirCleaner )
      set workDirCleanerOptions = ( $workDirCleanerOptions -N $FRE_JOBID.workDir.cleaner )
      set workDirCleanerOptions = ( $workDirCleanerOptions -l walltime=$workDirCleanerRuntime,$workDirCleanerCoreSpec )
      set workDirCleanerOptions = ( $workDirCleanerOptions -v dir=$workDir )

      if ( $#saveJobIds > 0 ) then
	set saveJobList = `echo $saveJobIds | tr ' ' ':'`
	set workDirCleanerOptions = ( $workDirCleanerOptions -l depend=afterok:$saveJobList )
	unset saveJobList
      endif

      set workDirCleanerResult = `submit -O "$workDirCleanerOptions" $workDirCleaner`

      if ( $status == 0 ) then
	if ( $echoOn ) unset echo
	echo "<NOTE> : The working directory cleaning job '$workDirCleanerResult' has been submitted successfully"
	if ( $echoOn ) set echo
      else
	if ( $echoOn ) unset echo
	echo "WARNING: Can't submit the working directory cleaning job"
	if ( $echoOn ) set echo
      endif

      unset workDirCleanerResult
      unset workDirCleanerOptions

    endif

  endif

  # ---------------- normal end of script 

  set -r runtimeEnd = `date "+%s"`
  set -r runtime = `echo "$runtimeEnd - $runtimeBeg" | bc -l`

  if ( $echoOn ) unset echo
  echo "<NOTE> : Finishing on `date`"
  echo "<NOTE> : Runtime = '$runtime' (seconds)"
  echo "<NOTE> : Natural end-of-script for '$scriptName'"
  if ( $echoOn ) set echo

  exit 0
