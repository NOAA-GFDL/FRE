#!/usr/bin/perl
# $Id: hsmget,v 18.0.2.12 2012/09/04 21:00:34 afy Exp $
# script for calling hsmget.mk

require 5;
use strict;

use Carp;                       # error messages in modules
use Cwd;
use Getopt::Long;
use File::Spec;
use File::Basename;
use File::Path qw( mkpath );
use FindBin();

use lib "$FindBin::Bin/../lib";

use HSM();

#option processing
my %opt;
my @optlist = ( 'archroot=s',
                'ptmproot=s',
                'workroot=s',
                'deepget=s',
                'remotepath=s',
                'localcp=s',
                'gcp=s',
                'checksum',
                'sum=s',
                'time',
                'force',
                'extra',
                'nocopy',
                'makefile=s',
                'quiet',
		'verbose',
                'help'
	      );
my $appName = basename($0);	      
my $usage = "Usage: $appName [options] file [file...] 
  Options: 
      -a|--archroot <dir> anchor point on remote storage 
      -p|--ptmproot <dir> anchor point on long-term scratch 
      -w|--workroot <dir> anchor point on local fast scratch 
      -r|--remotepath     remote path for offsite retrieval 
      -c|--checksum       run checksums on transfers
      -s|--sum <file>     external file of prior checksums (if known) 
      -t|--time           turn on timers 
      -f|--force          force transfer even if local file up-to-date
      -e|--extra          extra copy of target file saved in \$workroot 
      -n|--nocopy         dry run, no actual data transfer 
      -m|--makefile       makefile that this invokes 
      -q|--quiet          minimal output. 
      -v|--verbose        verbose output. 
      -h|--help           print help message. 
  Arguments must be files. 
  (No recursive gets because of the danger of huge retrievals) 
  Files are specified by listing the target path relative to workroot. 
  Container directory may be a tar/cpio archive on remote storage.\n";
croak "\n$usage" unless GetOptions( \%opt, @optlist );
# The following options exist but aren't listed on the help line:
#       -d|--deepget        deep storage retrieve command 
#       -l|--localcp        fast network copy command 
#       -g|--gcp            path to gcp (temporary for NCRC only) 

#help: print usage and exit
if( $opt{help} ) {
   print "$appName retrieves files from remote storage.\n\n";
   print "$usage\n";
   exit 0;
}

$SIG{'INT'}  = \&cleanup;          # interruped by ^C
$SIG{'TERM'} = \&cleanup;          # terminated by another process

my $verbose = $opt{verbose};

my $makefile = $opt{makefile} || "$FindBin::Bin/../etc/mk/hsmget.mk";
croak "Non-existent makefile $makefile\n" unless -f $makefile;
print "Using Makefile $makefile ...\n" if $verbose;

# 20090227, commented out next 3 lines, get defaults from hsmget.mk
# 20090508, ok changed my mind, now hsmget gets it from environment
my $archroot = $opt{archroot} || $ENV{ARCHROOT};
my $ptmproot = $opt{ptmproot} || $ENV{PTMPROOT};
my $workroot = $opt{workroot} || $ENV{WORKROOT};
my $workorig = $workroot;
$workroot .= '/.hsm' if $opt{extra};
print "Using archroot=$archroot ptmproot=$ptmproot workroot=$workroot\n" if $verbose;
# my $cmd = 'make';
# $cmd .= " ARCHROOT=$opt{archroot}" if $opt{archroot};
# $cmd .= " PTMPROOT=$opt{ptmproot}" if $opt{ptmproot};
# $cmd .= " WORKROOT=$opt{workroot}" if $opt{workroot};
my $cmd = "make ARCHROOT=$archroot PTMPROOT=$ptmproot WORKROOT=$workroot";
$cmd .= " DEEPGET=\"$opt{deepget}\"" if $opt{deepget};
$cmd .= " LOCALCP=\"$opt{localcp}\"" if $opt{localcp};
$cmd .= " GCP=\"$opt{gcp}\"" if $opt{gcp};
$cmd .= ' verbose=-v' if $verbose;
$cmd .= ' check=ON' if $opt{checksum};
$cmd .= ' time=ON' if $opt{time};
$cmd .= ' force=ON' if $opt{force};
$cmd .= ' -n' if $opt{nocopy};
$cmd .= ' -B' if $opt{force};
$cmd .= ' -s' if $opt{quiet};
$cmd .= " -r -f $makefile";

undef my $target;
undef my $result;
undef my $okfile;
undef my $handle;

foreach ( @ARGV ) {
   croak "$0 target $_ cannot be an absolute pathname!\n\n$usage" 
     if File::Spec->file_name_is_absolute($_);
#next line is incorrect, $_ will be evaluated relative to pwd
#   croak "$0 target $_ cannot be a directory!\n\n$usage" if -d $_;
   my $file = $_;
# vb 20090420: disallow absolute pathnames on targets
#    $file = File::Spec->abs2rel($_,$workroot) if File::Spec->file_name_is_absolute($_);
#skip archive processing if not mounted
   my $dir = dirname("$archroot/$file");
   my $status = qx/readlink -f -n $dir/;
   if ( $archroot && $status ) {
      if ( $opt{remotepath} ) {
         my $rpath = $opt{remotepath};
         $rpath =~ s,^/,,;         # remove leading /
         my $lpath = "$archroot/$rpath";
         print "rpath=$rpath lpath=$lpath\n" if $verbose;
         if ( $opt{force} || ! -f $lpath ) {
            print STDERR "CMD: $cmd -B force=on $lpath\n" if $verbose;
            $result = qx/$cmd -B force=on $lpath/;
            croak "ERROR: Unable to make $lpath\n$result\n" if $?;
            print $result;
            my $foo = $opt{remotepath};
            # print "foo before=$foo\n" if $verbose;
            $foo =~ /.*\/(.*)\./;
            $foo = $1;
            # print "foo after=$foo\n" if $verbose;
            my $bar = "$archroot/$file";
            $bar =~ /(.*)\/$foo/;
            $dir = $1;
            print "bar=$bar dir=$dir\n" if $verbose;
            mkpath $dir; # or croak "Unable to mkdir $dir\n";
            my $do = "ln -f $lpath $dir/" . basename( $opt{remotepath} );
            print "do=$do\n" if $verbose;
            qx/$do/;
            croak "ERROR: Unable to execute $do\n" if $?;
         }
      }
      my $dir = dirname("$ptmproot/$file");
      print STDERR "ptmproot=$ptmproot file=$file\n" if $verbose;
# vb  20090420: direct mkdir on ptmp above instead of going via hsmget.mk
# afy 20120514: the direct mkdir is commented out
#     qx/mkdir -p $dir/ unless -d $dir;
#   $result = qx/mkdir -p $dir/ or croak "ERROR: Unable to mkdir -p $dir\n";
#if source on archroot isn't a file, assume it's an an archive and make
#its ok file
      # default assumes source is an archive
      $target = ( -f "$archroot/$file" ) ? "$ptmproot/$file" : $dir;
      $handle = HSM::lock($target,30) or exit 1;
      HSM::clean($target);
      $okfile = "$target.ok";
      print STDERR "+CMD: $cmd $okfile\n" if $verbose;
      $result = qx/$cmd $okfile/;
      if ( $? ) {
         unlink $okfile if -f $okfile;
         HSM::unlock($handle);
         croak "ERROR: Unable to make $okfile\n$result\n";
      }
      print $result unless $result =~ / is up to date./;
      HSM::alignAccessTime($target);
      HSM::unlock($handle);
   } else {
      carp "WARNING: invalid archive location $dir; \
         hsmget will only do ptmp->work processing\n";
   }
# the glob below allows handling of wildcards in targets
   my @targets = HSM::getCache("$ptmproot/$file");
   print "ptmproot=$ptmproot file=$file targets=@targets\n" if $verbose;
   if ( @targets ) {
      foreach ( @targets ) {
	 $file = "$workroot/" . File::Spec->abs2rel($_,$ptmproot);
	 print STDERR "++CMD: $cmd $file\n" if $verbose;
	 $result = qx/$cmd $file/;
	 if ( $? ) {
            unlink $file if -f $file;
            croak "ERROR: Unable to make $file\n$result\n";
	 }
	 print $result unless $result =~ / is up to date./;
	 my $final = "$workorig/" . basename($_);
	 print qx/ln -f $file $final/ if( $opt{extra} && $file ne $final );
      }
      chdir dirname($file);
      print qx/md5sum -c $okfile/ if $opt{checksum};
      print qx/md5sum -c $opt{sum}/ if $opt{sum};
   } else {
      print STDERR "WARNING: Unable to get targets from the $ptmproot cache\n";
   }
}

sub cleanup ($) {
   my $sig = shift;
   print "Caught a SIG$sig, removing temporary file '$okfile' ...\n";
   unlink $okfile if -f $okfile;
   HSM::unlock($handle);
}
