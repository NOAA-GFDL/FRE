#!/usr/bin/perl
# -*- cperl -*-
# $Id: refrepp,v 18.0.8.9 2011/08/15 17:24:58 arl Exp $
# ------------------------------------------------------------------------------
# refrepp: submit FRE postprocessing jobs to fill in holes
# ------------------------------------------------------------------------------
require 5;
use strict;
use Carp;                       # error messages in modules
use Getopt::Long(':config', 'no_ignore_case');
use XML::LibXML;

use FRE();
use FREExperiment();

#option processing
my @optlist = ( 'xmlfile=s',
                'component=s',
                'dir=s',
                'History=s',
                'begin=s',
                'end=s',
                'frepp=s',
                'platform|Platform|p=s',
                'target|Target|t=s',
                'submit',
                'help',
		'verbose'
	      );
my %opt =
  (
    'platform'  => FREDefaults::Platform(),
    'target'    => FREDefaults::Target(),
    'xmlfile'   => FREDefaults::XMLFile(),
  );
my $usage = "Usage: $0 [options] exp [exp ...] 
  Options: 
      -x|--xmlfile xmlFile (default XML file \$cwd/rts.xml) 
      -c|--component <c>   (process only component <c>, default all) 
      -d|--dir <dir>       (where scripts are stored, default \$rootDir/scripts/postProcess) 
      -H|--History <dir>   (location of history data for frepp to use)
      -b|--begin <year>    (year to begin processing: should line up with chunk boundaries!), 
      -e|--end   <year>    (year to end processing), 
      -f|--frepp <file>    the frepp executable to use 
      -p|--platform <pl>   the platform name.
      -t|--target <tar>    the target name.
      -s|--submit          submit the script as a batch job. 
      -h|--help            print help message. 
      -v|--verbose         verbose messages. 
  At least one experiment from the xmlFile must be listed as an argument.\n";

croak "\n$usage" unless GetOptions( \%opt, @optlist );

#help: print usage and exit
if ( $opt{help}) {
   print "$0 finds and fills frepp holes.\n\n";
   print "$usage\n";
   exit 0;
}


#set default frepp version
exists $ENV{'FRE_COMMANDS_HOME'} or 
  croak "ERROR: FRE_COMMANDS_HOME not set: have you loaded the fre module?\n";

my $frepp = $ENV{FRE_COMMANDS_HOME}. '/bin/frepp';
my $freppcheck = $ENV{FRE_COMMANDS_HOME}. '/bin/freppcheck';
if ( "$opt{frepp}" ne "" ) {
   $frepp = $opt{frepp};
}
croak "ERROR: $frepp not found! check your paths and module loads.\n" 
  unless -f $frepp;
croak "ERROR: $freppcheck not found! check your paths and module loads.\n" 
  unless -f $freppcheck;

my $verbose = $opt{verbose};
my $xmlfile = $opt{xmlfile} || 'rts.xml';
croak "ERROR: XML file not found: $xmlfile\n\n$usage" unless -f $xmlfile;

my $fre = FRE->new('refrepp', %opt) or exit(1);

# get the experiment name: exactly one must be present
my $expt = shift @ARGV or croak "\n$usage";
carp "Only one experiment allowed on command line, rest ignored ...\n" 
  if shift @ARGV;
my $exp = FREExperiment->new($fre, $expt) or exit(1);
$fre->setCurrentExperimentName($expt);

#get the post-processing script directory
my $scriptd = $opt{dir} || $exp->scriptsDir()."/postProcess";
print "scriptd=$scriptd\n" if $verbose;
my $stated = $exp->stateDir()."/postProcess";

#scripts available for refrepping...
opendir DIR, $scriptd or 
 croak "Post-processing script directory $scriptd unavailable!\n";
my @files = readdir DIR;
closedir DIR;

#get components and years
undef my %years;
foreach ( @files ) {
   next if /\.o\d+$/;           # eliminate output files
   print "file=$_ " if $verbose and $ENV{'DEBUG'};
   if( /$expt\_(\w*)_(\d\d\d\d).*/ ) {
      print "comp=$1 year=$2\n" if $verbose and $ENV{'DEBUG'};
      $years{$1} .= $2 . ' ' unless $years{$1} =~ /\b$2\b/; # remove last trailing space later
   }
}

#loop over components
my $numjobs = 0;
print "Components and years available for refrepping:\n";
foreach my $c ( keys %years ) {
   next if( $opt{component} && $opt{component} ne $c ); # if -c run only that component
#sort years numerically, remove trailing slash
   chop $years{$c};
   $years{$c} = join ' ', sort {$a <=> $b} split / /, $years{$c};
#set ybegin/yend:
   $years{$c} =~ /^\s*(\d+)/;
   my $ybegin= $opt{begin} || $1; # command line overrides actual ybegin
   $years{$c} =~ /(\d+)\s*$/;
   my $yend  = $opt{end}   || $1; # command line overrides actual yend
   print "Component=$c years=$years{$c} ybegin=$ybegin yend=$yend\n";
#find the directories to scan for this component
#this includes directories that are _supposed_ to exist based on FRE
# as well as some others that actually exist (e.g av/*_1yr) though not in FRE
#currently uses freppcheck: replace with direct parsing of XML
   undef my $dir;
   undef my $dirs;
   undef my $chunks;
   undef my $yearstodo;
   print "Printing output from freppcheck -x $xmlfile -p $opt{platform} -t $opt{target} -c $c -a -b $ybegin -e $yend $expt ...\n" if $verbose;
   my $freppcheck = qx/freppcheck -x $xmlfile -p $opt{platform} -t $opt{target} -c $c -a -b $ybegin -e $yend $expt/;
   print $freppcheck if $verbose;
   foreach ( split "\n", $freppcheck ) {
      if ( /missing[\w\s]* in (.*)/ ) {
         $dir = $1;
         if ( $dir =~ /\/pp\/$c\// ) {
            $dirs .= $dir . ' '; # remove last trailing space later
#it appears some 1yr directories might exist even if not explicit in <postProcess>
#we get them in the next few lines
            my $d = $dir;
            $d =~ s/_\d+yr/_1yr/;
            $d =~ s/\s+$//;     # the output of freppcheck sometimes has trailing whitespace
            print "d= $d dirs= $dirs\n" if $verbose and $ENV{'DEBUG'};
            if ( -d $d ) {
               $dirs .= $d . ' ' unless $dirs =~ /\b$d\b/;
            }
         }
      }
   }
   chop $dirs;
   print "Directories associated with component $c= $dirs.\n" if $verbose;
   foreach $dir ( sort split / /, $dirs ) {
      if ( $dir =~ /(\d+)yr\s*$/ ) {
         my $chunk = $1;
         undef my @chunkstrings;
         undef my $chunkstring;
         my $y = $ybegin;
         while ( $y <= $yend ) {
            my $chunkend = $y + $chunk - 1;
            if ( $dir =~ /av\/annual_1yr\s*$/ ) {
               $chunkstring = sprintf("%4.4d",$y);
            } elsif ( $chunkend <= $yend ) {
               $chunkstring = sprintf("%4.4d",$y). '-' . sprintf("%4.4d",$chunkend);
               $chunkstring = sprintf("%4.4d",$y) . '01-' . sprintf("%4.4d",$chunkend) . '12' if $dir =~ /\/pp\/$c\/ts\/monthly\b/;
               $chunkstring = sprintf("%4.4d",$y) . '0101-' . sprintf("%4.4d",$chunkend) . '1231' if $dir =~ /\/pp\/$c\/ts\/daily\b/;
               $chunkstring = sprintf("%4.4d",$y) . '010100-' . sprintf("%4.4d",$chunkend) . '123123' if $dir =~ /\/pp\/$c\/ts\/3hr\b/;
               $chunkstring = sprintf("%4.4d",$y) . '-' . sprintf("%4.4d",$chunkend) . '.DJF' if $dir =~ /\/pp\/$c\/ts\/seasonal\b/;
               #ought to test the other three seasons as well: JJA, DJF, MAM, SON
            }
            push @chunkstrings, $chunkstring if $chunkstring;
            $y += $chunk;
         }
         print "dir= $dir chunk=$chunk strings=@chunkstrings\n" if $verbose and $ENV{'DEBUG'};
         undef my %undone;
         if ( opendir DIR, $dir ) {
            my @files = readdir DIR;
            closedir DIR;
            undef my %done;
            foreach ( @files ) {
               next unless /\.nc$/; # only check .nc files
               foreach $chunkstring ( @chunkstrings ) {
                  $done{$chunkstring} = 1 if /$c\.$chunkstring\.[^\.]*\.nc/;
                  print "file=$_ chunkstring=$chunkstring done=$done{$chunkstring}\n" if $verbose and $ENV{'DEBUG'};
               }
            }
            foreach ( @chunkstrings ) {
               $undone{$_} = 1 unless $done{$_};
            }
         } else {
            carp "WARNING: cannot open directory $dir ... treated as undone.\n" if $verbose;
            foreach ( @chunkstrings ) {
               $undone{$_} = 1;
            }
         }
         foreach ( @chunkstrings ) {
            if ($undone{$_}) {
               /^(\d\d\d\d)/;
               my $yeartodo = $1;
               /-(\d\d\d\d)/;
               $yeartodo = $1 if $1;
               $yearstodo .= $yeartodo . ' ' unless $yearstodo =~ /\b$yeartodo\b/; # remove last trailing space later
               print "dir= $dir component=$c chunk=$_ undone, yeartodo=$yeartodo.\n" if $verbose;
            }
         }
         $chunks .= $chunk . ' ' unless $chunks =~ /\b$chunk\b/;
      }
   }
   chop $chunks;
   chop $yearstodo;
   my @chunks = sort {$a <=> $b} split / /, $chunks;
   my @years  = sort {$a <=> $b} split / /, $yearstodo;
   print "component=$c chunks=@chunks yearstodo=@years\n";
   $numjobs += @years;          # count number of elements in @years
   if ( $opt{submit} ) {
      undef my $y;
#assign years to chunks, biggest chunk you can
      undef my %ychunk;
      foreach $y ( @years ) {
         foreach ( @chunks ) {
            if ( ($y-$ybegin+1)%$_ == 0 ) {
               $ychunk{$y} = $_; # this year belongs to this chunk
            }
         }
      }
      undef my $cmd;
      undef my $cmdout;
      undef my $hold;
      undef my $jobid;
      undef my $script;
      undef my %jobs;
      foreach $y ( @years ) {
#create the frepp job
         my $hdir; 
         if ( -d $opt{History} ) {
            $hdir = $opt{History};
         } else {
            $hdir = $exp->archiveDir();
            $hdir =~ s/(.*)\/.*/$1/;
            chomp( $hdir = qx/ls -1dt $hdir\/*\/history | grep -v '_crash' | tail -1/ );
         }
         print "Using history directory $hdir\n" if $verbose;
         if ( -e "$stated/$c.$y" ) {
            print "Removing state file: $stated/$c.$y\n";
            unlink "$stated/$c.$y" or warn "Could not unlink $stated/$c.$y: $!";
         }
         print "Running: '$frepp -t $y -c $c -P $opt{platform} -T $opt{target} -d $hdir -x $xmlfile $expt'\n" if $verbose;
         $cmd = "$frepp -t $y -c $c -P $opt{platform} -T $opt{target} -d $hdir -x $xmlfile $expt 2>&1";
         $cmdout = qx/$cmd/;
#get the jobscript name
         $cmdout =~ /\nTO SUBMIT: msub -d \$HOME (\S+)/m;
         $script = $1;
         if ( $cmdout =~ /ERROR:/ ) {
            print "cmd=$cmd\n$cmdout\n";
            die "ERROR: refrepp caught an error from frepp, exiting.\n";
         } elsif ( ! -f $script ) {
            print "cmd=$cmd\n$cmdout\nscript=$script\n";
            die "ERROR: frepp script not found: '$script' Exiting.\n";
         } else {
            print "cmd=$cmd\n$cmdout\nscript=$script\n" if $verbose;
         }
#work out its dependencies
         undef $hold;
         foreach ( @chunks ) {
            print "chunk=$_ hold=$hold ychunk=$ychunk{$y}\n" if $verbose and $ENV{'DEBUG'};
            last if $_ == $ychunk{$y}; # no dependencies on current chunklength
            $hold .= $jobs{$_};        # next chunk depends on jobs for this chunklength
            undef $jobs{$_};           # these dependencies have been subsumed into next chunklength, so eliminate them
         }
         chop $hold;
#submit the job
         $cmd = 'msub -d $HOME';
         $cmd .= " -l depend=afterok:$hold" if $hold;
         $cmdout = qx/$cmd $script/;
#retrieve the jobid
         $jobid = $cmdout;
         $jobid =~ s/\n//mg;
         $jobs{$ychunk{$y}} .= $jobid . ':';
         print "\ncmd=$cmd $script\n$cmdout\n" if $verbose;
      }
   }
}

print "$0 will submit $numjobs jobs when you $0 --submit (-s) ...\n" unless $opt{submit};
