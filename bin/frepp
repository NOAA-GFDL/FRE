#!/usr/bin/env perl
# -*- cperl -*-
# ------------------------------------------------------------------------------
# FMS/FRE Project: History/diagnostics post-processing
# ------------------------------------------------------------------------------

use strict;
use File::Spec;
use File::Temp;

#use File::stat;
use File::Basename;
use Text::Wrap;
use Getopt::Long( ':config', 'no_ignore_case' );
use Date::Manip;
use XML::LibXML;
use File::Spec;
use Email::Valid;
use Inline 'Python';

use lib ( File::Basename::fileparse( File::Spec->rel2abs($0) ) )[1] . "../lib";
use FRE();
use FREExperiment();
use FREAnalysis qw(analysis);
use FREUtil;
use FRETargets qw(standardize);

use Env::Modulecmd;
Env::Modulecmd::load('slurm');

use vars qw( $expt $nml $err $mailList %dtvars $root);
use vars
    qw( $mkdircommand $hDate $t0 $tEND $sim0 $ppRootDir $component $cpiomonTS $aggregateTS $historyfiles);
use vars qw( $do_static $segTime $segUnits $caltype);
use vars qw( $analysisdir $absfrepp $relfrepp $perlerrors );
use vars
    qw( $archivedir $rootdir $workdir $stdoutdir $tempCache $platform $freVersion $batchSubmit );
use vars
    qw( $maxyrs $maxdisk $cubic $nlat $nlon $interpMethod $xyInterpOptions $getgridspec $basenpes $call_fregrid );
use vars
    qw( $checktransfer $statefile $state $writestate $didsomething $userstartyear $userstartmo $call_tile_fregrid );
use vars qw( $mosaic_type $sourceGrid $xyInterp $xyInterpRegridFile );
our @frepp_plus_calls;

eval "use FREVersion";
if ($@) {
  # Set the version variable to some default string if the module is not available
  $freVersion = 'Development Version'
} else {
  $freVersion = $FREVersion::VERSION;
}

{

    package frepp;

    #Usage:    $relfrepp [ -AB:C:O:RY:Z:c:d:f:hlmMp:oqr:S:st:u:vx:z ] experiment [ experiment2 ... ]
    use constant OPTLIST => (
        'forceCombine|f',
        'time|t=s',
        'component|c=s',
        'limitstatic|l',
        'dir|history|d=s',
        'unique|u=s',
        'resourceManager|m=s',
        'override|o',
        'compress',

        'wait|w=s',
        'plus=i',

        'refineDiag|D:s',
        'refineDiagOnly|H',

        'AnalysisOnly|A',
        'Regenerate|R',
        'OutputFigureDir|O=s',
        'AnalysisStartYear|Y=s',
        'AnalysisEndYear|Z=s',

        'mail-list=s',
        'MailOnComplete|M',
        'Walltime|W=s',
        'debug|Q',
        'quiet|q',
        'verbose|v',
        'VeryVerbose|V',

        'help|h',
        'runparams|r=s',
        'submit|s',
        'xmlfile|x=s',
        'platform|Platform|p|P=s',
        'target|Target|T=s',

        'Calendar|C=s',
        'Basedate|B=s',
        'Segment|S=s',
        'oldStyleTimestamps|e',
        'statistics|z',
        'mppnccombine-opts=s',

        'novalidate',
        'version',

	    'epmt!'
    );

}

{

    my %opt = (
        'xmlfile' => FREDefaults::XMLFile(),
        'target'  => FREDefaults::Target(),
        'epmt'    => 1
    );

    Getopt::Long::GetOptions( \%opt, frepp::OPTLIST ) or ( print 'bad opts' and die "\n" );
    if ( $opt{version} ) { print $freVersion, "\n" and exit(0); }
    use vars
        qw( $opt_d $opt_D $opt_f $opt_l $opt_M $opt_m $opt_q $opt_Q $opt_t $opt_r $opt_x $opt_s $opt_v $opt_V  $opt_A $opt_B $opt_C $opt_O $opt_R $opt_S $opt_Y $opt_Z $opt_c $opt_H $opt_h $opt_o $opt_u $opt_z $opt_w $opt_P $opt_T );
    ( $opt_d = $opt{dir} ) =~ s|\/$||g;
    $opt_f = $opt{forceCombine};
    $opt_l = $opt{limitstatic};
    $opt_o = $opt{override};
    $opt_M = $opt{MailOnComplete};
    $opt_m = $opt{resourceManager};
    $opt_q = $opt{quiet};
    $opt_Q = $opt{debug};
    $opt_t = $opt{time};
    $opt_r = $opt{runparams};
    $opt_x = $opt{xmlfile};
    $opt_s = $opt{submit};
    $opt_v = $opt{verbose};
    $opt_V = $opt{VeryVerbose};
    $opt_A = $opt{AnalysisOnly};
    $opt_B = $opt{Basedate};
    $opt_C = $opt{Calendar};
    $opt_O = $opt{OutputFigureDir};
    $opt_R = $opt{Regenerate};
    $opt_S = $opt{Segment};
    $opt_Y = $opt{AnalysisStartYear};
    $opt_Z = $opt{AnalysisEndYear};
    $opt_c = $opt{component};
    $opt_H = $opt{refineDiagOnly};
    $opt_h = $opt{help};
    $opt_u = $opt{unique};
    $opt_z = $opt{statistics};
    $opt_D = $opt{refineDiag};
    $opt_w = $opt{wait};
    $opt_P = $opt{platform};
    $opt_T = $opt{target};

    ################### PROCESS ARGS, SET DEFAULTS #########################
    if ( -l $0 ) {
        $absfrepp = File::Spec->rel2abs( readlink($0) );
    }
    else {
        $absfrepp = File::Spec->rel2abs($0);
    }
    $relfrepp = basename($absfrepp);

#getopts( 'AB:C:O:RY:Z:c:d:f:hlmMp:oqr:S:st:u:vVx:z' ) || die "\aSyntax: $0 [-AB:C:O:RY:Z:c:d:f:hlmMp:oqr:S:st:u:vVx:z]\n";

    if ( $opt_h or "$#ARGV" eq "-1" ) {
        print <<EOF;

Synopsis: $relfrepp is the FRE postprocessing utility.

Usage:    $relfrepp -P|--platform platform [-AB:C:O:RY:Z:c:d:f:hlmMp:oqr:S:st:u:vx:z] experiment [experiment2 ...]

          OPTIONS FOR COMBINING MULTIPROCESSOR HISTORY FILES
          -f           = force combine of all "raw" history data and then exit

          OPTIONS FOR REFINING HISTORY FILES BEFORE POSTPROCESSING
          -D script    = comma separated list of scripts to run on history data
          -H           = refineDiag only: do not do regular frepp processing

          OPTIONS FOR POSTPROCESSING DATA
          -t time      = beginning of model year to process.  To process 1982, use
                           '-t 1982' or '-t 19820101'.
          --plus num   = "plus num years": additional years to process
          -c component = component to process, or keyword 'split' to process all in parallel
          -l           = limit static variable processing to the diag source file in the xml
          -d dir       = path to history data
          -w jobid     = place hold on current job so that it waits for jobID to complete
          -o           = override job dependencies
          --compress   = compress pp files using NetCDF4 compression, deflation=2 and shuffle

          OPTIONS FOR ANALYSIS FIGURES
          -A           = run analysis only
          -R           = regenerate, submit analysis scripts regardless of whether they already exist
          -O dir       = where to put output figures. This argument is normally
                         used with -A (run analysis only) and must be used if the
                         xml file is not yours.
          -Y year      = specify a four digit year as your analysis's start year, ex -Y 1984
                         This year overrides the startYear specifed in the <analysis> tag.
          -Z year      = specify a four digit year as your analysis's end year, ex -Z 1985
                         This year overrides the endYear specifed in the <analysis> tag.

          OPTIONS FOR TIMING/DEBUGGING/STATISTICS/SCHEDULING
          --mail-list string = send mail to comma-separated list instead of \$USER\@noaa.gov
          -M                 = send mail to user when job is complete
          -m opts            = Additional options to pass to the resource manager (e.g. msub, qsub, sbatch options)
          -W time            = change the max wallclock time for the job, ie, -W 00:20:00
          -u label           = specify unique output dir. frepp -u 2 yields .../pp_2/...
          -Q                 = don't print the error checks into the script.  For evaluating csh.
          -q                 = don't print the analysis figure checks to stdout.
          -v                 = verbose flag
          -V                 = very verbose flag
          --no-epmt          = Turn off EPMT statistics generation

          GENERAL FRE OPTIONS
          -h           = show this help message, then exit
          -r runparams = regression test run.  Combine netcdf files, but no further processing
          -s           = automatically submit the script to the batch scheduler
          -p platform  = platform (required)
          -T target    = target (default on PP/AN: prod)
          -x xmlfile   = specify xml file (default: ./rts.xml)
          experiment   = experiment to create scripts for; must be found in xml file

EOF
        exit 1;
    } ## end if ( $opt_h or "$#ARGV"...)

    # debugging/developer options
    #          --novalidate = skip the XML validation

    #still there but no longer advertised / DEBUGGING
    #          OPTIONS REQUIRED WHEN FULL XML IS NOT AVAILABLE
    #          -C calendar  = specify calendar type from coupler_nml, ie julian
    #          -B basedate  = specify reference date: initial date for simulation, ie "0 0 0 0 0 0"
    #                            from diag table date or coupler_nml current_date
    #          -S segment   = Segment length in months.  Supports 1,2,3,4,6 or 12.
    #setting this option inside script for now
    #          -z           = insert timing calls

    # Check of both -D and -r have been given
    print STDERR "WARNING: Both options -r and -D are given.  The -r option takes precedence.\n"
        if ( $opt_r and $opt_D );

    chomp( my $beginTime = `date +\%s` );

    if ($opt_V) { $opt_v = 1; }

    if ($opt{'mail-list'}) {
        # get rid of the quotes that are needed to pass through pp.starter
        $opt{'mail-list'} =~ s/"//g;
        for (split ',', $opt{'mail-list'}) {
            unless (Email::Valid->address($_)) {
                die "ERROR: The email address '$_' specified in --mail-list isn't valid\n";
            }
        }
        $mailList = $opt{'mail-list'};
        print STDERR "NOTE: The email list '$mailList' will be used for FRE notifications instead of the default '\$USER\@noaa.gov'\n";
    }
    else {
        $mailList = "$ENV{'USER'}\@noaa.gov";
        print STDERR "NOTE: '$mailList' will be used for FRE notifications\n" if $opt_v;
    }

    $opt_x = 'rts.xml' unless $opt_x;    #set default filename for experiments xml file
    if ( !-f $opt_x ) {
        mailuser("XML file does not exist: $opt_x");
        sysmailuser();
        die "ERROR: XML file does not exist: $opt_x\n";
    }

    if ( !$opt_t or ( "$opt_t" eq "" ) ) {
        print STDERR "WARNING: You did not specify a model date\n" unless $opt_A;
    }

    if ( $opt_M and $opt{plus} ) {
        print STDERR "NOTE: You have specified -M (mail on complete) and --plus; to avoid flooding your inbox, the -M option has been turned off.\n";
        $opt_M = "";
    }

    if ($opt_O) {
        print STDERR
            "NOTE: There has been a change to the behavior of the -O option. Your scripts will be written directly to '$opt_O' and not to '$opt_O/scripts/postProcess'\n";
    }

    unless ($opt_c) {
        print STDERR
            "NOTE: adding '-c split'; frepp will do each component in a separate batch job\n";
        $opt_c = 'split';
    }

    $perlerrors    = "";
    $component     = "";
    $maxyrs        = 0;
    $maxdisk       = 0;
    $do_static     = 1;
    $historyfiles  = "";
    %dtvars        = ();
    $basenpes      = 1;
    $aggregateTS   = 1;
    $didsomething  = 0;

    #initialize hsmfiles string
    my $hsmfiles = "";

    #for grepping and sorting associated files
    my $grepAssocFiles = <<'EOF';
grep ':associated_files' | cut -d '"' -f2 | sed "s/\w*://g" | tr ' ' '\n' | sort -u
EOF
    chomp $grepAssocFiles;

    # for netcdf compression querying
    my $grep_netcdf_compression
        = q(grep '_DeflateLevel' | cut -d '=' -f2 | sed s/\\;// | sort -r | head -n 1);
    my $grep_netcdf_shuffle
        = q(grep '_Shuffle' | cut -d '=' -f2 | sed s/\\;// | sed s/\\"//g | sort -r | head -n 1);

    #begin generating version string
    my $abs_xml_path = File::Spec->rel2abs($opt_x);
    my $createdate   = Date::Manip::ParseDate('now');
    my $version_head = "# FMS postprocessing script created at $createdate via:\n# $0 ";
    $version_head .= "-x $abs_xml_path ";


    #variables for timing statistics
    $opt_z = 1;
    if ($opt_Q) { $opt_z = 0; }
    my $time_ncatted     = "";
    my $time_ncks        = "";
    my $time_ncmerge     = "";
    my $time_ncrcat      = "";
    my $time_nccatm      = "";
    my $time_plevel      = "";
    my $time_splitncvars = "";
    my $time_timavg      = "";
    my $time_uncpio      = "";
    my $time_untar       = "";
    my $time_mkcpio      = "";
    my $time_mktar       = "";
    my $time_taxis2mid   = "";
    my $time_mv          = "";
    my $time_rm          = "";
    my $time_dmget       = "";
    my $time_ncap        = "";
    my $time_zgrid       = "";
    my $time_dmput       = "";
    my $time_cp          = "";
    my $time_fregrid     = "";
    my $time_ncrename    = "";
    my $time_hsmget      = "";
    my $time_hsmput      = "";
    my $time_combine     = "";
    my $time_nccopy      = "";

    # When frepp is run with -A option, the -t option is not required.
    # Then set the date to a valid date.  This isn't really ideal, but
    # this is how frepp did it in the past.
    if ( $opt_t =~ /^$/ and $opt_A ) {
        $opt_t = '00010101';
    }

    #clean up opt_t
    #
    # opt_t should be of the form \d{4,}\d{2}\d{2}.  It is possible a user
    # will pass in only a year (\d{4}).  As we move forward to allow for
    # years past 9999, we need to set some guidance on how opt_t is
    # interpreted.  Thus, we somewhat arbitrarily decide that if
    # length($opt_t) < 7, we assume a year has been passed in, 8 and
    # beyond, assume the from above.
    #
    # There should also be a method to correctly know how many digits are
    # in a year, when the year is needed later on in the script.
    #
    # $t0 holds $opt_t in the Date::Manip date format 'yyyymmddhh:mm:ss'
    $t0 = FREUtil::parseDate($opt_t);
    if ( $t0 == undef ) {
        print STDERR
            "ERROR: The date passed in via the '-t' option ('$opt_t') is not a valid date.\n";
        exit 1;
    }

    # Hold required information in the correct format in these three variables
    # should not use $opt_t anywhere as it may not have the correct format.
    ( $userstartyear, $userstartmo ) = $t0 =~ /(\d{4,})(\d{2}\d{2})\d{2}:\d{2}:\d{2}/;
    ($hDate) = $t0 =~ /(\d{4,}\d{4})\d{2}:\d{2}:\d{2}/;

    #assume we are processing 1 year
    $tEND = FREUtil::modifydate( $t0, '+1 year -1 sec' );
    if ($opt_v) {
        print "t0 is $t0 (from -t argument)\n";
        print "tEND is $tEND (from t0 + 1 year)\n";
    }

    #These things vary by platform
    my $cp         = 'cp';
    my $mv         = 'mv';
    my $mvfile     = 'mv';
    my $cpio       = 'cpio';
    my $uncpio     = 'cpio';
    my $timecmd    = '/usr/bin/time';
    my $timereal   = 'e';
    my $systimecmd = 'date +\%s';
    my $maxruntime = '60:00:00';        #needs work
    if ( "$opt{Walltime}" ne '' ) { $maxruntime = "$opt{Walltime}"; }

    #-------------- SET UP PARSER FOR XML DOCUMENT -------------------------
    #set up FRE4
    my $fre = FRE->new( 'frepp', %opt ) or exit(1);

    $root = $fre->{rootNode};
    my $project = $fre->project();

    # use expanded platform (e.g. gfdl.ncrc-intel rather than ncrc-intel)
    $opt_P = $fre->platform;

    # set default platform to "unknown", to catch error with unsupported platforms
    $platform = 'unknown';
    if ( $opt_P =~ /^gfdl\./ ) { $platform = 'x86_64'; }
    chomp $platform;
    my $platformcsh;

    #------------ LOOP OVER EXPTS GIVEN AS SCRIPT ARGUMENTS ----------------
    foreach $expt (@ARGV) {
        print "Setting up experiment '$expt'...\n" if $opt_v;
        unless ( FREUtil::checkExptExists($expt) ) { next; }

        my $exp = FREExperiment->new( $fre, $expt ) or exit(1);
        $fre->setCurrentExperimentName($expt);

        # Get the refineDiag scripts from the XML if -D given
        # on the command line with no string
        if ( defined( $opt{refineDiag} ) and not $opt_D ) {
            $opt_D = join ',', $exp->extractPPRefineDiagScripts;
        }
        $rootdir = $exp->rootDir();
        if ( ( !-d $rootdir ) or ( !-w $rootdir ) and ( !$opt_O ) ) {
            system("mkdir -p $rootdir");
        }
        if ( ( !-d $rootdir ) or ( !-w $rootdir ) and ( !$opt_O ) ) {
            mailuser("Can't write to your root directory $rootdir");
            sysmailuser();
            die "ERROR: Can't write to your root directory $rootdir\n";
        }
        $workdir    = $exp->workDir();
        $archivedir = $exp->archiveDir();
        my $postprocessdir = $exp->postProcessDir();
        my $analysisdir    = $exp->analysisDir();
        my $scriptsdir     = $exp->scriptsDir();
        $stdoutdir         = $exp->stdoutDir();
        my $ptmpDir        = $exp->ptmpDir();
        my $tempCache      = ( split /\//, $workdir )[0] . "/tempCache";
        my $statedir       = $exp->stateDir() . "/postProcess";
        my $outscriptdir   = "$scriptsdir/postProcess";
        if ( "$opt_u" ne '' ) { $outscriptdir .= "/$opt_u"; }
        if ($opt_O) { $outscriptdir = "$opt_O"; }
        unless ( -d "$outscriptdir" or $opt_A ) { system "mkdir -p $outscriptdir"; }

        unless ( -d "$stdoutdir/postProcess" or $opt_A ) {
            system "mkdir -p $stdoutdir/postProcess";
        }
        if ( "$opt_u" ne '' ) { $statedir .= "/$opt_u"; }
        unless ( -d "$statedir" or $opt_A ) { system "mkdir -p $statedir"; }
        my $aoutscriptdir = "$scriptsdir/analysis";
        if ($opt_O) { $aoutscriptdir = "$opt_O"; }
        my $shortxml = $abs_xml_path;
        $shortxml =~ s/.+\/(.+\.xml)(\.$expt\.o.+)?/$1/;

        #if ( -e "$archivedir/$shortxml" ) {
        #   print "Running ln -s $abs_xml_path $archivedir/$shortxml\n" if $opt_v;
        #   system("ln -s $abs_xml_path $archivedir/$shortxml");
        #}
        my $mdbi = $exp->{MDBIswitch};

        my $tmphistdir = "";
        if ( "$workdir" eq "" ) {
            die "ERROR: No workDir from xml\n";
            $tmphistdir = "\$TMPDIR/$expt" . "_$hDate";
            $workdir    = "\$TMPDIR/$expt" . "_$hDate/work";
        }
        else {
            $tmphistdir = "$workdir/$expt" . "_$hDate";
            $workdir    = "$workdir/$expt" . "_$hDate/work";
        }

        if ( !$opt_d ) {    #set appropriate history directory
            if ($opt_r) {
                $opt_d = "$archivedir/$opt_r/history";
            }
            else {
                $opt_d = "$archivedir/history";
            }
        }
        if ( "$opt_d" eq '$archive/$name/history' ) {
            $opt_d = "$archivedir/history";
        }
        my $histDir = $opt_d;
        if ( !-d "$histDir" ) {
            print STDERR "\nNOTE: Creating history dir ($histDir)\n" if $opt_v;
            system "mkdir -p $histDir";
        }
        print
            "\nDIRECTORIES: FRE4\nworkdir $workdir\nrootdir $rootdir\narchivedir $archivedir\nanalysisdir $analysisdir\noutscriptdir $outscriptdir\naoutscriptdir $aoutscriptdir\nhistDir $histDir\nptmpDir $ptmpDir\nstatedir $statedir\n\n"
            if $opt_v;

        # Warn users if MDBIswtich is set and give directions on how to manually fredb experiment
        if ($mdbi) {
            my $fredb = qx{which fredb};
            chomp($fredb);
            my $output;
            my @fredb_cmd = (
                "-x", $abs_xml_path, "-t", $opt_T,   "-p", $opt_P,
                $expt
            );
            print
                "\nWARNING: Frepp no longer automatically injests experiments into Curator. You can do this manually by running:\n$fredb @fredb_cmd\n\n";
        } ## end if ($mdbi)
        my $refinedir = "$opt_d" . "_refineDiag";
        $ptmpDir .= $archivedir;
        if ( "$opt_u" ne '' ) { $ptmpDir .= "/$opt_u"; }

        #set whether to aggregate time series files in archive
        my $agg = FREUtil::getxpathval('postProcess/@archiveTimeSeries');
        if ( "$agg" eq 'byVariable' ) { $aggregateTS = 0; }

        #set platform specific variables
        # This really should be done using the fre.properties file
        print STDERR "Using platform $platform\n" if $opt_v;
        if ( "$platform" eq 'x86_64' ) {
            $batchSubmit = 'sbatch';
            $cp          = 'gcp -v';
            $cpio        = 'cpio -C 524288';
            $uncpio      = 'cpio -C 2097152';
            $mvfile      = 'gcp -v';
            $platformcsh = $exp->fre->default_platform_csh . $exp->fre()->platformValue('csh');
        }
        else {
            mailuser("platform $platform not supported for postprocessing");
            print STDERR
                "ERROR: Platform '$platform' is unsupported.\n";
        }

        if ( "$opt_w" ne '' ) {
            if ($platform eq 'x86_64') {$opt_w = " --dependency=afterok:$opt_w";}
        }

        #variables for timing statistics
        if ($opt_z) {
            $time_ncatted
                = "$timecmd"
                . ' -f "     TIME for ncatted:   real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_ncks
                = "$timecmd"
                . ' -f "     TIME for ncks:      real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_ncmerge
                = "$timecmd"
                . ' -f "     TIME for ncmerge:   real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_ncrcat
                = "$timecmd"
                . ' -f "     TIME for ncrcat:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_nccatm
                = "$timecmd"
                . ' -f "     TIME for nccatm:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_plevel
                = "$timecmd"
                . ' -f "     TIME for plevel:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_splitncvars
                = "$timecmd"
                . ' -f "     TIME for splitvars: real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_timavg
                = "$timecmd"
                . ' -f "     TIME for timavg:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_uncpio
                = "$timecmd"
                . ' -f "     TIME for uncpio:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_untar
                = "$timecmd"
                . ' -f "     TIME for untar:     real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_mkcpio
                = "$timecmd"
                . ' -f "     TIME for mkcpio:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_mktar
                = "$timecmd"
                . ' -f "     TIME for mktar:     real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_taxis2mid
                = "$timecmd"
                . ' -f "     TIME for taxis2mid: real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_mv
                = "$timecmd"
                . ' -f "     TIME for move:      real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_rm
                = "$timecmd"
                . ' -f "     TIME for remove:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_dmget
                = "$timecmd"
                . ' -f "     TIME for dmget:     real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_ncap
                = "$timecmd"
                . ' -f "     TIME for ncap:      real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_zgrid
                = "$timecmd"
                . ' -f "     TIME for zgrid:     real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_dmput
                = "$timecmd"
                . ' -f "     TIME for dmput:     real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_cp
                = "$timecmd"
                . ' -f "     TIME for cp:        real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_fregrid
                = "$timecmd"
                . ' -f "     TIME for fregrid:   real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_ncrename
                = "$timecmd"
                . ' -f "     TIME for ncrename:  real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_hsmget
                = "$timecmd"
                . ' -f "     TIME for hsmget:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_hsmput
                = "$timecmd"
                . ' -f "     TIME for hsmput:    real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_combine
                = "$timecmd"
                . ' -f "     TIME for combine:   real %'
                . "$timereal"
                . ' user %U sys %S"';
            $time_nccopy
                = "$timecmd"
                . ' -f "     TIME for nccopy:    real %'
                . "$timereal"
                . ' user %U sys %S"';
        } ## end if ($opt_z)

        my $version_info = "$version_head";
        if ($opt_f)       { $version_info .= "-f "; }
        if ($opt_P)       { $version_info .= "--platform $opt_P "; }
        if ($opt_T)       { $version_info .= "-T $opt_T "; }
        if ($opt_D)       { $version_info .= "-D '$opt_D' "; }
        if ($opt_t)       { $version_info .= "-t $hDate "; }          # Using corrected $opt_t value
        if ( $opt{plus} ) { $version_info .= "--plus $opt{plus} "; }
        if ($opt_c)       { $version_info .= "-c $opt_c "; }
        if ($opt_d)       { $version_info .= "-d $opt_d "; }
        if ($opt_u)       { $version_info .= "-u $opt_u "; }
        if ($opt_r)       { $version_info .= "-r $opt_r "; }
        if ($opt_H)       { $version_info .= "-H "; }
        if ($opt_m)       { $version_info .= "-m '$opt_m' "; }
        if ($opt{'mail-list'}) { $version_info .= "--mail-list $opt{'mail-list'} "; }
        $version_info .= "$expt";
        my $this_frepp_cmd = $version_info;
        $this_frepp_cmd =~ s/.*# //smg;

        # Get post fix string for job and script name
        my $name_postFix = "";
        if ( $opt_u ne '' ) {
            $name_postFix .= "_$opt_u";
        }

        if ($opt_r) {
            $name_postFix .= "_$opt_r";
            $maxruntime = "01:00:00";
        }
        elsif ($opt_D) {
            $name_postFix .= "_refineDiag";
        }
        $name_postFix .= "_$hDate";

        # Set the job and script name using the postfix.  $outscript is the same
        # as the job name, but with the script directory prepended
        my $batch_job_name = $expt . $name_postFix;
        my $outscript    = File::Spec->catfile($outscriptdir, $batch_job_name);

        my $cshscripttmpl = getTemplate($platform);

        #environment setup for FRE
        my $freCommandsHomeDir = FRE::home();
        my $siteconfig         = <<EOF;
  setenv FRE_COMMANDS_HOME_FREPP $freCommandsHomeDir
EOF
        $cshscripttmpl =~ s/#get_site_config/$siteconfig/;

        #platform_csh and check for FRE version mismatch
        if ( "$platformcsh" ne "" ) {
            my $fremodule = `echo $ENV{LOADEDMODULES} | tr ':' '\n' | egrep '^fre/.+'`;
            chomp $fremodule;
            my $xmlfremodule = $platformcsh;
            my @fremodulecsh = ();

            # Loop through the CSH and remove all comments
            foreach ( split( /\n/, $xmlfremodule ) ) {
                if ( $_ =~ /#/ ) {
                    my $noncomment = ( split( /#/, $_ ) )[0];
                    if ( $noncomment =~ /\S/ ) {
                        push @fremodulecsh, $noncomment;
                    }
                }
                else {
                    push @fremodulecsh, $_;
                }
            }
            $xmlfremodule = join( "\n", @fremodulecsh );
            $xmlfremodule =~ s/.*module load (fre\/\S+)\s*.*/$1/s;
            if ( "$fremodule" ne "$xmlfremodule" ) {
                print STDERR
                    "ERROR: FRE version mismatch. Must use the same version of FRE in the shell and XML.\n";
                print STDERR "       frepp version: $fremodule\n";
                print STDERR "         xml version: $xmlfremodule\n";
                exit 1;
            }
$platformcsh = <<EOF;
#platform_csh
$platformcsh
if ("$xmlfremodule" == "$fremodule" && "$fremodule" == "fre/test") then
    if ( "\$FRE_COMMANDS_HOME" != "\$FRE_COMMANDS_HOME_FREPP" ) then
      echo "WARNING: FRE/test version mismatch:"
      echo "       Frepp version: \$FRE_COMMANDS_HOME_FREPP"
      echo "       XML loads version: \$FRE_COMMANDS_HOME"
    endif
else
    if ( "\$FRE_COMMANDS_HOME" != "\$FRE_COMMANDS_HOME_FREPP" ) then
      echo "ERROR: FRE version mismatch:"
      echo "       Frepp version: \$FRE_COMMANDS_HOME_FREPP"
      echo "       XML loads version: \$FRE_COMMANDS_HOME"
      exit 1
    endif
endif
EOF

        } ## end if ( "$platformcsh" ne...)
        $cshscripttmpl =~ s/#platform_csh/$platformcsh/;
        if ( "$platform" eq 'x86_64' ) {
            $cshscripttmpl =~ s/(#SBATCH --job-name)/$1=$batch_job_name/;
            $cshscripttmpl =~ s/(#SBATCH --time)/$1=$maxruntime/;
            $cshscripttmpl =~ s|(#SBATCH --output)|$1=$stdoutdir/postProcess/%x.o%j|;
            $cshscripttmpl =~ s/(#SBATCH --chdir)/$1=$ENV{HOME}/;
            $cshscripttmpl
                =~ s|(setenv FRE_STDOUT_PATH)|$1 $stdoutdir/postProcess/$batch_job_name.o\$JOB_ID|;
        }
        $cshscripttmpl =~ s/#version_info/# $freVersion\n$version_info/;
        $cshscripttmpl =~ s/set name/set name = $expt/;
        $cshscripttmpl =~ s/set rtsxml/set rtsxml = $abs_xml_path/;
        $cshscripttmpl =~ s/set work/set work = $workdir/;
        $cshscripttmpl =~ s/set tempCache/set tempCache = $tempCache/;
        $cshscripttmpl =~ s/set root/set root = $rootdir/;
        $cshscripttmpl =~ s/set archive/set archive = $archivedir/;
        $cshscripttmpl =~ s/set scriptName/set scriptName = $outscript/;
        $cshscripttmpl =~ s/set oname/set oname = $hDate/;
        $cshscripttmpl =~ s/set histDir/set histDir = $opt_d/;
        $cshscripttmpl =~ s/set ptmpDir/set ptmpDir = $ptmpDir/;
        $cshscripttmpl =~ s/set platform/set platform = $opt_P/;
        $cshscripttmpl =~ s/set target/set target = $opt_T/;
        $cshscripttmpl =~ s/set segment_months/'set segment_months = ' . segmentLengthInMonths()/e;
        $cshscripttmpl =~ s/(#SBATCH --mail-user).*/$1=$mailList/;
        $cshscripttmpl =~ s|(#SBATCH --comment).*|$1=fre/$ENV{'FRE_COMMANDS_VERSION'}|;

        # if using XTMP filesystem for PTMP location, let scheduler know via Slurm --comment directive
        # so it can set $TMPDIR accordingly
        if ($ptmpDir =~ m|/xtmp|) {
            $cshscripttmpl =~ s|(#SBATCH --comment)=?(.*)|$1=$2,xtmp|;
        }

        if ($opt_r) {    #if a regression test, no further postprocessing
            $cshscripttmpl =~ s/(#INFO:max_years=)/$1$maxyrs/;
            writescript( $cshscripttmpl, $outscript, "$batchSubmit$opt_w $opt_m", $statefile );
            $opt_w = '';
            next;
        }
        my $ppNode = FREUtil::getppNode($expt);
        unless ($opt_f) {
            unless ($ppNode) {    #if no pp node, no further postprocessing
                if ( "$platform" eq 'x86_64' ) {
                    $cshscripttmpl =~ s/(#SBATCH --time).*/$1=01:00:00/;
                }
                $cshscripttmpl =~ s/(#INFO:max_years=)/$1$maxyrs/;
                writescript( $cshscripttmpl, $outscript, "$batchSubmit$opt_w $opt_m", $statefile );
                $opt_w = '';
                next;
            }
        }
        if ( "$opt_M" ne "" ) {
            $cshscripttmpl =~ s/(#SBATCH --mail-type=)NONE/$1END/;
        }

        #calendar
        if ($opt_C) {
            $caltype = $opt_C;
        }
        else {
            if ($opt_v) { print "Getting namelists...\n"; }
            $nml = $exp->extractNamelists();
            if ($nml) {
                $caltype = $nml->namelistSingleQuotedStringGet( "coupler_nml", "calendar" );
                unless ($caltype) {
                    $caltype = 'julian';
                    print STDERR "\nWARNING: Using default calendar type 'julian' as couldn't find 'coupler_nml'/'calendar' namelist value.\n\n";
                }
            }
            else {
                $caltype = 'julian';
                print STDERR "\nWARNING: Couldn't populate namelists; most likely your external namelists weren't transferred, or are improperly referenced in your XML!\n";
                print STDERR "WARNING: Using default calendar type 'julian' as couldn't find 'coupler_nml'/'calendar' namelist value.\n\n";
            }
            print STDERR "caltype = $caltype\n" if $opt_v;
        }

        #diag table date -> sim0 (simulation begin date)
        my $basedate = "";
        my @diagtablecontent = split( '\n', $exp->extractTable('diagTable') );
        if ($opt_B) {
            $basedate = $opt_B;
        }
        else {
            #look in coupler_nml if basedate set to $baseDate
            chomp( $basedate = $diagtablecontent[1] );
            $basedate =~ s/^\s*//g;
            if ( "$basedate" eq "\$baseDate" ) {
                $basedate = $nml->namelistGet("coupler_nml");
                if ( "$basedate" eq "" ) {
                    $basedate = "0 0 0 0 0 0";
                }
                else {
                    $basedate
                        =~ s/.*current_date\s*=\s*(\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+)\s*(.*)/$1/s;
                    chomp $basedate;
                    $basedate =~ s/^\s*//g;
                }
            }
        } ## end else [ if ($opt_B) ]
        print "basedate = $basedate\n" if $opt_v;

        my $gridspec = $exp->extractVariableFile('gridSpec');
        if ( "$gridspec" eq '' ) {
            die "ERROR: gridSpec for platform $opt_P was not found in $opt_x.\n";
        }
        elsif ( !-e $gridspec ) {
            die "ERROR: gridSpec file does not exist: $gridspec\n";
        }
        else {
            print STDERR "NOTE: Using gridSpec $gridspec\n" if $opt_v;
        }

        #if refineDiag run, insert refineDiag csh here
        if ($opt_D) {
            $cshscripttmpl
                .= refineDiag( $tmphistdir, $stdoutdir, $ptmpDir, $basedate, $refinedir, $gridspec,
                $mdbi );
        }

        if ( $opt_f or ($opt_D) ) {

            #separate mppnccombine from rest of script due to splitting components
            unless ($opt_H) {
                $cshscripttmpl .= "\n/usr/bin/env perl $absfrepp -x $abs_xml_path -t $hDate -s -v ";
                if ($opt_P) { $cshscripttmpl .= "-P $opt_P "; }
                if ($opt_T) { $cshscripttmpl .= "-T $opt_T "; }
                if ($opt_d) { $cshscripttmpl .= "-d $opt_d "; }
                if ($opt_u) { $cshscripttmpl .= "-u $opt_u "; }
                if ($opt_c) { $cshscripttmpl .= "-c $opt_c "; }
                if ($opt_m) { $cshscripttmpl .= "-m '$opt_m' "; }
                if ($opt_M) { $cshscripttmpl .= "-M "; }
                if ($opt_o) { $cshscripttmpl .= "-o "; }

                $cshscripttmpl .= "$expt\n";
                $cshscripttmpl
                    .= errorstr( "$relfrepp had a problem creating next script $expt" . "_$hDate" );
            } ## end unless ($opt_H)

            if ($opt_f) {
                my @hf   = ();
                my @hsmf = ();
                opendir( DIR, $opt_d ) or die $!;
                @hf = grep { /\.raw\.nc\.tar$/ && -f "$opt_d/$_" } readdir(DIR);
                closedir(DIR);
                my $hsmget_history = hsmget_history_csh(
                    $ptmpDir, $tmphistdir, $refinedir, $this_frepp_cmd,
                    join( ' ', @hf ),
                    join( ' ', @hsmf )
                );
                $cshscripttmpl =~ s/#hsmget_history_files/$hsmget_history/;
                my $uncompress = uncompress_history_csh($tmphistdir);
                $cshscripttmpl =~ s/#uncompress_history_files/$uncompress/;
                my @sorted = sort { $a cmp $b } @hf;
                my $check_history
                    = checkHistComplete( $tmphistdir, $sorted[0], $this_frepp_cmd, \@hsmf,
                    \@diagtablecontent );
                $cshscripttmpl =~ s/#check_history_files/$check_history/;
            } ## end if ($opt_f)

            if ( $opt_D and $opt{plus} ) {
                $cshscripttmpl .= call_frepp( $abs_xml_path, $outscript, $opt_c, "" );
                $cshscripttmpl
                    .= errorstr( "$relfrepp had a problem creating next script $expt" . "_$hDate" );
            }

            $cshscripttmpl .= mailerrors($outscript);
            if ( "$platform" eq 'x86_64' ) {
                $cshscripttmpl =~ s/(#SBATCH --time).*/$1=$maxruntime/;
            }
            $cshscripttmpl =~ s/(#INFO:max_years=)/$1$maxyrs/;
            writescript( $cshscripttmpl, $outscript, "$batchSubmit$opt_w $opt_m", $statefile );
            $opt_w = '';
            next;
        } ## end if ( $opt_f or ($opt_D...))
        else {
            $cshscripttmpl =~ s/set histDir = .*/set histDir = $tmphistdir/;
        }

        $writestate = '';
        unless ($opt_A) {
            my $writeIDorINTER = <<'EOF';
echo $JOB_ID > $statefile
EOF
            $cshscripttmpl =~ s/#write_to_statefile/$writeIDorINTER/;

            $writestate = <<EOF;
  if ( "\$prevjobstate" == "ERROR" ) then
     echo FATAL > \$statefile
  else
     echo ERROR > \$statefile
  endif
EOF
        } ## end unless ($opt_A)

        $checktransfer = <<EOF;
if ( \$status ) then
         echo ERROR: data transfer attempt failed twice, exiting.
         Mail -s "\$name year \$historyyear cannot be postprocessed" $mailList <<END
Your FRE post-processing job ( \$JOB_ID ) has exited because of a data transfer failure.

This job can be resubmitted via:

$this_frepp_cmd

Job details:
\$name running on \$HOST
Batch job stdout:
\$FRE_STDOUT_PATH
END

$writestate

         sleep 30
         exit 7
endif
EOF

        #assemble a command to create archive directories
        if ($opt_v) { print "Creating archive directories...\n"; }
        $ppRootDir = $postprocessdir;
        if ( "$opt_u" ne '' ) { $ppRootDir .= "_$opt_u"; }
        if ( $opt_A and !-d "$ppRootDir" ) {
            print "ERROR: directory $ppRootDir not found. Exiting.\n";
            exit 1;
        }
        $mkdircommand = "";
        $mkdircommand .= "mkdir -p $ppRootDir/.dec $ppRootDir/.checkpoint " unless $opt_A;
        my $nocommentver = $version_info;
        $nocommentver =~ s/#//g;
        $cshscripttmpl .= <<EOF;
   touch $statedir/frepp.log
   echo '#$freVersion' >> $statedir/frepp.log
   cat >> $statedir/frepp.log <<END
$nocommentver

END
EOF
        $cshscripttmpl .= <<EOF;
#hsmget_history_files

#uncompress_history_files

#check_history_files
EOF

        #if ( \$?checkpt ) then
        #   #goto \$checkpt
        #else
        #   if ( -e $ppRootDir/.checkpoint/\$checkptfile ) then
        #      set checkpt = `cat $ppRootDir/.checkpoint/\$checkptfile`
        #      if ( "\$checkpt" != "" ) then
        #         #goto \$checkpt
        #      endif
        #   endif
        #endif
        #EOF

        $getgridspec = "cd \$work; dmget $gridspec\n";
        if ( $gridspec =~ /cpio$/ ) {
            $getgridspec .= <<EOF;
if ( ! -e mosaic.nc && ! -e grid_spec.nc && ! -e atmos_mosaic.nc ) then
   $time_uncpio cpio -iv < $gridspec
endif

EOF
        }
        elsif ( $gridspec =~ /tar$/ ) {
            $getgridspec .= <<EOF;
if ( ! -e mosaic.nc && ! -e grid_spec.nc && ! -e atmos_mosaic.nc ) then
   $time_untar tar -xvf $gridspec
endif
EOF
        }
        else {
            $getgridspec .= <<EOF;
if ( ! -e mosaic.nc && ! -e grid_spec.nc && ! -e atmos_mosaic.nc ) then
   $time_cp $cp $gridspec .
endif
EOF
        }

        $call_tile_fregrid = $getgridspec . <<'EOF';
if ( -e mosaic.nc ) then
   set input_mosaic = `ncks -H -v $mosaic_type mosaic.nc | sed 's/.*="//;s/"//'`
else if ( -e grid_spec.nc ) then
   set input_mosaic = `ncks -H -v $mosaic_type grid_spec.nc | sed 's/.*="//;s/"//'`
else
   echo ERROR: Cannot locate atm_mosaic_file
   exit 1
endif

ls -l $input_mosaic

# Check for a suitable regrid file in FMS-land
set mosaic_gridfile = `ncks -H -v gridfiles $input_mosaic | head -n 1 | sed 's/.*="//;s/"//'`
@ remap_source_x = `ncdump -h $mosaic_gridfile | grep "nx =" | sed 's/.*=//;s/;//;s/ //g'` / 2
@ remap_source_y = `ncdump -h $mosaic_gridfile | grep "ny =" | sed 's/.*=//;s/;//;s/ //g'` / 2
set fms_remap_file = $fregrid_remap_file:t
set fms_remap_file = `echo $fms_remap_file | sed 's/^\.//'`
EOF

        my $fms_remap_dir = $fre->property('FRE.directory.fms_shared_fregrid_remap_files');
        $call_tile_fregrid .= <<EOF;
set fms_remap_file = "$fms_remap_dir/\$source_grid/\${remap_source_x}_by_\$remap_source_y/\$fms_remap_file"
EOF

        $call_tile_fregrid .= <<'EOF';
if (-e $fms_remap_file) then
    echo "NOTE: Using shared FMS remap file $fms_remap_file"
    set fregrid_remap_file = $fms_remap_file
    set remap_dir = $fms_remap_file:h
    set remap_file = $fms_remap_file:t
else
    set remap_dir = $fregrid_remap_file:h
    set remap_file = $fregrid_remap_file:t
endif
EOF
        $call_tile_fregrid .= <<EOF;
if ( -e \$fregrid_remap_file ) then
   $time_cp $cp \$fregrid_remap_file \$remap_file
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_cp $cp \$fregrid_remap_file \$remap_file
      $checktransfer
   endif
endif
EOF
        $call_tile_fregrid .= <<'EOF';
if ( $?variables && "$variables" != '' ) then
   # auxillary static variables such as a,b,*_bnds must be passed through fregrid for CMIP use
   set static_vars = ( `$NCVARS -s0123 $fregrid_in.tile1.nc` )
   set static_vars = `echo $static_vars |sed 's/ /,/g'`
   set interpvars = `echo "$variables,$static_vars" | sed 's/,$//'`
   unset variables static_vars
else
   set interpvars = ( `$NCVARS $ncvars_arg $fregrid_in.tile1.nc` )
   set interpvars = `echo $interpvars |sed 's/ /,/g'`
endif
set order1 = ( precip prec_ls snow_ls prec_conv snow_conv uw_precip prec_uwc snow_uwc prc_deep_donner snow_deep_donner prc1_deep_donner prc_mca_donner snow_mca_donner ice_mask land_mask zsurf cld_amt_2d conv_freq IWP_all_clouds WP_all_clouds WVP tot_cloud_area tot_ice_amt tot_liq_amt swdn_sfc_clr swdn_sfc swdn_toa_clr swdn_toa swdn_tot_dif swup_sfc_clr swup_sfc swup_toa_clr swup_toa wind_ref wind_ref_max wind_ref_min area )
set non_regrid_vars = ( lat lon )
EOF
        my $non_regrid_vars = $fre->property('FRE.frepp.fregrid.non_regrid_vars');
        $call_tile_fregrid .= <<EOF;
set non_regrid_vars = ( \$non_regrid_vars $non_regrid_vars )
set attCmds = ()
unset echo
if ( -e $ppRootDir/.non_default_interp_method ) then
  source $ppRootDir/.non_default_interp_method
endif
EOF
        $call_tile_fregrid .= <<'EOF';
foreach order1var ( $order1 )
  foreach modelvar ( `echo $interpvars | sed -e "s/,/ /g"` )
    if ( $modelvar == $order1var ) then
      if ( `ncexists -f $fregrid_in.tile1.nc -v $order1var` ) then
        if ( ! `ncexists -f $fregrid_in.tile1.nc -v $order1var -a interp_method` ) then
          set attCmds = ( $attCmds -a interp_method,$order1var,a,c,"conserve_order1" )
        endif
      endif
    endif
  end
end
foreach non_regrid_var ( $non_regrid_vars )
  foreach modelvar ( `echo $interpvars | sed -e "s/,/ /g"` )
    if ( $modelvar == $non_regrid_var ) then
      if ( `ncexists -f $fregrid_in.tile1.nc -v $non_regrid_var` ) then
        if ( ! `ncexists -f $fregrid_in.tile1.nc -v $non_regrid_var -a interp_method` ) then
          set attCmds = ( $attCmds -a interp_method,$non_regrid_var,a,c,"none" )
        endif
      endif
    endif
  end
end
set echo
EOF

        $call_fregrid = $call_tile_fregrid;
        $call_fregrid =~ s/tile1.//g;

        $call_fregrid .= <<EOF;
if (\$#attCmds > 0) then
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.nc \$fregrid_in.nc.tmp
   #check_ncatted
   mv -f \$fregrid_in.nc.tmp \$fregrid_in.nc
endif

if ( "\$fregrid_wt" != '' ) then
   set fregrid_yr = `echo \$fregrid_in_date | sed 's/[0-9][0-9][0-9][0-9]\$//'`
   foreach fregridwtfile ( `ls $opt_d/\${fregrid_yr}????.nc.*` )
      set fregridwtfile = \$fregridwtfile:t:r
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$fregridwtfile/\\*land_static\\*
      if ( \$status ) then
         echo "WARNING: hsmget reported failure, retrying..."
         $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$fregridwtfile/\\*land_static\\*
         $checktransfer
      endif
   end
   ln -s \$histDir/\${fregrid_yr}????.nc/*land_static* .
      foreach fregrid_mo ( 02 03 04 05 06 07 08 09 10 11 12 )
        if ( ! -e \${fregrid_yr}\${fregrid_mo}01.land_static.nc ) then
           ln -s \${fregrid_yr}0101.land_static.nc \${fregrid_yr}\${fregrid_mo}01.land_static.nc
        endif
      end
endif

# Get the associated_files
foreach assocFileBase ( `ncdump -h \$fregrid_in.nc | $grepAssocFiles` )
   set assocFileYear = `echo \$assocFileBase | cut -c 1-4`
   foreach aff ( `ls -1 \$histDir/\$assocFileYear*/*\${assocFileBase}*` )
      if ( ! -e `basename \$aff` ) ln -s \$aff .
   end
end
EOF
        $call_tile_fregrid .= <<EOF;
if (\$#attCmds > 0) then
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile1.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile2.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile3.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile4.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile5.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile6.nc
   #check_ncatted
endif

if ( "\$fregrid_wt" != '' ) then
   set fregrid_yr = `echo \$fregrid_in_date | sed 's/[0-9][0-9][0-9][0-9]\$//'`
   foreach fregridwtfile ( `ls $opt_d/\${fregrid_yr}????.nc.*` )
      set fregridwtfile = \$fregridwtfile:t:r
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$fregridwtfile/\\*land_static\\*
      if ( \$status ) then
         echo "WARNING: hsmget reported failure, retrying..."
         $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$fregridwtfile/\\*land_static\\*
         $checktransfer
      endif
   end
   ln -s \$histDir/\${fregrid_yr}????.nc/*land_static* .
   foreach i ( 1 2 3 4 5 6 )
      foreach fregrid_mo ( 02 03 04 05 06 07 08 09 10 11 12 )
        if ( ! -e \${fregrid_yr}\${fregrid_mo}01.land_static.tile\$i.nc ) then
           ln -s \${fregrid_yr}0101.land_static.tile\$i.nc \${fregrid_yr}\${fregrid_mo}01.land_static.tile\$i.nc
        endif
      end
   end
endif

# Correct associated_file year (for static files) and get files
foreach f ( \$fregrid_in*.nc )
   set fregrid_yr = `echo \$fregrid_in_date | cut -c 1-4`
   set oldassoc = `ncdump -h \$f | grep ':associated_files' | cut -d'"' -f2`
   if ("\$oldassoc" != '' ) then
      set newassoc = `ncdump -h \$f | grep ':associated_files' | cut -d'"' -f2 | sed "s/: [0-9]\\{4\\}/: \$fregrid_yr/g"`
      if ("\$oldassoc" != "\$newassoc") then
         # If file is a link, then copy and make sure it is writable
         if ( -l \$f ) then
            $time_cp cp \$f copy
            $time_rm rm -f \$f
            $time_mv $mv copy \$f
            chmod 644 \$f
         endif
         $time_ncatted ncatted -h -O -a associated_files,global,m,c,"\$newassoc" \$f
#check_ncatted
      endif

      # For now, remove the '.tile[1-6]' from all associated files.  fregrid will add it back in
      #TODO - When fregrid is updated, remove this
      set newassoc = `ncdump -h \$f | grep ':associated_files' | cut -d'"' -f2 | sed "s/\.tile[0-6]//g"`
      if ( -l \$f ) then
         $time_cp cp \$f copy
         $time_rm rm -f \$f
         $time_mv $mv copy \$f
         chmod 644 \$f
      endif
      $time_ncatted ncatted -h -O -a associated_files,global,m,c,"\$newassoc" \$f
#check_ncatted

      # Get the associated_files
      foreach af ( `echo \$newassoc | sed "s/\\w*://g"` )
         foreach aff ( \$histDir/\$fregrid_yr*/*\${af:r}* )
            if ( ! -e `basename \$aff` ) ln -s \$aff .
            end
         end
      endif
   end
EOF
        if ( $basenpes == 1 ) {
            my $exec_fregrid .= <<EOF;
$time_fregrid \$FREGRID --standard_dimension --input_mosaic \$input_mosaic --input_file \$fregrid_in --interp_method \$interp_method --remap_file \$remap_file --nlon \$nlon --nlat \$nlat --scalar_field \$interpvars \$fregrid_wt --output_file out.nc \$interp_options
EOF
            $call_tile_fregrid .= $exec_fregrid;
            $call_fregrid      .= $exec_fregrid;
        }
        else {
            my $exec_fregrid .= <<EOF;
$time_fregrid mpirun -np $basenpes fregrid_parallel --standard_dimension --input_mosaic \$input_mosaic --input_file \$fregrid_in --interp_method \$interp_method --remap_file \$remap_file --nlon \$nlon --nlat \$nlat --scalar_field \$interpvars \$fregrid_wt --output_file out.nc \$interp_options
EOF
            $call_tile_fregrid .= $exec_fregrid;
            $call_fregrid      .= $exec_fregrid;
        }

        my $rename_regridded = <<EOF;
#check_fregrid

if ( ! -e \$fregrid_remap_file && -e out.nc ) then
   ls -l \$remap_file*
   $time_hsmput hsmput -v -t -p \$remap_dir -w . \$remap_file
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_hsmput hsmput -v -t -p \$remap_dir -w . \$remap_file
      $checktransfer
   endif
endif

if ( -e out.nc ) then
    mv out.nc \$fregrid_in.nc
else
    rm \$fregrid_in.nc
endif

EOF
        $call_tile_fregrid .= $rename_regridded;
        $call_fregrid      .= $rename_regridded;

        $call_tile_fregrid .= <<EOF;
$time_rm rm \$fregrid_in.tile?.nc
$time_rm rm *.grid_spec.tile*.nc
EOF

        if ($opt_A) { print STDERR "\n ANALYSIS ONLY mode, pp/ files will not be generated\n"; }

        my $cshscript        = $cshscripttmpl;
        my @ppComponentNodes = $ppNode->findnodes("component");
        if ( $opt_c and "$opt_c" ne "split" ) {
            @ppComponentNodes = $ppNode->findnodes("component[\@type='$opt_c']");
        }

        if ( "@ppComponentNodes" eq '' ) {
            if ( $opt_c and "$opt_c" ne "split" ) {
                print STDERR "ERROR: No such component: $opt_c\n";
            }
            else {
                print STDERR "ERROR: No available components\n";
            }
        }

        #process each component
        foreach my $ppcNode (@ppComponentNodes) {
            $cpiomonTS = "";
            $component = $ppcNode->findvalue('@type');
            print STDERR "\nCreating script for postprocessing component '$component'\n" if $opt_v;
            my $this_component_cmd = $this_frepp_cmd;
            $this_component_cmd =~ s/ -c split / -c $component /;
            $checktransfer = <<EOF;
if ( \$status ) then
         echo ERROR: data transfer attempt failed twice, exiting.
         Mail -s "\$name year \$historyyear component $component cannot be postprocessed" $mailList <<END
Your FRE post-processing job ( \$JOB_ID ) has exited because of a data transfer failure.

This job can be resubmitted via:

$this_component_cmd

Job details:
  \$name running on \$HOST
Batch job stdout:
  \$FRE_STDOUT_PATH
END

         $writestate
         sleep 30
         exit 7
endif
EOF

            if ($opt_c) {    #append component name to job and file name
                $cshscript = $cshscripttmpl;
                my $origoutscript     = $outscript;
                $outscript    = "$outscriptdir/$expt" . "_$component" . "_$hDate";
                $batch_job_name = $expt;
                if ( "$opt_u" ne '' ) {
                    $batch_job_name .= "_$opt_u";
                }
                $batch_job_name .= "_$component" . "_$hDate";
                $cshscript =~ s/set scriptName = .*/set scriptName = $outscript/;
                $cshscript
                    =~ s|(setenv FRE_STDOUT_PATH).*|$1 $stdoutdir/postProcess/$batch_job_name.o\$JOB_ID|;
                $cshscript =~ s/(#SBATCH --job-name).*/$1=$batch_job_name/;
                $cshscript =~ s/(-w $expt)/$1_$component/;
                $cshscript =~ s/(#INFO:component=)/$1$component/;

                # special case: ocean_(annual|month) jobs can run into memory issues, so require bigmem node
                if ( $component =~ /ocean_(annual|monthly)/ ) {
                    print STDERR "NOTE: Requesting large-memory node for component='$component' due to the possibly large ocean files.\n" if $opt_v;
                    $cshscript =~ s/(#SBATCH --job-name.*)/$1\n#SBATCH --constraint=bigmem/;
                }
                $statefile = "$statedir/$component." . $userstartyear;

                #check status of this frepp year
                unless ($opt_A) {
                    if ( -e $statefile ) {
                        open( STATEFILE, "<$statefile" ) or die $!;
                        $state = FREUtil::cleanstr(<STATEFILE>);
                        close STATEFILE;
                        print
                            "This year ($hDate) has a state file with state '$state' for $component.\n";
                        if ( "$state" eq "OK" ) {
                            if ($opt_o) {
                                print
                                    "Redoing anyway because 'overwrite state files' was specified...\n";
                            }
                            else {
                                print
                                    "This year ($hDate) has already been completed for $component.\n";

                      # if --plus option is used, store next year's frepp command to call at the end
                                push @frepp_plus_calls, form_frepp_call_for_plus_option($component)
                                    if $opt{plus};
                                next;
                            }
                        }
                        elsif ( "$state" eq "FATAL" ) {
                            print
                                "This year ($hDate) got an error in multiple attempts, skipping this component.  To retry $component processing, delete the state file $statefile\n";

                            #what if this is the -c split job? continue to other components
                            next;
                        }
                        elsif ( "$state" eq "INTERACTIVE" ) {
                            print
                                "This year ($hDate) was partially run interactively but not completed, resubmitting $component...\n";
                        }
                        elsif ( "$state" eq "ERROR" ) {
                            print
                                "This year ($hDate) got an error in the last frepp attempt, resubmitting $component...\n";
                        }
                        elsif ( "$state" eq "HISTORYDATAERROR" ) {
                            print
                                "This year ($hDate) got an error in the last frepp attempt due to missing history data, resubmitting $component...\n";
                        }
                        elsif ( "$state" eq '' ) {
                            print "ERROR: statefile $statefile exists but is empty, exiting.\n";

                            #what if this is the -c split job? continue to other components
                            next;
                        }
                        else {
                            #check that jobid is still running
                            my $jobrunning = isjobrunning($state);
                            print "Checking state in $statefile: $state: jobrunning: $jobrunning\n";
                            if ($jobrunning) {
                                print
                                    "Previous frepp job ($state) for $hDate still running for $component, exiting.\n";
                                next;
                            }
                            else {
                                print
                                    "Previous frepp job for $hDate was lost, resubmitting $component...\n";
                            }
                        }
                    } ## end if ( -e $statefile )
                    $cshscript =~ s/set prevjobstate.*/set prevjobstate = '$state'/;
                    $cshscript =~ s/set statefile.*/set statefile = '$statefile'/;
                } ## end unless ($opt_A)

            } ## end if ($opt_c)

            #initialize per component
            $cubic        = 0;
            $sourceGrid   = '';
            $xyInterp     = '';
            $interpMethod = '';
            $xyInterpOptions = '';

            #xyInterp
            my $sourceGridAtt = $ppcNode->findvalue('@sourceGrid');

            #backwards reproducibility
            my $c2l = $ppcNode->findvalue('@cubicToLatLon');

            if ( "$c2l" eq 'none' ) {    #leave data on cubed sphere grid
                $sourceGrid  = 'cubedsphere';
                $xyInterp    = '';
                $mosaic_type = "atm_mosaic_file";
            }
            elsif ( "$c2l" ne '' ) {     #convert to lat lon grid
                $sourceGrid  = 'cubedsphere';
                $xyInterp    = $c2l;
                $mosaic_type = "atm_mosaic_file";
            }
            else {                       #latlon grid
                if ( "$sourceGridAtt" eq '' ) {
                    $sourceGrid  = 'latlon';
                    $xyInterp    = '';
                    $mosaic_type = "atm_mosaic_file";
                }
            }

            #check if need to convert cube sphere grid to lat lon
            my @gridstrings = split( /-/, $sourceGridAtt );
            if ( "$gridstrings[0]" eq "atmos" ) {
                $mosaic_type = "atm_mosaic_file";
            }
            elsif ( "$gridstrings[0]" eq "ocean" ) {
                $mosaic_type = "ocn_mosaic_file";
            }
            elsif ( "$gridstrings[0]" eq "land" ) {
                $mosaic_type = "lnd_mosaic_file";
            }
            elsif ( "$gridstrings[0]" eq "none" ) {
                $mosaic_type = "none";
            }
            else {
                die
                    "sourceGrid mosaic type '$gridstrings[0]' not supported. sourceGrid string must be 'none' or of the form: {atmos,ocean,land}-{latlon,cubedsphere,tripolar}\n"
                    if "$mosaic_type" eq '';
            }
            $cshscript
                .= "set mosaic_type = $mosaic_type\n";  #this will be wrong for ocean, but not used.
            if ( "$sourceGridAtt" eq 'none' ) {
                $sourceGrid = 'none' if "$sourceGrid" eq '';
            }
            else {
                $sourceGrid = $gridstrings[1] if "$sourceGrid" eq '';
            }
            $xyInterp = $ppcNode->findvalue('@xyInterp') if "$xyInterp" eq '';
            if ( "$sourceGrid" eq '' ) {
                die
                    "ERROR: Must specify postprocessing component 'sourceGrid' attribute of the form: '{atmos,ocean,land}-{latlon,cubedsphere,tripolar}' or 'none'\n";
            }
            elsif ( "$sourceGrid" !~ /(cubedsphere|latlon|tripolar|none)/ ) {
                die
                    "ERROR: sourceGrid must be 'none' or '{atmos,ocean,land}-{cubedsphere,latlon,tripolar}'\n";
            }
            $nlat = 0;
            $nlon = 0;
            if ( "$xyInterp" eq '' ) {
                print STDERR "Data will be left on $sourceGrid grid\n" if $opt_v;
                $cshscript .= "#Grid type: $sourceGrid\n";
            }
            elsif ( "$xyInterp" =~ /\d+,\d+/ ) {
                ( $nlat, $nlon ) = split( ',', $xyInterp );
                print STDERR "$sourceGrid data will be converted to (nlat,nlon)=($nlat,$nlon)\n"
                    if $opt_v;
                $cshscript
                    .= "#Grid type: $sourceGrid will be converted to latlon (nlat,nlon)=($nlat,$nlon)\n";

                # Check for a xyInterpRegridFile defined in the XML
                my @xyInterpRegridFiles = $fre->dataFiles( $ppcNode, 'xyInterpRegridFile' );

                # dataFiles returns a file/target type array, we only care about the file
                if ( scalar(@xyInterpRegridFiles) > 0 ) {
                    $xyInterpRegridFile = $xyInterpRegridFiles[0];
                    if ( !-e $xyInterpRegridFile && !-w dirname($xyInterpRegridFile) ) {
                        die
                            "ERROR: xyInterpRegridFile '$xyInterpRegridFile' is specified for '$component', but doesn't exist and user will be unable to write to it's final location";
                    }
                }
                else {
                    $xyInterpRegridFile
                        = "$ppRootDir/$component/.fregrid_remap_file_\${nlon}_by_\${nlat}.nc";
                }
            } ## end elsif ( "$xyInterp" =~ /\d+,\d+/)
            else {
                die "ERROR: xyInterp must specify a 'lat,lon' for regridding\n";
            }
            $interpMethod = 'conserve_order1';
            $interpMethod = 'conserve_order2' if "$sourceGrid" eq "cubedsphere";

            #check if non-default interpMethod specified
            my $componentIM = $ppcNode->findvalue('@interpMethod');
            if ( "$componentIM" ne "" ) { $interpMethod = $componentIM; }

            # make sure cmip and zInterp options aren't used together
            if (    $ppcNode->findvalue('@cmip') =~ /(?:yes|on|true)/i
                and $ppcNode->findvalue('@zInterp') ) {
                die
                    "ERROR: Component $component requested incompatible cmip and zInterp options.\n";
            }

            # if custom xyInterpOptions are requested, pass them to fregrid
            $xyInterpOptions = $ppcNode->findvalue('@xyInterpOptions');
            print STDERR "\nNOTE: Custom xyInterp options: '$xyInterpOptions'\n\n" if $xyInterpOptions;

            #get list of all diagnostic output files from source attributes, remove duplicates
            my @sourceatts = $ppcNode->findnodes('*/@source');
            push @sourceatts, $ppcNode->findnodes('@source');
            my @dts = map { $_->findvalue('.') } @sourceatts;
            push @dts, "$component" . "_month";
            my @dtsources = ();
            my %seen      = ();
            foreach (@dts) {
                push( @dtsources, $_ )
                    unless ( $_ =~ /monthly/ or $_ =~ /annual/ or $_ =~ /seasonal/ or $seen{$_}++ );
            }
            push( @dtsources, 'land_static' ) unless $seen{$_}++;
            if ($opt_v) { print STDERR "diag_table source files are '@dtsources'\n"; }

            #get list of variables for each file from diag table information.
            foreach my $srcfile (@dtsources) {
                my @dtv    = ();
                my @dtvall = ();

                foreach (@diagtablecontent) {
                    if ( /.*,.*,\s*"(\w*)"\s*,\s*"$srcfile"\s*,.*,.*,.*,.*/ and not /^#/ ) {
                        push @dtvall, $1;
                    }

                    #omit static/instantaneous variables
                    if ( /.*,.*,\s*"(\w*)"\s*,\s*"$srcfile"\s*,.*,\s*\.true\.\s*,.*,.*/
                        and not /^#/ ) {
                        push @dtv, $1;
                    }
                }
                my $varstr    = join( ',', @dtv );
                my $varstrall = join( ',', @dtvall );
                my $srcfileall = "all_$srcfile";
                if ( "$varstrall" ne "" ) {
                    $dtvars{$srcfile}    = $varstr;
                    $dtvars{$srcfileall} = $varstrall;
                    if ($opt_V) {
                        print "$srcfile vars, static/instant omitted: $dtvars{$srcfile}\n\n";
                    }
                    if ($opt_v) {
                        print "All $srcfile diag_table variables: $dtvars{$srcfileall}\n\n";
                    }
                }
            } ## end foreach my $srcfile (@dtsources)

            my $startdate = $ppcNode->findvalue('@start');
            if ( "$startdate" eq "" ) { $startdate = $ppNode->findvalue('@start'); }
            $sim0 = "";
            my $run0 = &FREUtil::parseFortranDate($basedate);
            if ( "$startdate" ne "" ) {
                $startdate = FREUtil::padzeros($startdate);
                $sim0      = FREUtil::parseDate($startdate);
                if ( $sim0 == undef ) {
                    print STDERR
                        "ERROR: The start date specified in the XML postProcess/component tag is not a valid date.\n";
                    exit 1;
                }
                if ( "$sim0" ne "" and FREUtil::dateCmp( $run0, $sim0 ) == 1 ) {
                    mailuser(
                        "the $component postprocessing start attribute ($sim0) must be equal to or later than the start of the run ($run0). The default value of the start attribute is the start of the run.  Setting the start attribute to a later date provides the ability to skip years of data at the beginning of a run.  Please check the start attribute of all postprocessing components."
                    );
                    print STDERR
                        "WARNING: the $component postprocessing start attribute ($sim0) must be equal to or later than the start of the run ($run0).  The default value of the start attribute is the start of the run.  Setting the start attribute to a later date provides the ability to skip years of data at the beginning of a run.  Please check the start attribute of all postprocessing components.";
                }
                else {
                    print "NOTE: sim0 from start attribute: $sim0\n" if $opt_v;
                }
            }
            else {
                $sim0 = &FREUtil::parseFortranDate($basedate);
                print "NOTE: sim0 from basedate: $sim0\n" if $opt_v;
            }
            if ( "$sim0" eq "" ) {
                mailuser("$relfrepp had a problem calculating sim0.  Please contact Amy.");
                sysmailuser();
                die "ERROR: $relfrepp had a problem calculating sim0.  Please contact Amy.\n";
            }
            my $startflag = FREUtil::dateCmp( $t0, $sim0 );
            my $startofrun = 0;
            if ( $startflag eq 0 ) {
                print "NOTE: This is the first postprocessing of the simulation for $component\n"
                    if $opt_v;
                $startofrun = 1;
            }
            elsif ( $startflag eq -1 and !$opt_A ) {
                print "NOTE: t0 < sim0, skipping $t0-$tEND for $component\n" if $opt_v;
                next;
            }
            elsif ( $startflag eq 1 ) {
                print "NOTE: t0 > sim0 for $component\n" if $opt_v;
            }
            else {
                print "WARNING: having trouble comparing t0 to sim0 ($t0,$sim0) for $component\n"
                    if $opt_v;
            }
            print "      sim0 is $sim0 (from basedate or start attribute)\n" if $opt_v;

            #get simulation end date from production xml -> simEND
            my $simTime  = FREUtil::getxpathval('runtime/production/@simTime');  #not currently used
            my $simUnits = FREUtil::getxpathval('runtime/production/@units');    #not currently used
            ( $segTime, $segUnits ) = getSegmentLength();                        # global

            my $simEND = FREUtil::modifydate( $run0, "+ $simTime $simUnits - 1 sec" );

            if ( $simEND < $tEND and !$opt_A ) {
                if ( $simEND < $t0 ) {
                    print
                        "WARNING: The simulation time calculated from the basedate in your diag_table ($basedate) and the simulation length from the xml ($simTime $simUnits) ends before this year of postprocessing ($hDate).\n";
                    $simEND = $tEND;    #simEND not currently used for anything else
                }
                else {
                    $tEND = $simEND;
                    print "      adjusting tEND to simulation end: $tEND\n";
                }
            }

            #print "      simEND is $simEND (from basedate + xml simTime)\n";

            my $scriptcopy = $cshscript;
            my @depyears   = ();
            ( my $standardTarget, my $targeterr ) = FRETargets::standardize($opt_T);

            #STATIC
            my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
            my $diag_source = "";
            if ( scalar @monthnodes ) {
                my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
                $diag_source = $monthnode->getAttribute('@source');
            }
            if ( "$diag_source" eq "" ) { $diag_source = $ppcNode->findvalue('@source'); }
            if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }
            if ( !$opt_l ) { $diag_source =~ s/_.*//; }
            my $staticfile = "$ppRootDir/$component/$component.static.nc";
            print STDERR "      static vars from '$diag_source'\n" if $opt_v;
            if ( !$opt_A ) {
                $cshscript .= staticvars( $diag_source, $ptmpDir, $tmphistdir, $refinedir );
            }

            #TIMEAVERAGES - MONTHLY
            my @taNodes = sort by_interval $ppcNode->findnodes('timeAverage[@source="monthly"]');
            my @intervals = map { $_->findvalue('@interval') } @taNodes;
            my $diag_source = " ";
            foreach my $taNode (@taNodes) {
                $hsmfiles = $hsmfiles . jpkSrcFiles($taNode) . ",";
                ( my $int, my $subint, my @dep ) = get_subint( $taNode, @intervals );
                push( @depyears, @dep );
                if ($opt_v) {
                    print STDERR "      monthly av int=$int subint=$subint";
                    if   ( "$subint" eq "" ) { print STDERR "history\n"; }
                    else                     { print STDERR "\n"; }
                }

                if ( !$opt_A ) {
                    if ($subint) {
                        $cshscript .= monthlyAVfromav( $taNode, $sim0, $subint );
                    }
                    else {
                        #does monthly 1year and monthly xyear, order is unimportant
                        $cshscript .= monthlyAVfromhist( $taNode, $sim0 );
                    }
                }
                $cshscript .= analysis(
                    {   node        => $taNode,
                        experiment  => $expt,
                        gridSpec    => $gridspec,
                        staticFile  => $staticfile,
                        type        => "timeAverage",
                        diagSrc     => $diag_source,
                        ppRootDir   => $ppRootDir,
                        comp        => $component,
                        dtvarsRef   => " ",
                        analysisDir => $analysisdir,
                        scriptDir   => $aoutscriptdir,
                        workDir     => $workdir,
                        archDir     => $archivedir,
                        opt_t       => $hDate,
                        opt_O       => $opt_O,
                        opt_Y       => $opt_Y,
                        opt_Z       => $opt_Z,
                        opt_V       => $opt_V,
                        opt_u       => $opt_u,
                        sim0        => $sim0,
                        opt_R       => $opt_R,
                        histDir     => $histDir,
                        nLat        => $nlat,
                        nLon        => $nlon,
                        absXmlPath  => $abs_xml_path,
                        stdoutDir   => $stdoutdir,
                        opt_P       => $opt_P,
                        stdTarget   => $standardTarget,
                        opt_s       => $opt_s
                    }
                );
            } ## end foreach my $taNode (@taNodes)

            #TIMEAVERAGES - ANNUAL
            my @taNodes = sort by_interval $ppcNode->findnodes(
                'timeAverage[@source="annual" and @interval!="1yr"]');
            my @intervals = map { $_->findvalue('@interval') } @taNodes;
            my @annavnodes
                = $ppcNode->findnodes('timeAverage[@source="annual" and @interval="1yr"]');
            my $annCalcInterval = '';
            if ( scalar @annavnodes ) {
                my $taNode
                    = $ppcNode->findnodes('timeAverage[@source="annual" and @interval="1yr"]')
                    ->get_node(1);
                $annCalcInterval = $taNode->findvalue('@calcInterval');
                if ( not scalar @taNodes or "$annCalcInterval" eq "1yr" ) {
                    push( @intervals, $annCalcInterval );
                    $hsmfiles = $hsmfiles . jpkSrcFiles($taNode) . ",";
                    if ( !$opt_A ) {
                        print STDERR "      annual av int=1yr subint=history\n" if $opt_v;
                        $cshscript .= annualAV1yrfromhist( $taNode, $sim0, 1 );
                    }
                    $cshscript .= analysis(
                        {   node        => $taNode,
                            experiment  => $expt,
                            gridSpec    => $gridspec,
                            staticFile  => $staticfile,
                            type        => "timeAverage",
                            diagSrc     => $diag_source,
                            ppRootDir   => $ppRootDir,
                            comp        => $component,
                            dtvarsRef   => \%dtvars,
                            analysisDir => $analysisdir,
                            scriptDir   => $aoutscriptdir,
                            workDir     => $workdir,
                            archDir     => $archivedir,
                            opt_t       => $hDate,
                            opt_O       => $opt_O,
                            opt_Y       => $opt_Y,
                            opt_Z       => $opt_Z,
                            opt_V       => $opt_V,
                            opt_u       => $opt_u,
                            sim0        => $sim0,
                            opt_R       => $opt_R,
                            histDir     => $histDir,
                            nLat        => $nlat,
                            nLon        => $nlon,
                            absXmlPath  => $abs_xml_path,
                            stdoutDir   => $stdoutdir,
                            opt_P       => $opt_P,
                            stdTarget   => $standardTarget,
                            opt_s       => $opt_s
                        }
                    );
                } ## end if ( not scalar @taNodes...)
            } ## end if ( scalar @annavnodes)
            foreach my $taNode (@taNodes) {
                $hsmfiles = $hsmfiles . jpkSrcFiles($taNode) . ",";
                ( my $int, my $subint, my @dep ) = get_subint( $taNode, @intervals );
                push( @depyears, @dep );
                if ($opt_v) {
                    print STDERR "      annual av int=$int subint=$subint";
                    if   ( "$subint" eq "" ) { print STDERR "1\n"; }
                    else                     { print STDERR "\n"; }
                }
                if ( !$opt_A ) {
                    if ( $subint > 1 ) {
                        $cshscript .= annualAVfromav( $taNode, $sim0, $subint );
                    }
                    else {
                        $cshscript
                            .= annualAVxyrfromann( $taNode, $sim0, $ppcNode, scalar @annavnodes,
                            $annCalcInterval );
                    }
                }
                $cshscript .= analysis(
                    {   node        => $taNode,
                        experiment  => $expt,
                        gridSpec    => $gridspec,
                        staticFile  => $staticfile,
                        type        => "timeAverage",
                        diagSrc     => $diag_source,
                        ppRootDir   => $ppRootDir,
                        comp        => $component,
                        dtvarsRef   => \%dtvars,
                        analysisDir => $analysisdir,
                        scriptDir   => $aoutscriptdir,
                        workDir     => $workdir,
                        archDir     => $archivedir,
                        opt_t       => $hDate,
                        opt_O       => $opt_O,
                        opt_Y       => $opt_Y,
                        opt_Z       => $opt_Z,
                        opt_V       => $opt_V,
                        opt_u       => $opt_u,
                        sim0        => $sim0,
                        opt_R       => $opt_R,
                        histDir     => $histDir,
                        nLat        => $nlat,
                        nLon        => $nlon,
                        absXmlPath  => $abs_xml_path,
                        stdoutDir   => $stdoutdir,
                        opt_P       => $opt_P,
                        stdTarget   => $standardTarget,
                        opt_s       => $opt_s
                    }
                );
            } ## end foreach my $taNode (@taNodes)

            #TIMEAVERAGES - SEASONAL
            my @taNodes = sort by_interval $ppcNode->findnodes('timeAverage[@source="seasonal"]');
            my @intervals = map { $_->findvalue('@interval') } @taNodes;
            foreach my $taNode (@taNodes) {
                $hsmfiles = $hsmfiles . jpkSrcFiles($taNode) . ",";
                ( my $int, my $subint, my @dep ) = get_subint( $taNode, @intervals );
                push( @depyears, @dep );

                if ( !$opt_A ) {
                    if ($subint) {
                        print STDERR "      seasonal av int=$int subint=$subint\n" if $opt_v;
                        $cshscript .= seasonalAVfromav( $taNode, $sim0, $subint );
                    }
                    else {
                        print STDERR "      seasonal av int=$int subint=history\n" if $opt_v;
                        $cshscript .= seasonalAVfromhist( $taNode, $sim0 );
                    }
                }
                $cshscript .= analysis(
                    {   node        => $taNode,
                        experiment  => $expt,
                        gridSpec    => $gridspec,
                        staticFile  => $staticfile,
                        type        => "timeAverage",
                        diagSrc     => $diag_source,
                        ppRootDir   => $ppRootDir,
                        comp        => $component,
                        dtvarsRef   => \%dtvars,
                        analysisDir => $analysisdir,
                        scriptDir   => $aoutscriptdir,
                        workDir     => $workdir,
                        archDir     => $archivedir,
                        opt_t       => $hDate,
                        opt_O       => $opt_O,
                        opt_Y       => $opt_Y,
                        opt_Z       => $opt_Z,
                        opt_V       => $opt_V,
                        opt_u       => $opt_u,
                        sim0        => $sim0,
                        opt_R       => $opt_R,
                        histDir     => $histDir,
                        nLat        => $nlat,
                        nLon        => $nlon,
                        absXmlPath  => $abs_xml_path,
                        stdoutDir   => $stdoutdir,
                        opt_P       => $opt_P,
                        stdTarget   => $standardTarget,
                        opt_s       => $opt_s
                    }
                );
            } ## end foreach my $taNode (@taNodes)

            #TIMESERIES - HOURLY
            my @hrfreqs = ( '30min', 'hourly', '2hr', '3hr', '4hr', '6hr', '8hr', '12hr', '120hr' );
            foreach my $hrfreq (@hrfreqs) {
                my @tsNodes     = sort by_chunk $ppcNode->findnodes("timeSeries[\@freq='$hrfreq']");
                my @chunks      = map { $_->findvalue('@chunkLength') } @tsNodes;
                my $diag_source = diagfile( $ppcNode, "$hrfreq" );
                foreach my $tsNode (@tsNodes) {
                    $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
                    ( my $cl, my $subchunk, my @dep ) = get_subint( $tsNode, @chunks );
                    push( @depyears, @dep );
                    if ($opt_v) {
                        print STDERR "      $hrfreq ts chunklength=$cl subchunk=$subchunk";
                        if   ( "$subchunk" eq "" ) { print STDERR "history\n"; }
                        else                       { print STDERR "\n"; }
                    }

                    if ( !$opt_A ) {
                        if ($subchunk) {
                            $cshscript .= TSfromts( $tsNode, $sim0, $subchunk );
                        }
                        else {
                            $cshscript .= directTS( $tsNode, $sim0, $startofrun );
                        }
                    }
                    $cshscript .= analysis(
                        {   node        => $tsNode,
                            experiment  => $expt,
                            gridSpec    => $gridspec,
                            staticFile  => $staticfile,
                            type        => "timeSeries",
                            diagSrc     => $diag_source,
                            ppRootDir   => $ppRootDir,
                            comp        => $component,
                            dtvarsRef   => \%dtvars,
                            analysisDir => $analysisdir,
                            scriptDir   => $aoutscriptdir,
                            workDir     => $workdir,
                            archDir     => $archivedir,
                            opt_t       => $hDate,
                            opt_O       => $opt_O,
                            opt_Y       => $opt_Y,
                            opt_Z       => $opt_Z,
                            opt_V       => $opt_V,
                            opt_u       => $opt_u,
                            sim0        => $sim0,
                            opt_R       => $opt_R,
                            histDir     => $histDir,
                            nLat        => $nlat,
                            nLon        => $nlon,
                            absXmlPath  => $abs_xml_path,
                            stdoutDir   => $stdoutdir,
                            opt_P       => $opt_P,
                            stdTarget   => $standardTarget,
                            opt_s       => $opt_s
                        }
                    );
                } ## end foreach my $tsNode (@tsNodes)
            } ## end foreach my $hrfreq (@hrfreqs)

            #TIMESERIES - DAILY
            my @tsNodes
                = sort by_chunk $ppcNode->findnodes('timeSeries[@freq="daily" or @freq="day"]');
            my @chunks = map { $_->findvalue('@chunkLength') } @tsNodes;
            my $diag_source = diagfile( $ppcNode, "daily" );
            foreach my $tsNode (@tsNodes) {
                $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
                ( my $cl, my $subchunk, my @dep ) = get_subint( $tsNode, @chunks );
                push( @depyears, @dep );
                if ($opt_v) {
                    print STDERR "      daily ts chunklength=$cl subchunk=$subchunk";
                    if   ( "$subchunk" eq "" ) { print STDERR "history\n"; }
                    else                       { print STDERR "\n"; }
                }

                if ( !$opt_A ) {
                    if ($subchunk) {
                        $cshscript .= TSfromts( $tsNode, $sim0, $subchunk );
                    }
                    else {
                        $cshscript .= directTS( $tsNode, $sim0, $startofrun );
                    }
                }
                $cshscript .= analysis(
                    {   node        => $tsNode,
                        experiment  => $expt,
                        gridSpec    => $gridspec,
                        staticFile  => $staticfile,
                        type        => "timeSeries",
                        diagSrc     => $diag_source,
                        ppRootDir   => $ppRootDir,
                        comp        => $component,
                        dtvarsRef   => \%dtvars,
                        analysisDir => $analysisdir,
                        scriptDir   => $aoutscriptdir,
                        workDir     => $workdir,
                        archDir     => $archivedir,
                        opt_t       => $hDate,
                        opt_O       => $opt_O,
                        opt_Y       => $opt_Y,
                        opt_Z       => $opt_Z,
                        opt_V       => $opt_V,
                        opt_u       => $opt_u,
                        sim0        => $sim0,
                        opt_R       => $opt_R,
                        histDir     => $histDir,
                        nLat        => $nlat,
                        nLon        => $nlon,
                        absXmlPath  => $abs_xml_path,
                        stdoutDir   => $stdoutdir,
                        opt_P       => $opt_P,
                        stdTarget   => $standardTarget,
                        opt_s       => $opt_s
                    }
                );
            } ## end foreach my $tsNode (@tsNodes)

            #TIMESERIES - MONTHLY
            my @tsNodes
                = sort by_chunk $ppcNode->findnodes('timeSeries[@freq="monthly" or @freq="month"]');
            my @chunks = map { $_->findvalue('@chunkLength') } @tsNodes;
            my $diag_source = diagfile( $ppcNode, "monthly" );
            foreach my $tsNode (@tsNodes) {
                $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
                ( my $cl, my $subchunk, my @dep ) = get_subint( $tsNode, @chunks );
                push( @depyears, @dep );
                if ($opt_v) {
                    print STDERR "      monthly ts chunklength=$cl subchunk=$subchunk";
                    if   ( "$subchunk" eq "" ) { print STDERR "history\n"; }
                    else                       { print STDERR "\n"; }
                }

                if ( !$opt_A ) {
                    if ($subchunk) {
                        $cshscript .= TSfromts( $tsNode, $sim0, $subchunk );
                    }
                    else {
                        $cshscript .= directTS( $tsNode, $sim0, $startofrun );
                    }
                }
                $cshscript .= analysis(
                    {   node        => $tsNode,
                        experiment  => $expt,
                        gridSpec    => $gridspec,
                        staticFile  => $staticfile,
                        type        => "timeSeries",
                        diagSrc     => $diag_source,
                        ppRootDir   => $ppRootDir,
                        comp        => $component,
                        dtvarsRef   => \%dtvars,
                        analysisDir => $analysisdir,
                        scriptDir   => $aoutscriptdir,
                        workDir     => $workdir,
                        archDir     => $archivedir,
                        opt_t       => $hDate,
                        opt_O       => $opt_O,
                        opt_Y       => $opt_Y,
                        opt_Z       => $opt_Z,
                        opt_V       => $opt_V,
                        opt_u       => $opt_u,
                        sim0        => $sim0,
                        opt_R       => $opt_R,
                        histDir     => $histDir,
                        nLat        => $nlat,
                        nLon        => $nlon,
                        absXmlPath  => $abs_xml_path,
                        stdoutDir   => $stdoutdir,
                        opt_P       => $opt_P,
                        stdTarget   => $standardTarget,
                        opt_s       => $opt_s
                    }
                );
            } ## end foreach my $tsNode (@tsNodes)

            #TIMESERIES - ANNUAL
            my @tsNodes     = sort by_chunk $ppcNode->findnodes('timeSeries[@freq="annual"]');
            my @chunks      = map { $_->findvalue('@chunkLength') } @tsNodes;
            my $diag_source = diagfile( $ppcNode, "annual", "annual" );
            foreach my $tsNode (@tsNodes) {
                $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
                ( my $cl, my $subchunk, my @dep ) = get_subint( $tsNode, @chunks );
                push( @depyears, @dep );
                if ($opt_v) {
                    print STDERR "      annual ts chunklength=$cl subchunk=$subchunk";
                    if   ( "$subchunk" eq "" ) { print STDERR "..."; }
                    else                       { print STDERR "\n"; }
                }

                if ( !$opt_A ) {
                    if ($subchunk) {
                        $cshscript .= TSfromts( $tsNode, $sim0, $subchunk );
                    }
                    else {
                        $cshscript .= annualTS( $tsNode, $sim0, $startofrun,
                            join( "\n", @diagtablecontent ) );
                    }
                }
                $cshscript .= analysis(
                    {   node        => $tsNode,
                        experiment  => $expt,
                        gridSpec    => $gridspec,
                        staticFile  => $staticfile,
                        type        => "timeSeries",
                        diagSrc     => $diag_source,
                        ppRootDir   => $ppRootDir,
                        comp        => $component,
                        dtvarsRef   => \%dtvars,
                        analysisDir => $analysisdir,
                        scriptDir   => $aoutscriptdir,
                        workDir     => $workdir,
                        archDir     => $archivedir,
                        opt_t       => $hDate,
                        opt_O       => $opt_O,
                        opt_Y       => $opt_Y,
                        opt_Z       => $opt_Z,
                        opt_V       => $opt_V,
                        opt_u       => $opt_u,
                        sim0        => $sim0,
                        opt_R       => $opt_R,
                        histDir     => $histDir,
                        nLat        => $nlat,
                        nLon        => $nlon,
                        absXmlPath  => $abs_xml_path,
                        stdoutDir   => $stdoutdir,
                        opt_P       => $opt_P,
                        stdTarget   => $standardTarget,
                        opt_s       => $opt_s
                    }
                );
            } ## end foreach my $tsNode (@tsNodes)

            #TIMESERIES - SEASONAL
            my @tsNodes     = sort by_chunk $ppcNode->findnodes('timeSeries[@freq="seasonal"]');
            my @chunks      = map { $_->findvalue('@chunkLength') } @tsNodes;
            my $diag_source = diagfile( $ppcNode, "seasonal", "seasonal" );
            foreach my $tsNode (@tsNodes) {
                $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
                ( my $cl, my $subchunk, my @dep ) = get_subint( $tsNode, @chunks );
                push( @depyears, @dep );
                if ($opt_v) {
                    print STDERR "      seasonal ts chunklength=$cl subchunk=$subchunk";
                    if   ( "$subchunk" eq "" ) { print STDERR "..."; }
                    else                       { print STDERR "\n"; }
                }

                if ( !$opt_A ) {
                    if ($subchunk) {
                        $cshscript .= seaTSfromts( $tsNode, $sim0, $subchunk );
                    }
                    else {
                        $cshscript .= seasonalTS( $tsNode, $sim0 );
                    }
                }
                $cshscript .= analysis(
                    {   node        => $tsNode,
                        experiment  => $expt,
                        gridSpec    => $gridspec,
                        staticFile  => $staticfile,
                        type        => "timeSeries",
                        diagSrc     => $diag_source,
                        ppRootDir   => $ppRootDir,
                        comp        => $component,
                        dtvarsRef   => \%dtvars,
                        analysisDir => $analysisdir,
                        scriptDir   => $aoutscriptdir,
                        workDir     => $workdir,
                        archDir     => $archivedir,
                        opt_t       => $hDate,
                        opt_O       => $opt_O,
                        opt_Y       => $opt_Y,
                        opt_Z       => $opt_Z,
                        opt_V       => $opt_V,
                        opt_u       => $opt_u,
                        sim0        => $sim0,
                        opt_R       => $opt_R,
                        histDir     => $histDir,
                        nLat        => $nlat,
                        nLon        => $nlon,
                        absXmlPath  => $abs_xml_path,
                        stdoutDir   => $stdoutdir,
                        opt_P       => $opt_P,
                        stdTarget   => $standardTarget,
                        opt_s       => $opt_s
                    }
                );
            } ## end foreach my $tsNode (@tsNodes)

            if ($didsomething) {
                $didsomething = 0;
            }
            else {
                print STDERR "NOTE: No calculations necessary for year $hDate for $component.\n\n";

                # if --plus option is used, store next year's frepp command to call at the end
                push @frepp_plus_calls, form_frepp_call_for_plus_option($component) if $opt{plus};
                next;
            }

            #PROCESS DEPENDENCIES
            my $depholds     = "";
            my $redothisyear = 0;
            unless ($opt_A) {

                #sort, unique dependencies
                my %seen = ();
                my @u = grep { !$seen{$_}++ } @depyears;
                @depyears = sort { $a <=> $b } @u;
                print "\nThis frepp year depends on: @depyears\n" if $opt_v;

                foreach my $depyear (@depyears) {
                    my $depfile  = "$statedir/$component.$depyear";
                    my $redo     = 0;
                    my $depstate = '';
                    if ( -e $depfile ) {
                        open( DEPFILE, "<$depfile" ) or die $!;
                        $depstate = FREUtil::cleanstr(<DEPFILE>);
                        close DEPFILE;
                        print
                            "Required year $depyear has a state file with state '$depstate' for $component.\n";
                        if ( "$depstate" eq "OK" ) {

                            #ok, keep going
                            if ($opt_o) {
                                if ($opt_s) {
                                    print
                                        "Redoing anyway because 'overwrite state files' was specified...\n";
                                    $redo         = 1;
                                    $redothisyear = 1;
                                }
                            }
                            else {
                       #print "Required year ($hDate) has already been completed for $component.\n";
                            }
                        }
                        elsif ( "$depstate" eq "FATAL" ) {
                            print
                                "Required year $depyear got an error in multiple attempts, exiting.  To retry, delete the state file $depfile\n";

                            #what if this is the -c split job? continue to other components
                            next;
                        }
                        elsif ( "$depstate" eq "INTERACTIVE" ) {
                            if ($opt_s) {
                                print
                                    "Required year $depyear has been partially run interactively but not completed, resubmitting $component...\n";
                                $redo         = 1;
                                $redothisyear = 1;
                            }
                            else {
                                print
                                    "WARNING: Required year $depyear has been run interactively but not completed, and should be rerun.\n";
                            }
                        }
                        elsif ( "$depstate" eq "ERROR" ) {
                            if ($opt_s) {
                                print
                                    "Required year $depyear got an error in the last frepp attempt, resubmitting $component...\n";
                                $redo         = 1;
                                $redothisyear = 1;
                            }
                            else {
                                print
                                    "WARNING: Required year $depyear got an error in the last frepp attempt and should be rerun.\n";
                            }
                        }
                        elsif ( "$depstate" eq "HISTORYDATAERROR" ) {
                            if ($opt_s) {
                                print
                                    "Required year $depyear got a history data error in the last frepp attempt, resubmitting $component...\n";
                                $redo         = 1;
                                $redothisyear = 1;
                            }
                            else {
                                print
                                    "WARNING: Required year $depyear got a history data error in the last frepp attempt and should be rerun.\n";
                            }
                        }
                        elsif ( "$depstate" eq '' ) {
                            print "ERROR: statefile $depfile exists but is empty, exiting.\n";

                            #what if this is the -c split job? continue to other components
                            next;
                        }
                        else {
                            #check that jobid is still running
                            my $jobrunning = isjobrunning($depstate);
                            print "Checking state of job $depstate: jobrunning=$jobrunning\n";
                            if ($jobrunning) {
                                print
                                    "Required year $depyear still working, placing a hold for $component.\n";
                                $depholds .= "$depstate:";
                            }
                            else {
                                if ($opt_s) {
                                    print
                                        "Required year $depyear job was lost, resubmitting $component...\n";
                                    $redo         = 1;
                                    $redothisyear = 1;
                                }
                                else {
                                    print
                                        "WARNING: Required year $depyear job was lost and should be rerun.\n";
                                }
                            }
                        } ## end else [ if ( "$depstate" eq "OK")]
                    } ## end if ( -e $depfile )
                    else {
                        if ($opt_s) {
                            print "Required year $depyear missing, resubmitting $component...\n";
                            $redo         = 1;
                            $redothisyear = 1;
                        }
                        else {
                            print
                                "WARNING: Required year $depyear missing. Use 'frepp -s' to submit with dependencies.\n";
                        }
                    }
                    if ($redo) {
                        my $cmd = call_frepp( $abs_xml_path, $outscript, $component, "$depyear" );
                        print "$cmd\n";
                        my $frepp_submit_output = `$cmd`;
                        print "$frepp_submit_output\n";
                        $frepp_submit_output =~ s/^$//mg;
                        my $frepp_submit_output_last_line = (split '\n', $frepp_submit_output)[-1];
                        my ($depjobid) = $frepp_submit_output_last_line =~ /Submitted batch job (\d+)/;

                        unless ( $frepp_submit_output_last_line =~ /has already been completed/ ) {
                            print "Dependent job for $depyear='$depjobid'\n";
                            my $depstatefile = "$statedir/$component.$depyear";
                            if ( ! $depjobid and ! $frepp_submit_output_last_line ) {
                                print
                                    "No jobid resulted from the job submission of $depyear.\n";
                                print "ERROR: Unable to submit dependent jobs, exiting.\n";
                                exit 1;
                            }
                            elsif ( ! $depjobid ) {
                                print
                                    "ERROR: the jobid returned has the wrong format: a frepp or batch system issue occurred.\n";
                                exit 1;
                            }
                            else {
                                $depholds .= "$depjobid:";
                                open( DEPSTATEFILE, ">$depstatefile" ) or die $!;
                                print DEPSTATEFILE "$depjobid\n";
                                close DEPSTATEFILE;
                            }
                        } ## end unless ( $depjobid =~ /has already been completed/)
                    } ## end if ($redo)

                } ## end foreach my $depyear (@depyears)
            } ## end unless ($opt_A)

#I'm not sure whether "redothisyear" means that old dependencies in the current list could be wrong? -arl
            if ( $redothisyear and !$opt_A ) {
                print
                    "This year ($hDate) has unmet dependencies for $component, submitting with holds.\n";
            }
            else {
                print "All dependencies met or known for $hDate for $component.\n" if $opt_v;
            }

            if ( "$depholds" ne "" ) {
                chop $depholds;
                $opt_w = " --dependency=afterok:$depholds";
                print "Setting holds for $hDate: $opt_w\n";
            }

            $cshscript .= mailcomponent();

            #CPIO
            if ( "$cpiomonTS" ne "" and $aggregateTS ) { $cshscript .= $cpiomonTS; }

            #END OF THIS COMPONENT; REMOVE CHECKPOINT FILE
            $cshscript .= "rm -f $ppRootDir/.checkpoint/\$checkptfile\n";

            if ($opt_c) {

                #set up dmget, set up to postprocess the following year if necessary, write script
                $mkdircommand = createdirs($mkdircommand);
                my @hf   = dmget_files();
                my @hsmf = jpk_hsmget_files();
                if ( scalar @hf ) {
                    my $hsmget_history = hsmget_history_csh(
                        $ptmpDir, $tmphistdir, $refinedir, $this_frepp_cmd,
                        join( ' ', @hf ),
                        join( ' ', @hsmf )
                    );
                    $cshscript =~ s/#hsmget_history_files/$hsmget_history/;
                    my $uncompress = uncompress_history_csh($tmphistdir);
                    $cshscript =~ s/#uncompress_history_files/$uncompress/;
                    my @sorted = sort { $a cmp $b } @hf;
                    my $check_history
                        = checkHistComplete( $tmphistdir, $sorted[0], $this_frepp_cmd, \@hsmf,
                        \@diagtablecontent );
                    $cshscript =~ s/#check_history_files/$check_history/;
                }
                $cshscript .= call_frepp( $abs_xml_path, $outscript, $component, "" );
                $cshscript .= "echo END-OF-SCRIPT for postprocessing job $t0-$tEND for $expt\n";

                # if the user sets -W, don't override the wallclock even for 1-year postprocessing
                if ( $maxyrs < 2 and !$opt{Walltime} ) {
                    if ( "$platform" eq 'x86_64' ) {
                        $cshscript =~ s/(#SBATCH --time).*/$1=20:00:00/;
                    }
                }
                if ( $maxyrs >= 20 ) {
                    if ( "$platform" eq 'x86_64' ) {
                        $cshscript =~ s/(#SBATCH --time).*/$1=$maxruntime/;
                    }
                }
                $cshscript =~ s/(#INFO:max_years=)/$1$maxyrs/;
                my $writefinalstate = <<EOF;

if ( \$errors_found == 0 ) then
  echo OK > $statefile
else if ( "\$prevjobstate" == "ERROR" ) then
  echo FATAL > $statefile
else
  echo ERROR > $statefile
endif
EOF
                unless ($opt_A) {
                    writescript(
                        "$cshscript" . "$writefinalstate", $outscript,
                        "$batchSubmit$opt_w $opt_m",       $statefile
                    );
                    $opt_w = '';
                }
            } ## end if ($opt_c)
        } ## end foreach my $ppcNode (@ppComponentNodes)

        if ( !$opt_c ) {
            die "Calling frepp without -c is no longer supported.\n";
        }

        sysmailuser();
        print "\n";

        if (@frepp_plus_calls) {
            my $N = @frepp_plus_calls;
            print
                "\nNormal frepp processing done; about to run $N frepp commands for next year, due to --plus $opt{plus}\n";
            my $i = 1;
            for my $cmd (@frepp_plus_calls) {
                printf "\n%s$cmd\n\n", $N > 1 ? "#$i/$N: " : '>';
                system $cmd;
                ++$i;
            }
        }
    } ## end foreach $expt (@ARGV)

##############################################
    # SUBROUTINES
##############################################

    sub jpkSrcFiles {
        my $jpkElem = $_[0]->getName;
        if ( $jpkElem eq "timeAverage" ) {
            my $jpkSrc = $_[0]->findvalue('../@source');
            if ( $jpkSrc eq "" ) {
                print STDERR "WARNING: no diagnostic source file specified for "
                    . $_[0]->toString() . "\n";
            }
            return $jpkSrc;
        }
        else {
            my $jpkSrc = $_[0]->findvalue('@source');
            if ( $jpkSrc eq "" ) { $jpkSrc = $_[0]->findvalue('../@source'); }
            if ( $jpkSrc eq "" ) {
                print STDERR "WARNING: no diagnostic source file specified for "
                    . $_[0]->toString() . "\n";
            }
            return $jpkSrc;
        }
    } ## end sub jpkSrcFiles

    sub jpk_hsmget_files {
        my @hsmf      = ();
        my %seen      = ();
        my @hsmfilesa = split ',', $hsmfiles;
        foreach (@hsmfilesa) {
            push( @hsmf, $_ ) unless ( $seen{$_}++ );    #uniq
        }
        if ($opt_v) { print "diagnostic files to be extracted: @hsmf\n\n"; }
        $hsmfiles = '';
        return @hsmf;
    }

    #sort, uniq list of history files to dmget
    sub dmget_files {
        my @hf            = ();
        my %seen          = ();
        my @historyfilesa = split ' ', $historyfiles;
        foreach (@historyfilesa) {
            push( @hf, $_ ) unless ( $seen{$_}++ );    #uniq
        }
        @hf = sort(@hf);
        if ($opt_v) { print "historyfiles used: @hf\n\n"; }
        $historyfiles = '';
        return @hf;
    }

    #return the csh to extract history files
    sub hsmget_history_csh {
        my $ptmpDir        = $_[0];
        my $tmphistdir     = $_[1];
        my $refinedir      = $_[2];
        my $this_frepp_cmd = $_[3];
        my $hf             = $_[4];
        my $hsmf           = $_[5];

        #this keeps users to 1,2,3,4,6,12 mo segments, but if <1yr, it should be allowed.
        #my @reqStartMonths = segStartMonths($segTime,$segUnits);
        #my $histPerYear = scalar(@reqStartMonths);
        my $beginCombineTime = `date +\%s`;

        #check for and combine raw history files online

        my @histfiles = split " ", $hf;

        #print "histfiles:".join(", ",@histfiles)."\n";
        #print "hsmf $hsmf\n";

        # Retrieve hidden debug mppnccombine flag if available or use default combiner flags
        my $mppnccombineOptsDefault = '-64 -h 16384 -m';
        my $mppnccombineOptString   = $mppnccombineOptsDefault;
        if ( exists $opt{'mppnccombine-opts'} ) {
            $mppnccombineOptString = $opt{'mppnccombine-opts'};
        }

        foreach my $h (@histfiles) {
            chdir $opt_d;
            my ($year) = $h =~ /(\d{4,})\d{4}\./;

            #print "\nyear:$year\n";
            my @availraw = split /\n/,
                `ls -1 | egrep "$year....\.raw\.nc\.cpio\$|$year....\.raw\.nc\.tar\$"`;

            #print "availraw:".join(", ", @availraw)."\n";
            my @availhf = split /\n/, `ls -1 | egrep "$year....\.nc\.cpio\$|$year....\.nc\.tar\$"`;

            #print "availhf:".join(", ", @availhf)."\n";

           #if both raw and combined data exist, and raw is newer, replace. Otherwise exit on error.
            if ( @availraw and @availhf ) {
                my %count       = ();
                my @modavailraw = @availraw;
                s/\.raw\.nc/\.nc/ for @modavailraw;

                #print "modavailraw:".join(", ", @modavailraw)."\n";
                foreach my $file ( @modavailraw, @availhf ) { $count{$file}++ }
                foreach my $file ( keys %count ) {
                    if ( $count{$file} > 1 ) {
                        my $combinedate = ( stat($file) )[9];
                        my $rawfile     = $file;
                        $rawfile =~ s/\.nc\./\.raw\.nc\./;
                        my $rawdate = ( stat($rawfile) )[9];

                        #print "combined=$combinedate raw=$rawdate\n";
                        if ( $combinedate > $rawdate ) {
                            mailuser(
                                "Date of uncombined (raw) history file is older than date of combined history file for $file. This may indicate a problem; please remove the incorrect history file and relaunch frepp with the following command, using '-s' to submit:\n\n$this_frepp_cmd"
                            );
                            sysmailuser();
                            die
                                "ERROR: Date of uncombined (raw) history file is older than date of combined history file for $file. This may indicate a problem; please remove the incorrect history file and relaunch frepp.\n";
                        }
                    }
                }
            } ## end if ( @availraw and @availhf)
            elsif ( !@availraw and !@availhf ) {
                mailuser(
                    "No history data found for year $year in $opt_d\n\nTo resubmit this frepp job when the data is available, run the following command with '-s' to submit:\n\n$this_frepp_cmd"
                );
                sysmailuser();
                die "ERROR: No history data found for year $year in $opt_d\n";
            }

            #combine raw data
            my $jobid = $ENV{SLURM_JOBID};
            my $wallTime  = 0;
            if ( $jobid ) {

                chomp( $wallTime
                        = `$ENV{FRE_COMMANDS_HOME}/sbin/batch.scheduler.time -t $jobid`
                );
                my $shreturn = $? >> 8;
                if ( $shreturn != 0 ) {
                    print "ERROR: Could not obtain wallclock time\n";
                    exit $shreturn;
                }
                print "NOTE: Requested walltime is $wallTime sec\n";
            }

            foreach my $file (@availraw) {
                my $histdate = $file;
                $histdate =~ s/(\d+)\..*/$1/;
                $histdate .= '.nc';
                my $combinedir
                    = File::Temp->newdir( 'combinehistXXXXX', DIR => $ENV{TMPDIR}, CLEANUP => 1 );

                #my $combinedir = File::Temp->tempdir( 'combinehistXXXXX', DIR => $ENV{TMPDIR});
                mkdir "$combinedir/$histdate";
                chdir "$combinedir/$histdate";
                print "\nNOTE: Copying to $combinedir, combining, and archiving file $file\n";

                #set initial timing stats
                chomp( my $segmentStart = `date +\%s` );
                my $combine = <<EOF;
$time_cp $cp $opt_d/$file .
MYSTATUS=\$?
if [ \$MYSTATUS -ne 0 ]; then
   echo WARNING: copy filed for raw history file $file, retrying.
   $time_cp $cp $opt_d/$file .
   MYSTATUS=\$?
   if [ \$MYSTATUS -ne 0 ]; then
      echo ERROR: copy failed twice for raw history file $file, exiting.
      exit 7
   fi
fi

$time_untar tar -xf $file
MYSTATUS=\$?
if [ \$MYSTATUS -ne 0 ]; then
   echo ERROR: history tar extraction failed for $file, exiting.
   exit 1
fi
$time_rm rm $file

export mppnccombineOptString='$mppnccombineOptString'

$time_combine $ENV{FRE_COMMANDS_HOME}/site/$ENV{FRE_SYSTEM_SITE}/bin/combinehist
MYSTATUS=\$?
if [ \$MYSTATUS -ne 0 ]; then
   echo ERROR: combining history files failed for $file, exiting.
   exit 1
fi

$time_hsmput hsmput -v -t -s tar -a $opt_d -p $ptmpDir/history -w $combinedir $histdate
MYSTATUS=\$?
if [ \$MYSTATUS -eq 0 ]; then
 if [ -f $opt_d/$file ] && [ -f $opt_d/$histdate.tar ]; then
 $time_rm rm $opt_d/$file
 fi
fi

EOF
                print qx("$combine");
                my $shreturn = $? >> 8;
                if ( $shreturn != 0 ) {
                    print "ERROR: Could not combine history data\n";
                    exit $shreturn;
                }

                #calculate timings, resubmit if necessary
                chomp( my $segmentEnd = `date +\%s` );
                my $timeSoFar = $segmentEnd - $beginCombineTime;
                print "NOTE: Finished a segment, timeSoFar = $timeSoFar\n";
                my $segmentTime = $segmentEnd - $segmentStart;

                #if not enough time for 2 x segmentTime, resubmit
                $segmentTime *= 2;
                if ( $wallTime > 0 ) {
                    my $timeRemaining = $wallTime - $timeSoFar;
                    if ( $segmentTime > $timeRemaining ) {
                        print "NOTE: Only $timeRemaining seconds left, resubmitting.\n";
                        sleep 2;
                        exit 99;
                    }
                }
            } ## end foreach my $file (@availraw)
        } ## end foreach my $h (@histfiles)

        #gets all avail hist files
        my $hsmget_history = <<EOF;
cd $opt_d
foreach h ( $hf )
 set historyyear = `echo \$h | sed 's/[0-9][0-9][0-9][0-9].nc.tar//'`
 set availhf = ( `ls \$historyyear????.nc.cpio \$historyyear????.nc.tar` )
 if ( "\$availhf" == "" ) then
   Mail -s "\$name year \$historyyear cannot be postprocessed" $mailList <<END
Your FRE post-processing job ( \$JOB_ID ) has exited because no history files
were found for year \$historyyear in directory:
$opt_d

FRE will attempt to transfer the history files on the remote side by retrying
the failed output stager transfers.  If later postprocessing jobs require
this postprocessing interval, this year of postprocessing will be rerun.

To recover manually, please transfer the history data with gcp,
and then resubmit this postprocessing job via:

$this_frepp_cmd

Job details:
  \$name running on \$HOST
Batch job stdout:
  \$FRE_STDOUT_PATH
END

    echo HISTORYDATAERROR > \$statefile
    sleep 30
    exit 6
 endif

 foreach historyfile ( \$availhf )
 foreach hsmsrc ( $hsmf )
  set hsmdate = \$historyfile:r
  $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$hsmdate/\\*.\$hsmsrc.\\*
  if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$hsmdate/\\*.\$hsmsrc.\\*
$checktransfer
  endif
         # Set original history compression variables to restore before placing in archive.
         # (Have to use the ptmp version as the vftmp version may already be uncompressed
         # from a previous run attempt.)
         foreach ptmpfile ( `ls $ptmpDir/history/\$hsmdate/*.\$hsmsrc.*` )
            if (! \$?history_deflation) then
                set -r history_deflation = `ncdump -sh \$ptmpfile | $grep_netcdf_compression`
                set -r history_shuffle = `ncdump -sh \$ptmpfile | $grep_netcdf_shuffle`
            endif
         end
         # Get files listed as associated_files
         foreach hsmsrcfile ( `ls $tmphistdir/\$hsmdate/*.\$hsmsrc.*` )
            # Get a list of all associated files
            set assocFiles = `ncdump -h \$hsmsrcfile | $grepAssocFiles`
            foreach assocFile ( \$assocFiles )
               $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$hsmdate/\\*\${assocFile:r}.\\*
 end
 end
      end
   end
#end loop over history year
end

# Set nccopy netcdf compression flags
if ($opt{compress}) then
    set -r nc_compression_flags = "-d 2 -s"
else if (\$?history_deflation) then
    if (\$history_deflation) then
        if (\$history_shuffle == "true") then
            set -r nc_compression_flags = "-d \$history_deflation -s"
        else
            set -r nc_compression_flags = "-d \$history_deflation"
        endif
    else
        set -r nc_compression_flags = ""
    endif
else
    set -r nc_compression_flags = ""
endif

if ( -d $refinedir ) then
  cd $refinedir
  foreach h ( $hf )
  foreach hsmsrc ( $hsmf )
   set historyyear = `echo \$h | sed 's/[0-9][0-9][0-9][0-9].nc.tar//'`
   foreach historyfile ( `ls \$historyyear????.nc.cpio \$historyyear????.nc.tar`)
    set hsmdate = \$historyfile:r
    $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir \$hsmdate/\\*.\$hsmsrc.\\*
    if ( \$status ) then
        echo "WARNING: hsmget reported failure, retrying..."
        $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir \$hsmdate/\\*.\$hsmsrc.\\*
$checktransfer
    endif
            # Get files listed as associated_files
            foreach hsmsrcfile ( `ls $tmphistdir/\$hsmdate/*.\$hsmsrc.*` )
               # Get a list of all associated files
               set assocFiles = `ncdump -h \$hsmsrcfile | $grepAssocFiles`
               foreach assocFile ( \$assocFiles )
                  $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir \$hsmdate/\\*\${assocFile:r}.\\*
                  $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$hsmdate/\\*\${assocFile:r}.\\*
               end
   end
  end
  end
   end
endif
EOF

        return $hsmget_history;
    } ## end sub hsmget_history_csh

    # uncompress netcdf compression
    sub uncompress_history_csh {
        my $dir          = shift;
        my $check_nccopy = errorstr("NCCOPY (uncompress history files)");

        return <<EOF
# uncompress all netcdf-compressed files
if (\$?history_deflation) then
    foreach file (`find $dir -type f -name "*.nc"`)
        if (`ncdump -sh \$file | $grep_netcdf_compression`) then
            $time_nccopy nccopy -d 0 \$file \$file.uncompressed
            $check_nccopy
            mv -f \$file.uncompressed \$file
            chmod 444 \$file
        endif
    end
endif
EOF
    }

    # compress pp files before placing in archive
    sub compress_csh {
        my ( $file, $check_nccopy ) = @_;

        return <<EOF
if ("\$nc_compression_flags" != "") then
    $time_nccopy nccopy \$nc_compression_flags $file $file.compressed
    $check_nccopy
    mv $file.compressed $file
endif
EOF
    }

    #check for complete history data
    sub checkHistComplete {
        my ( $dir, $hf, $frepp_cmd, $usedfiles, $diagtablecontent ) = @_;
        my $script = "cd $dir\n";

        my ($firsthisty) = $hf =~ /(\d{4,})\d{4}\./;
        my $firsthistm = substr( $userstartmo, 0, 2 );
        my $firsthistd = substr( $userstartmo, 2, 2 );
        my ( $tENDy, $tENDm, $tENDd ) = $tEND =~ /^(\d{4,})(\d{2})(\d{2})(?:\d{2}:\d{2}:\d{2})?$/;

        my $days_firsthist = FREUtil::daysSince1BC( $firsthistm, $firsthistd, $firsthisty );
        my $days_tEND      = FREUtil::daysSince1BC( $tENDm,      $tENDd,      $tENDy );

        my $firsthist = FREUtil::parseDate( $firsthisty . $userstartmo );
        my $delta = FREUtil::dateCalc( $firsthist, FREUtil::modifydate( $tEND, "+1 sec" ) );

        foreach (@$diagtablecontent) {
            if ( /"(\w*)"\s*,\s*(\d*)\s*,\s*"(\w*)"\s*,.*,.*,.*,?/ and not /^#/ ) {
                my ( $diagfile, $freq, $units ) = ( $1, $2, $3 );

                next unless ( grep { "$_" eq "$diagfile" } @$usedfiles );

                #get tEND-firsthist in hours, months, (years, days)
                my $efields  = 0;
                my $efields2 = 0;
                if ( "$units" eq "months" ) {
                    $efields = &Delta_Format( $delta, 0, "%Mt" );
                    $efields /= $freq;
                    $efields2 = $efields;
                }
                elsif ( "$units" eq "years" ) {
                    $efields = &Delta_Format( $delta, 0, "%yt" );
                    $efields /= $freq;
                    $efields2 = $efields;
                }
                elsif ( "$units" eq "days" ) {
                    if ( "$caltype" eq "julian" ) {
                        $efields  = $days_tEND - $days_firsthist + 1;
                        $efields2 = $days_tEND - $days_firsthist + 2;
                        $efields  /= $freq;
                        $efields2 /= $freq;
                    }
                }
                elsif ( "$units" eq "hours" ) {
                    if ( "$caltype" eq "julian" ) {
                        $efields  = ( $days_tEND - $days_firsthist + 1 ) * 24;
                        $efields2 = ( $days_tEND - $days_firsthist + 2 ) * 24;
                        $efields  /= $freq;
                        $efields2 /= $freq;
                    }
                }

                next if $efields == 0;
                print
                    "Will check that $diagfile ($freq $units) history data has $efields time levels ($firsthisty$firsthistm$firsthistd-$tENDy$tENDm$tENDd) \n"
                    if $opt_v;

                $script .= <<EOF;

echo NOTE: Check $diagfile time levels: compare expected and actual fields
set afields = 0
foreach file (`ls -1 */*$diagfile\.*nc | egrep -v '\.tile[2-6]\.nc'`)
   set nf = `ncdump -h \$file | grep UNLIMITED | sed 's/.*(//;s/ .*//'`
   @ afields = \$afields + \$nf
end
if ( \$afields == $efields ) then
   echo NOTE: History data has the expected number of time levels for $diagfile
else if ( \$afields == $efields2 ) then
   echo NOTE: History data has the expected number of time levels for $diagfile
else
   echo ERROR: Incomplete history data
   Mail -s "\$name year \$historyyear cannot be postprocessed" $mailList <<END
Your FRE post-processing job ( \$JOB_ID ) has exited because of incomplete
history data.  FRE expected $efields time levels in $diagfile data, but
found \$afields time levels for the interval $firsthisty$firsthistm$firsthistd-$tENDy$tENDm$tENDd.

FRE will attempt to transfer the history files on the remote side by retrying
the failed output stager transfers.  If later postprocessing jobs require
this postprocessing interval, this year of postprocessing will be rerun.

To recover manually, please transfer the history data with gcp,
and then resubmit this postprocessing job via:

$frepp_cmd

Job details:
\$name running on \$HOST
Batch job stdout:
\$FRE_STDOUT_PATH
END
    echo HISTORYDATAERROR > \$statefile
    sleep 30
    exit 7

endif
EOF
            } ## end if ( /"(\w*)"\s*,\s*(\d*)\s*,\s*"(\w*)"\s*,.*,.*,.*,?/...)
        } ## end foreach (@$diagtablecontent)

        return $script;
    } ## end sub checkHistComplete

    #make directories
    sub createdirs {
        my $mkdircommand = $_[0];

        if ( "$mkdircommand" ne "" and "$mkdircommand" ne "mkdir -p " ) {

            #if ( $opt_v ) { print "length of mkdircommand: ".length("$mkdircommand")."\n"; }
            if ( length("$mkdircommand") > 5000 ) {
                $mkdircommand =~ s/^mkdir -p //;
                my $i = index( $mkdircommand, ' ', 5000 );
                my $f = substr( $mkdircommand, 0,  $i );
                my $s = substr( $mkdircommand, $i, length($mkdircommand) );

            #if($opt_v){print "executing mkdircommand:\nfirst half:\n'$f'\n\nsecond half:\n'$s'\n";}
                execute( 'ac-arch', "mkdir -p $f" );
                execute( 'ac-arch', "mkdir -p $s" );
            }
            else {
                #if ( $opt_v ) { print "executing mkdircommand: $mkdircommand\n"; }
                execute( 'ac-arch', $mkdircommand );
            }
            $mkdircommand = "mkdir -p ";
        }

        return $mkdircommand;
    } ## end sub createdirs

  # ------ execute a command on the workstation that can write to archive. arguments: $host $command
    sub execute {
        my ( $h, $c ) = @_;
        $/ = "";
        chomp( my $platform = qx(/home/gfdl/bin/gfdl_platform) );
        if ( $platform eq 'desktop' ) {

            # ----------------------------- gfdl workstation
            my $qloginHome = '/home/gfdl/qlogin';
            return system("$qloginHome/bin/hpcs_ssh_init; $qloginHome/bin/hpcs_ssh '$h' '$c'");
        }
        else {
            # ----------------------------- other hosts
            return system("$c");
        }
    }

    #set up to postprocess the following year if necessary
    sub call_frepp {
        my $abs_xml_path = $_[0];
        my $outscript    = $_[1];
        my $component    = $_[2];
        my $year         = $_[3];
        my $depjobs      = $_[4];
        my $csh          = "";

        my $nextyear = FREUtil::modifydate( $tEND, "+ 1 sec" );
        my $nextyearf = FREUtil::graindate( $nextyear, "day" );

        if ( "$depjobs" ne "" ) {
            chop $depjobs;
            $depjobs = "-w $depjobs ";
        }

        if ( "$year" ne "" ) {
            $year .= $userstartmo;
            $csh  .= "\n/usr/bin/env perl $absfrepp -x $abs_xml_path -t $year -s -q $depjobs";
            if ($opt_P)           { $csh .= "--platform $opt_P "; }
            if ($opt_T)           { $csh .= "-T $opt_T "; }
            if ($opt_d)           { $csh .= "-d $opt_d "; }
            if ($opt_D)           { $csh .= "-D '$opt_D' "; }
            if ($opt_u)           { $csh .= "-u $opt_u "; }
            if ($opt_c)           { $csh .= "-c $component "; }
            if ($opt_m)           { $csh .= "-m '$opt_m' "; }
            if ($opt_M)           { $csh .= "-M "; }
            if ($opt_H)           { $csh .= "-H "; }
            if ($opt_o)           { $csh .= "-o "; }
            if ( $opt{compress} ) { $csh .= "--compress "; }
            $csh .= "$expt\n";
        }
        else {
            # call frepp -A for analysis scripts unless we're writing a refineDiag script
            if (! $opt_D) {
                $csh .= "\n/usr/bin/env perl $absfrepp -A -x $abs_xml_path -t $hDate -s -v ";
                if ($opt_P) { $csh .= "--platform $opt_P "; }
                if ($opt_T) { $csh .= "-T $opt_T "; }
                if ($opt_d) { $csh .= "-d $opt_d "; }
                if ($opt_u) { $csh .= "-u $opt_u "; }
                if ($opt_c) { $csh .= "-c $component "; }
                if ($opt_m) { $csh .= "-m '$opt_m' "; }
                if ($opt_M) { $csh .= "-M "; }
                if ($opt_H) { $csh .= "-H "; }
                $csh .= "$expt\n";
                $csh .= errorstr(
                    "$relfrepp had a problem creating final analysis script $expt" . "_$nextyearf" );
            }

            if ( $opt{plus} ) {
                $csh .= "\n" . form_frepp_call_for_plus_option($component) . "\n";
                $csh .= errorstr(
                    "$relfrepp had a problem creating next script $expt" . "_$nextyearf" );
            }
            $csh .= mailerrors($outscript);
        } ## end else [ if ( "$year" ne "" ) ]

        return $csh;
    } ## end sub call_frepp

    # Generate the frepp command for next year's frepp call when using the --plus option
    sub form_frepp_call_for_plus_option {
        my $comp      = shift;
        my $nextyear  = FREUtil::modifydate( $tEND, "+ 1 sec" );
        my $nextyearf = FREUtil::graindate( $nextyear, "day" );
        my $togo      = $opt{plus} - 1;
        my $plus      = $togo > 0 ? "--plus $togo" : '';
        my $cmd       = "/usr/bin/env perl $absfrepp -x $abs_xml_path -t $nextyearf $plus -s -v ";
        if ($opt_P)           { $cmd .= "--platform $opt_P "; }
        if ($opt_T)           { $cmd .= "-T $opt_T "; }
        if ($opt_d)           { $cmd .= "-d $opt_d "; }
        if ($opt_D)           { $cmd .= "-D '$opt_D' "; }
        if ($opt_u)           { $cmd .= "-u $opt_u "; }
        if ($opt_c)           { $cmd .= "-c $comp "; }
        if ($opt_m)           { $cmd .= "-m '$opt_m' "; }
        if ($opt_M)           { $cmd .= "-M "; }
        if ($opt_H)           { $cmd .= "-H "; }
        if ($opt_o)           { $cmd .= "-o "; }
        if ( $opt{compress} ) { $cmd .= "--compress "; }
        $cmd .= $expt;
        return $cmd;
    } ## end sub form_frepp_call_for_plus_option

    #set up checkpointing
    sub setcheckpt {
        my $checkpt = "$component" . "_$_[0]";
        unless ( "$_[0]" eq "staticvars" ) {
            $didsomething = 1;

            #print STDERR "DID SOMETHING: $checkpt\n";
        }
        my $csh = <<EOF;

if ( \$errors_found == 0 ) then
   echo $checkpt > $ppRootDir/.checkpoint/\$checkptfile
endif
if ( -f /home/gfdl/flags/fre/checkpoint.\$HOST || -f /home/gfdl/flags/fre/checkpoint.all || -f /home/gfdl/flags/fre/jobs/checkpoint.\$JOB_ID || -f \$HOME/fre.checkpoint.\$JOB_ID ) then
   set now = `date +\%s`
   echo "Exiting early by HPCS request at \$now, will resume with $checkpt"
   Mail -s "\$name job \$JOB_ID has been checkpointed by frepp" $mailList <<END
Your FRE post-processing job ( \$JOB_ID ) has been stopped and resubmitted
to the batch queue.  It will be re-run by the operators as soon as possible
and resume calculating $checkpt.

Job details:
\$name running on \$HOST
Batch job stdout:
\$FRE_STDOUT_PATH
END
   sleep 30
   exit 99
endif
$checkpt:
EOF
        return $csh;
    } ## end sub setcheckpt

    #call this to set up a check
    #had to use a temp file in case strings get too long, want to preserve end-of-lines.
    sub errorstr {
        my $msg = $_[0];
        if ($opt_Q) { return ""; }
        my $str = <<EOF;

if ( \$status != 0 ) then
 @ errors_found += 1
 echo "ERROR: $msg"
 echo "ERROR: $msg" >> \$work/.errors
 exit 1
endif

EOF
        return $str;
    }

    sub retryonerrorstart {
        my $cmd = $_[0];
        if ($opt_Q) { return "if ( \$status != 0 ) then\n"; }
        my $str = <<EOF;
   set thisstatus = \$status
   if ( \$thisstatus != 0 ) then
      echo ERROR: $cmd returned status \$thisstatus
      sleep 30
EOF
        return $str;
    }

    sub retryonerrorend {
        my $msg = $_[0];
        if ($opt_Q) { return "endif\n"; }
        my $str = <<EOF;
      set thisstatus = \$status
      if ( \$thisstatus != 0 ) then
         echo ERROR ON RETRY: status \$thisstatus
         @ errors_found += 1
         echo "ERROR: $msg"
         echo "ERROR: $msg" >> \$work/.errors
      else
         echo RETRY SUCCESSFUL.
      endif
   endif

EOF
        return $str;

    }

    #fatal error - exit script immediately, but email the user the error first
    sub fatalerrorstr {
        my $msg       = $_[0];
        my $outscript = $_[1];
        if ($opt_Q) { return ""; }
        my $createmailfile = mailerrors("$archivedir");
        my $sendemail      = mailcomponent();

        my $str = <<EOF;

if ( \$status != 0 ) then
 @ errors_found += 1
 echo "FATAL ERROR: $msg"
 echo "FATAL ERROR: $msg" >> \$work/.errors
 $createmailfile
 cat >> \$work/.errorssend <<END

You will need to resubmit the job when the error conditions are resolved:
$batchSubmit $outscript
END
 $sendemail
 exit 1
endif

EOF
        return $str;
    } ## end sub fatalerrorstr

    #appends the current batch of errors to a text file for mailing to the user
    #call this at the end of each piece of postprocessing, or you'll have too few/many messages
    sub mailerrors {
        my $outdir = $_[0];
        if ($opt_Q) { return ""; }
        my $str = <<EOF;

if ( -e \$work/.errors ) then
  set errorlines = `cat \$work/.errors | wc -l`
  if ( \$errorlines ) then
    cat > \$work/.errorshead <<END

Errors are reported by the shell script created by $relfrepp working in
$outdir
Grep for 'ERROR' in
\$FRE_STDOUT_PATH
for details.
END
    if ( -e \$work/.errorssend ) then
      cat \$work/.errorshead \$work/.errors >> \$work/.errorssend
    else
      cat \$work/.errorshead \$work/.errors > \$work/.errorssend
    endif
  endif
  $time_rm rm -rf \$work/.errors \$work/.errorshead
endif

EOF
        return $str;
    } ## end sub mailerrors

    #mail the user the csh errors that may have accumulated in $work/.errorssend
    #call this at the end of each component
    sub mailcomponent {
        if ($opt_Q) { return ""; }
        my $str = <<EOF;

if ( -e \$work/.errorssend ) then
set errorlines = `cat \$work/.errorssend | wc -l`
if ( \$errorlines ) then
Mail -s "$relfrepp CSH ERROR: $expt $component $hDate" $mailList < \$work/.errorssend
$writestate
sleep 30
endif
$time_rm rm -rf \$work/.errors*
endif

EOF
        return $str;

    }

    #if a batch job, build an error string of the bad news from perl
    sub mailuser {
        my $msg = $_[0];
        $perlerrors = "ERROR: $msg\n\n$perlerrors";
    }

    #mail user any errors at end of perl script execution
    sub sysmailuser {
        if ( "$perlerrors" ne "" ) {
            my $jobid = $ENV{SLURM_JOBID};
            if ( $jobid ) {
                my $outpath = File::Spec->catfile($stdoutdir, 'postProcess', "$ENV{SLURM_JOB_NAME}.o$jobid");
                my $str = <<EOF;
Mail -s "$relfrepp PERL ERROR: $expt $hDate" $mailList <<END
Error message(s) have been reported by $relfrepp while
creating postprocessing scripts for year $hDate of the
experiment $expt, in the stdout file

$outpath

$perlerrors
END
EOF
                system $str;
                sleep 30;
            }
        } ## end if ( "$perlerrors" ne ...)
    } ## end sub sysmailuser

    #begin system timings
    sub begin_systime {
        my $csh = <<EOF;
echo SYSTEM TIME FOR \$outdir
set systime1 = `$systimecmd`

EOF
        return $csh;
    }

    #end system timings
    sub end_systime {
        my $csh = <<EOF;
set systime2 = `$systimecmd`
@ ttlsystime = \$systime2 - \$systime1
echo TOTAL SYSTEM TIME = \$ttlsystime
set diskusage = `du -ksh \$TMPDIR | cut -f1`
echo TOTAL DISK USAGE IN TMPDIR "\$TMPDIR": \$diskusage
echo '================================================'

EOF
        return $csh;
    }

    #check whether a job is running
    sub isjobrunning {
        my $jobid = $_[0];
        my $cmd   = "squeue -u $ENV{USER} -o %i";
        my $line;
        open( my $handle, "$cmd 2>&1 |" );
        while ( $line = <$handle> ) {
            chomp($line);
            if ( $line =~ /\b$jobid\b/ ) { close($handle); return 1; }
        }
        close($handle);
        return 0;
    }

    #set up interpolation on z levels
    sub zInterpolate {
        my $zInterp   = $_[0];
        my $infile    = $_[1];
        my $outfile   = $_[2];
        my $caltype   = $_[3];
        my $variables = $_[4];
        my $source    = $_[5];
        if ($opt_V) { print STDERR "in zInterpolate, $zInterp $infile $outfile $caltype\n"; }

        my $csh = "";

        #set up atmospheric pressure levels
        my $ncep_levels = <<EOF;
echo 'Using zInterp ncep'
set levels = (100000 92500 85000 70000 60000 50000 40000 30000 25000 20000 15000 \\
              10000  7000  5000  3000  2000  1000                               )
EOF
        my $am3_levels = <<EOF;
echo 'Using zInterp am3'
set levels = (100000 92500 85000 70000 60000 50000 40000 30000 25000 20000 15000 \\
              10000  7000  5000  3000  2000  1000   500   300   200   100       )
EOF
        my $hs20_levels = <<EOF;
echo 'Using zInterp hs20'
set levels = ( 2500  7500 12500 17500 22500 27500 32500 37500 42500 47500 \\
               52500 57500 62500 67500 72500 77500 82500 87500 92500 97500 )
EOF
        my $era40_levels = <<EOF;
echo 'Using zInterp era40'
set levels = (100000 92500 85000 77500 70000 60000 50000 40000 30000 25000 20000 15000 \\
                10000  7000  5000  3000  2000  1000   700   500   300   200   100       )
EOF

        my $narcaap_levels = <<EOF;
echo 'Using zInterp narcaap'
set levels = ( 2500  5000  7500  10000  12500  15000 17500 20000 22500 25000 27500 30000 \\
              32500 35000 37500  40000  42500  45000 47500 50000 52500 55000 57500 60000 \\
              62500 65000 67500  70000  72500  75000 77500 80000 82500 85000 87500 90000 \\
              92500 95000 97500 100000 102500 105000 )
EOF
        my $ar5daily_levels = <<EOF;
echo 'Using zInterp ar5daily'
set levels = (100000 85000 70000 50000 25000 10000 5000 1000)
EOF
        my $ncepSubset_levels = <<EOF;
echo 'Using zInterp ncep_subset'
set levels = ( 925 850 700 500 250 )
EOF

        my $set_plevels = "";
        if    ( "$zInterp" eq "ncep" )        { $set_plevels = $ncep_levels; }
        elsif ( "$zInterp" eq "am3" )         { $set_plevels = $am3_levels; }
        elsif ( "$zInterp" eq "hs20" )        { $set_plevels = $hs20_levels; }
        elsif ( "$zInterp" eq "era40" )       { $set_plevels = $era40_levels; }
        elsif ( "$zInterp" eq "narcaap" )     { $set_plevels = $narcaap_levels; }
        elsif ( "$zInterp" eq "ar5daily" )    { $set_plevels = $ar5daily_levels; }
        elsif ( "$zInterp" eq "ncep_subset" ) { $set_plevels = $ncepSubset_levels; }
        elsif ( "$zInterp" eq "zgrid" )       { }
        else {

            if ( "$zInterp" ne "" ) {
                mailuser("zInterp $zInterp not recognized, not interpolating $outfile");
                print STDERR "ERROR: zInterp $zInterp not recognized, not interpolating $outfile\n";
            }
        }

        my $check_plevel  = errorstr("PLEVEL ($outfile)");
        my $check_ncdump  = errorstr("NCDUMP ($outfile)");
        my $check_ncks    = errorstr("NCKS ($outfile)");
        my $check_zgrid   = errorstr("ZGRID (Calling Resample_on_Z for $outfile)");
        my $check_ncatted = errorstr("NCATTED ($outfile)");
        my $plev_command  = '$PLEVEL -a';
        if ( "$variables" ne "" ) {
            $variables =~ s/,/ /g;
            $variables =~ s/'//g;
            $variables =~ s/^-v//g;
            $plev_command = '$PLEVEL';
            if ($opt_v) {
                my $count = $variables =~ s/((^|\s)\S)/$1/g;
                print STDERR
                    "NOTE: will interpolate $count variables to pressure levels for $infile\n";
            }
        }

        #atmospheric pressure levels
        if (   "$zInterp" eq "ncep"
            or "$zInterp" eq "am3"
            or "$zInterp" eq "narcaap"
            or "$zInterp" eq "hs20"
            or "$zInterp" eq "era40"
            or "$zInterp" eq "ar5daily"
            or "$zInterp" eq "ncep_subset" ) {

            $csh .= <<EOF;
   $set_plevels

   set reqvars = `\$NCVARS -st12 $infile | grep -e '^ *bk\$' -e '^ *pk\$' -e '^ *ps\$' -c`
   set hgtvars = `\$NCVARS -st23 $infile | grep -e '^ *temp\$' -e '^ *sphum\$' -e '^ *zsurf\$' -c`

   set vars3d  = `\$NCVARS -st3  $infile`

   if ( \$reqvars == 3 && \$#vars3d > 0 ) then
      set vlist = ()
      if ( \$hgtvars == 3 ) then
         set vlist = (divv rvort hght slp)
      endif
      $time_plevel $plev_command -p "\$levels" -i $infile -o plev.nc \$vlist $variables
      $check_plevel
      set string = `ncdump -h plev.nc | grep UNLIMITED`
      $check_ncdump
      set timename   = `echo \$string[1]`
      set string = `ncdump -h plev.nc | grep calendar_type`
      set caltype   = `echo \$string[3] | sed 's/"//g'`
      if ( "\$caltype" == "" ) set caltype = $caltype
      $time_ncatted ncatted -h -O -a calendar,\$timename,c,c,\$caltype plev.nc
      $check_ncatted
      $time_mv $mv plev.nc $outfile
      $time_rm rm -f $infile
   else if ( \$reqvars < 3 && \$#vars3d > 0 ) then
      echo ERROR: zInterp requested for $source, but missing one or more required variables
      exit 1
   else
      $time_mv $mv $infile $outfile
   endif
EOF

        } ## end if ( "$zInterp" eq "ncep"...)
        elsif ( "$zInterp" eq "zgrid" ) {    #ocean
            if ( "$variables" eq "" ) {
                $variables = "temp,salt,age,u,v";
                print STDERR "NOTE: No variables specified, resampling $variables to zgrid\n";
            }
            else {
                $variables =~ s/ //;
                $variables =~ s/'//g;
                $variables =~ s/^-v//g;
                if ($opt_v) {
                    my $count = $variables =~ s/((^|\s)\S)/$1/g;
                    print STDERR "NOTE: will interpolate $count variables to zgrid for $infile\n";
                }
            }
            if ( "$platform" eq "x86_64" ) {
                $csh .= <<EOF;
    set taxis = `ncdump -h $infile | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
    #set hasclimbounds = `ncdump -h $infile | grep 'climatology_bounds' | wc -l`
    if ( `ncdump -h $infile | grep -c " climatology_bounds("` == 1 ) then
      $time_zgrid /home/rwh/data/regrid_MESO/Resample_on_Z_new -d/home/rwh/data/regrid_MESO/OM3_zgrid.nc -V:$variables -T:average_T1,average_T2,average_DT,climatology_bounds -ee -o$outfile $infile
      $check_zgrid
    else
      $time_zgrid /home/rwh/data/regrid_MESO/Resample_on_Z_new -d/home/rwh/data/regrid_MESO/OM3_zgrid.nc -V:$variables -T:average_T1,average_T2,average_DT,\${taxis}_bounds -ee -o$outfile $infile
      $check_zgrid
    endif
EOF
            }
        } ## end elsif ( "$zInterp" eq "zgrid")
        else {
            $csh .= <<EOF;
      $time_mv $mv $infile $outfile
EOF
        }

        return $csh;
    } ## end sub zInterpolate

    #
    sub segStartMonths {
        my $segTime  = $_[0];
        my $segUnits = $_[1];

        if (   ( $segTime == 1 and "$segUnits" eq "years" )
            or ( $segTime == 12 and "$segUnits" eq "months" ) ) {
            return qw(0101);
        }
        elsif ( $segTime == 6 ) {
            return qw(0101 0701);
        }
        elsif ( $segTime == 4 ) {
            return qw(0101 0501 0901);
        }
        elsif ( $segTime == 3 ) {
            return qw(0101 0401 0701 1001);
        }
        elsif ( $segTime == 2 ) {
            return qw(0101 0301 0501 0701 0901 1101);
        }
        elsif ( $segTime == 1 and "$segUnits" eq "months" ) {
            return qw(0101 0201 0301 0401 0501 0601 0701 0801 0901 1001 1101 1201);
        }
        else {
#print STDERR "ERROR: segTime $segTime not supported.  Try 1,2,3,4,6 or 12 month segments.\n" if not $opt_f;
#return ();
            die
                "ERROR: segTime $segTime not supported for timeAverages.  Try 1,2,3,4,6 or 12 month segments.\n"
                if not $opt_f;
        }

    } ## end sub segStartMonths

    #make csh for splitting history files into monthly files
    sub convertSegments {
        my $segTime     = $_[0];
        my $segUnits    = $_[1];
        my $diag_source = $_[2];
        my $type        = $_[3];
        my $convertSeg  = "";
        my $convertDec  = "";

        my $cubicLoopStart    = "";
        my $cubicLoopEnd      = "";
        my $cubicLinkGridSpec = "";
        if ( "$sourceGrid" eq 'cubedsphere' ) {
            $cubicLoopStart = "set i = 1\nwhile ( \$i <= 6 )";
            $cubicLoopEnd   = "@ i ++\nend";
            $diag_source    = "$diag_source.tile\$i";
        }

        if ( $segTime == 6 ) {
            if ( "$sourceGrid" eq 'cubedsphere' ) {
                $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0301.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0401.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0501.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0901.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1001.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1101.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
            }
            $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0101.$diag_source.nc \${hDate}0301.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0101.$diag_source.nc \${hDate}0401.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,5,5 \${hDate}0101.$diag_source.nc \${hDate}0501.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,6,6 \${hDate}0101.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0701.$diag_source.nc tmp07.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0701.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0701.$diag_source.nc \${hDate}0901.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0701.$diag_source.nc \${hDate}1001.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,5,5 \${hDate}0701.$diag_source.nc \${hDate}1101.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,6,6 \${hDate}0701.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp07.nc \${hDate}0701.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
            $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,6,6 \${prevyear}0701.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
        } ## end if ( $segTime == 6 )
        elsif ( $segTime == 2 ) {
            if ( "$sourceGrid" eq 'cubedsphere' ) {
                $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0401.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1001.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
            }
            $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0301.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0301.$diag_source.nc \${hDate}0401.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0301.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0501.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0501.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0501.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0701.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0701.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0701.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0901.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0901.$diag_source.nc \${hDate}1001.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0901.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}1101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}1101.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}1101.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
            $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${prevyear}1101.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
        } ## end elsif ( $segTime == 2 )
        elsif ( $segTime == 3 ) {
            if ( "$sourceGrid" eq 'cubedsphere' ) {
                $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0301.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0501.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0901.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1101.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
            }
            $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0101.$diag_source.nc \${hDate}0301.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0401.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0401.$diag_source.nc \${hDate}0501.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0401.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0401.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0701.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0701.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0701.$diag_source.nc \${hDate}0901.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0701.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}1001.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}1001.$diag_source.nc \${hDate}1101.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}1001.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}1001.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
            $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${prevyear}1001.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
        } ## end elsif ( $segTime == 3 )
        elsif ( $segTime == 4 ) {
            if ( "$sourceGrid" eq 'cubedsphere' ) {
                $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0301.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0401.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0701.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1001.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1101.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
            }
            $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0101.$diag_source.nc \${hDate}0301.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0101.$diag_source.nc \${hDate}0401.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0501.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0501.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0501.$diag_source.nc \${hDate}0701.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0501.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0501.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0901.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0901.$diag_source.nc \${hDate}1001.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0901.$diag_source.nc \${hDate}1101.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0901.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0901.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
            $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${prevyear}0901.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
        } ## end elsif ( $segTime == 4 )
        elsif (( $segTime == 1 and "$segUnits" eq "years" )
            or ( $segTime == 12 and "$segUnits" eq "months" ) ) {
            if ( "$sourceGrid" eq 'cubedsphere' ) {
                $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0301.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0401.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0501.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0701.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0901.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1001.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1101.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
            }
            $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0101.$diag_source.nc \${hDate}0301.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0101.$diag_source.nc \${hDate}0401.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,5,5 \${hDate}0101.$diag_source.nc \${hDate}0501.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,6,6 \${hDate}0101.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,7,7 \${hDate}0101.$diag_source.nc \${hDate}0701.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,8,8 \${hDate}0101.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,9,9 \${hDate}0101.$diag_source.nc \${hDate}0901.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,10,10 \${hDate}0101.$diag_source.nc \${hDate}1001.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,11,11 \${hDate}0101.$diag_source.nc \${hDate}1101.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,12,12 \${hDate}0101.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
            $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,12,12 \${prevyear}0101.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
        } ## end elsif ( ( $segTime == 1 and...))
        elsif ( $segTime != 1 ) {
            print STDERR
                "ERROR: $diag_source: segTime $segTime not supported for seasonal calculations.  Try 1,2,3,4,6 or 12 month segments.\n";
        }

        if ( "$type" eq "dec" ) { return $convertDec; }
        return $convertSeg;
    } ## end sub convertSegments

    #sort array by interval attribute
    sub by_interval {
        my $int1 = $a->findvalue('@interval');
        my $int2 = $b->findvalue('@interval');
        return $int1 <=> $int2;
    }

    #sort array by chunkLength attribute
    sub by_chunk {
        my $int1 = $a->findvalue('@chunkLength');
        my $int2 = $b->findvalue('@chunkLength');
        return $int1 <=> $int2;
    }

    #return appropriate subinterval
    sub get_subint {

        #my $node = $_[0];
        my $interval = "";
        my $name     = $_[0]->getName();
        if ( "$name" eq "timeSeries" ) {
            $interval = $_[0]->findvalue('@chunkLength');
        }
        elsif ( "$name" eq "timeAverage" ) {
            $interval = $_[0]->findvalue('@interval');
        }
        else {
            print STDERR
                "ERROR: nodes of type $name are not supported, only timeSeries and timeAverage\n";
        }
        $interval =~ s/yr$//;
        my $from = $_[0]->findvalue('@from');
        if ( "$from" ne "" ) {
            $from =~ s/yr$//;
            return ( $interval, $from );
        }
        shift(@_);

        my @ints = map { ( my $x = $_ ) =~ s/yr$//; $x; } @_;

#if($opt_v){print "nodename is $name, interval is $interval, ints is @ints, from is $from, rest is @_\n";}
        my $subint = undef;
        foreach (@ints) {
            if ( $interval and $_ and $interval > $_ and ( $interval % $_ ) == 0 ) { $subint = $_; }
        }

        #get dependant years
        my @depyears   = ();
        my ($thisyear) = FREUtil::splitDate($t0);
        my ($simstart) = FREUtil::splitDate($sim0);

#print "in get_subint with thisyear=$thisyear, simstart=$simstart, interval=$interval, subint=$subint\n";

        unless ( "$subint" eq '' ) {
            my $i = 1;
            while ( ( $thisyear - ( $subint * $i ) ) > ( $thisyear - $interval )
                and ( $thisyear - ( $subint * $i ) ) >= $simstart ) {
                if ( ( ( $thisyear - $simstart + 1 ) % $interval ) == 0 ) {
                    push( @depyears, FREUtil::padzeros( $thisyear - ( $subint * $i ) ) );

                    #print "in get_subint, adding dep=$thisyear-($subint*$i)  --  @depyears\n";
                }
                $i++;
            }
        }

        return ( $interval, $subint, @depyears );
    } ## end sub get_subint

    #least common multiple
    sub lcm {
        use integer;
        my $lcm = shift;
        foreach (@_) { $lcm *= $_ / gcd( $_, $lcm ) }
        no integer;
        return $lcm;
    }

    #greatest common denominator
    sub gcd {
        use integer;
        my $gcd = shift || 1;
        while (@_) {
            my $next = shift;
            while ($next) {
                my $r = $gcd % $next;
                $r += $next if $r < 0;
                $gcd  = $next;
                $next = $r;
            }
        }
        no integer;
        return $gcd;
    }

    #create a cpio and dmput original files.  Also dmput only when a cpio is not created.
    sub createcpio {
        my $cache     = $_[0];
        my $outdir    = $_[1];
        my $prefix    = $_[2];
        my $abbrev    = $_[3];
        my $dmputOnly = $_[4];
        my $csh       = "";

        if ($dmputOnly) {
            $csh = <<EOF;
cd $outdir
$time_dmput dmput "$prefix.*.nc"
cd \$work
EOF

        }
        else {
            $csh = <<EOF;
cd $cache
set numfilestocpio = `ls $prefix.*.nc | wc -l`
if ( \$numfilestocpio > 0 ) then

if ( ! -e $outdir/$prefix.$abbrev.nc.cpio ) then
   ls -1 $prefix.*.nc | $time_mkcpio $cpio -oKvO \$work/$prefix.$abbrev.nc.cpio
   $time_mv $mvfile \$work/$prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$work/$prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
      $checktransfer
   endif
   $time_rm rm \$work/$prefix.$abbrev.nc.cpio
else
   $time_dmget dmget $outdir/$prefix.$abbrev.nc.cpio
   $time_cp $cp $outdir/$prefix.$abbrev.nc.cpio .
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_cp $cp $outdir/$prefix.$abbrev.nc.cpio .
      $checktransfer
   endif
   set files = ( `ls $prefix.*.nc` )
   set filesincpio = ( `$cpio -itI $prefix.$abbrev.nc.cpio` )
   set exist = ()
   foreach file ( \$files )
     foreach fileincpio ( \$filesincpio )
         if ( "\$file" == "\$fileincpio" ) then
            set exist = ( \$exist \$file )
         endif
     end
   end
   if ( \$#exist == 0 ) then
      ls -1 $prefix.*.nc | $time_mkcpio $cpio -oKvAO $prefix.$abbrev.nc.cpio
      $time_mv $mvfile $prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
         $checktransfer
      endif
      $time_rm rm $prefix.$abbrev.nc.cpio
   else
      mkdir \$work/mkcpio
      cd \$work/mkcpio
      $time_uncpio $cpio -ivI $outdir/$prefix.$abbrev.nc.cpio
      cd $outdir
      #this is a local cp within vftmp
      $time_cp cp \$files \$work/mkcpio
      cd \$work/mkcpio
      ls -1 $prefix.*.nc | $time_mkcpio $cpio -oKvO $prefix.$abbrev.nc.cpio
      $time_mv $mvfile $prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
         $checktransfer
      endif
      cd \$work
      $time_rm rm -rf \$work/mkcpio
   endif
endif

cd $outdir
$time_dmput dmput "$prefix.*.nc"
$time_dmput dmput  $prefix.$abbrev.nc.cpio

endif
cd \$work
EOF
        } ## end else [ if ($dmputOnly) ]

        return $csh;
    } ## end sub createcpio

    #get appropriate number of time levels in a time series file
    sub gettimelevels {
        my $freq = $_[0];
        my $cl   = $_[1];
        $cl =~ s/yr//;

        if ( "$freq" =~ /daily/ or "$freq" =~ /day/ ) {
            return 365 * $cl;
        }
        elsif ( "$freq" =~ /mon/ ) {
            return 12 * $cl;
        }
        elsif ( "$freq" =~ /ann/ or "$freq" =~ /yr/ or "$freq" =~ /year/ ) {
            return $cl;
        }
        elsif ( "$freq" =~ /hour/ or "$freq" =~ /hr/ ) {
            my $n = $freq;
            $n =~ s/hr$//;
            if ( $n =~ /^\d+$/ and $n != 0 ) {
                return 365 * 24 * $cl / $n;
            }
            else {
                return 365 * 24 * $cl;
            }
        }
        elsif ( $freq =~ /(\d+)min$/ ) {
            my $count_per_hour = 60 / $1;
            return 365 * 24 * $count_per_hour * $cl;
        }
        elsif ( "$freq" =~ /season/ ) {
            return 1 * $cl;    #only one season per year per file, so this must be 1
        }
        else {
            print STDERR "WARNING: frequency not recognized in gettimelevels\n";
            return $cl;
        }
    } ## end sub gettimelevels

    #get the name of the diagnostic output file from the source attribute
    sub diagfile {
        my $ppcNode     = $_[0];
        my $freq        = $_[1];
        my $src         = $_[2];
        my $diag_source = "";

        #STATIC
        #TIMESERIES - ANNUAL or SEASONAL
        if ( $src eq "annual" or $src eq "seasonal" ) {
            my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
            if ( scalar @monthnodes ) {
                my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
                $diag_source = $monthnode->getAttribute('@source');
            }
            if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('@source'); }
            if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }
        }

        #TIMESERIES - from smaller timeSeries
        if ( $src ne "seasonal" and $src ne "annual" ) {
            my @nodes = $ppcNode->findnodes("timeSeries[\@freq='$freq']");
            if ( scalar @nodes ) {
                my $node = $ppcNode->findnodes("timeSeries[\@freq='$freq']")->get_node(1);
                $diag_source = $node->getAttribute('@source');
            }
            if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('@source'); }
            if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }
        }
        return $diag_source;
    } ## end sub diagfile

    #TIMESERIES - ANNUAL
    sub annualTS {

        #tsNode = $_[0] ;
        my $sim0             = $_[1];
        my $startofrun       = $_[2];
        my $diagtablecontent = $_[3];
        my $ppcNode          = $_[0]->parentNode;

        my $freq   = 'annual';
        my $source = 'monthly';    #always use monthly, don't need $tsNode->findvalue('@source');
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $outdirpath  = "$component/ts/$freq/$chunkLength";
        my $outdir      = "$ppRootDir/$outdirpath";
        if ( "$chunkLength" eq "" ) {
            mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
            print STDERR
                "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
            return "";
        }

        #need timeSeries freq=monthly chunkLength=something.  Then split apart into yearly data.
        #prefer identical chunklength if available
        my $TSchunkLength = "";
        my $desiredts     = "timeSeries[\@freq='monthly' and \@chunkLength='$chunkLength']\n";
        foreach my $node ( $ppcNode->findnodes("$desiredts") ) {
            $TSchunkLength = $node->findvalue('@chunkLength');
            if ( "$TSchunkLength" ne "" ) {
                print STDERR "will use monthly_ts cl=$TSchunkLength\n" if $opt_v;
                last;
            }
        }

        #otherwise use whatever is available, but we don't support 1yr for now
        if ( "$TSchunkLength" eq "" ) {
            my $requiredts = "timeSeries[\@freq='monthly']\n";
            foreach my $node ( $ppcNode->findnodes("$requiredts") ) {
                $TSchunkLength = $node->findvalue('@chunkLength');
                if ( "$TSchunkLength" ne "" and "$TSchunkLength" ne "1yr" ) {
                    print STDERR "will use monthly_ts cl=$TSchunkLength\n" if $opt_v;
                    last;
                }
            }
        }

        my $reqpath = "\$tempCache/$component/ts/monthly/$TSchunkLength";

        if ( "$TSchunkLength" eq "" ) {
            my @existing = <$reqpath/*/*>;
            if ( scalar(@existing) eq 0 ) {

                #if have annual diag data, this TS can be created with directTS
                my $mysource = $_[0]->findvalue('@source');
                if ( "$mysource" eq "" ) { $mysource = $ppcNode->findvalue('@source'); }
                my @dtc = split( "\n", $diagtablecontent );
                my @sourcelines = grep( /^\s*['"]$mysource['"]/, @dtc );
                my @fd = split( /,/, $sourcelines[0] );
                if (   ( $fd[1] == "1" and $fd[2] =~ /year/ )
                    or ( $fd[1] == "12" and $fd[2] =~ /month/ ) ) {
                    print STDERR "using history file $mysource\n" if $opt_v;
                    return directTS( $_[0], $sim0, $startofrun );
                }
                else {
                    mailuser(
                        "Cannot create $component $freq timeSeries unless you generate <timeSeries freq='monthly' chunkLength='Xyr'>"
                    );
                    print STDERR
                        "\nERROR: Cannot create $component $freq timeSeries unless you generate <timeSeries freq='monthly' chunkLength='Xyr'>\n";
                    return "";
                }
            } ## end if ( scalar(@existing)...)
            else {
                my @reqfiles = <$reqpath/*>;
                chomp( $TSchunkLength = `ls -1 $reqpath | sort -g | head -1` );
                $TSchunkLength =~ s/$reqpath//;
                $TSchunkLength =~ s/\///g;
                print STDERR
                    "$component $freq timeSeries calculation found data at ts/monthly/$TSchunkLength\n"
                    if $opt_v;
            }
            $reqpath = "\$tempCache/$component/ts/monthly/$TSchunkLength";
        } ## end if ( "$TSchunkLength" ...)

        my $tmp = FREUtil::modifydate( $tEND, "+1 sec" );
        my $yrsSoFar = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $int = $TSchunkLength;
        $int =~ s/yr//;
        my $mod = $yrsSoFar % $int;
        if ( $mod != 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        my $cl = $chunkLength;
        $cl =~ s/yr//;
        if ( $int > $maxyrs ) { $maxyrs = $int; }

#this is not exactly right.  You need to make it not do any annualTS till $cl and to leave it in $TMP till everything's done.
#then change this to $cl

        #check that all files up to current time exist
        my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
        my $diag_source = "";
        if ( scalar @monthnodes ) {
            my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
        $variables =~ s/ /.nc /g;
        if ( "$variables" ne "" ) { $variables =~ s/$/.nc/g }

        my $tBEG = FREUtil::modifydate( $tEND, "-$int years +1 sec" );
        my $tBEGf = FREUtil::graindate( $tBEG, 'monthly' );
        my $tENDf = FREUtil::graindate( $tEND, 'monthly' );
        my $check_ncdump  = errorstr("NCDUMP ($component $freq ts from $source)");
        my $check_ncks    = errorstr("NCKS ($component $freq ts from $source)");
        my $check_timavg  = retryonerrorend("TIMAVG ($component $freq ts from $source)");
        my $retry_timavg  = retryonerrorstart("TIMAVG");
        my $check_ncrcat  = errorstr("NCRCAT ($component $freq ts from $source)");
        my $check_ncatted = errorstr("NCATTED ($component $freq ts from $source)");
        my $check_dmget   = errorstr("DMGET ($component $freq ts from $source)");
        my $check_nccopy  = errorstr("NCCOPY ($component $freq ts from $source)");
        my $csh           = setcheckpt("annualTS_$chunkLength");
        $csh .= <<EOF;

#####################################
echo 'timeSeries ($component $freq ts from $source)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath
EOF
        if ($opt_z) { $csh .= begin_systime(); }

        foreach my $chunkyear ( 0 .. ( $int - 1 ) ) {
            my $tYEAR = FREUtil::modifydate( $tBEG, "+ $chunkyear years" );
            my $tYEARf     = FREUtil::graindate( $tYEAR, 'annual' );
            my $startmonth = $chunkyear * 12 + 1;
            my $endmonth   = $startmonth + 11;

            #if it is time, chunk the files`
            #if tYEARf-sim0 % chunklength == 0 then cat files to outfile
            my $catfiles       = "";
            my $makecpio       = "";
            my $getlist        = "";
            my $chunkedoutfile = "";

            #print "tYEARf=$tYEARf sim0=$sim0 cl=$cl\n";
            if ( ( $tYEARf - FREUtil::graindate( $sim0, 'annual' ) + 1 ) % $cl == 0 ) {
                my $n = $cl - 1;
                my $begin = FREUtil::modifydate( $tYEAR, "- $n years" );
                $begin = FREUtil::graindate( $begin, 'annual' );
                $chunkedoutfile = "$component.$begin-$tYEARf.\$var";
                my $filelist = "";
                foreach my $year ( $begin .. $tYEARf ) {
                    $year = FREUtil::padzeros($year);
                    $filelist .= "\$tempCache/$component.$year.\$var ";
                    $getlist  .= "$component.$year.*.nc ";
                }
                if ($aggregateTS) {
                    $makecpio = createcpio( "\$tempCache/$outdirpath", $outdir,
                        "$component.$begin-$tYEARf", FREUtil::timeabbrev($freq), 1 );
                }
                my $compress = compress_csh( $chunkedoutfile, $check_nccopy );
                $catfiles = <<EOF;
if ( -e $chunkedoutfile ) rm -f $chunkedoutfile
$time_ncrcat ncrcat \$ncrcatopt $filelist $chunkedoutfile
$check_ncrcat
$time_ncatted ncatted -h -O -a filename,global,m,c,"$chunkedoutfile" $chunkedoutfile
$check_ncatted
$compress
$time_mv $mvfile $chunkedoutfile $outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $chunkedoutfile $outdir/
   $checktransfer
endif
$time_mv $mv $chunkedoutfile \$tempCache/$outdirpath/
$time_rm rm -f $filelist
EOF
            } ## end if ( ( $tYEARf - FREUtil::graindate...))

            #set up loop over variables
            my $forloop = "";
            if ( "$variables" eq "" ) {
                $forloop = <<EOF;
  foreach file ( $reqpath/$component.$tBEGf-$tENDf.*.nc )
    set var = `echo \$file | sed "s#.*/##;s/$component.$tBEGf-$tENDf.//"`
EOF
            }
            else {
                $forloop .= <<EOF;
  foreach var ( $variables )
    set file = $reqpath/$component.$tBEGf-$tENDf.\$var
EOF
            }

            $csh .= <<EOF;

$forloop
    if ( $chunkyear == 0 ) then
      $time_cp $cp \$file .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp \$file .
         $checktransfer
      endif
    endif
    set file = "./\$file:t"
    set string = `ncdump -h \$file | grep UNLIMITED`
    $check_ncdump
    set timename   = `echo \$string[1]`
    $time_ncks ncks \$ncksopt -d \$timename,$startmonth,$endmonth \$file year.nc > ncks.out
    $check_ncks
    $time_timavg \$TIMAVG -o \$tempCache/$component.$tYEARf.\$var year.nc
    $retry_timavg
       $time_timavg \$TIMAVG -o \$tempCache/$component.$tYEARf.\$var year.nc
    $check_timavg
    $time_rm rm -f year.nc
    $catfiles
  end
  $makecpio
  else
    echo ERROR: Error: input files do not exist
  endif

EOF

        } ## end foreach my $chunkyear ( 0 .....)
        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);
        return $csh;
    } ## end sub annualTS

    #TIMESERIES - SEASONAL
    sub seasonalTS {

        #tsNode = $_[0] ;
        my $sim0    = $_[1];
        my $ppcNode = $_[0]->parentNode;
        my $freq    = 'seasonal';
        my $source = 'monthly';    #always use monthly, don't need $tsNode->findvalue('@source');
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $outdirpath  = "$component/ts/$freq/$chunkLength";
        my $outdir      = "$ppRootDir/$outdirpath";

        #check if need to convert cube sphere grid to lat lon
        if ( "$sourceGrid" eq 'cubedsphere' ) {
            print STDERR
                "WARNING: Calculating seasonal timeseries from cubed sphere data is not supported in this version of frepp.  Skipping.  To avoid this error message, edit your xml to remove the request for seasonal timeseries for cubed sphere components.\n";
            mailuser(
                "WARNING: Calculating seasonal timeseries from cubed sphere data is not supported in this version of frepp.  Skipping.  To avoid this error message, edit your xml to remove the request for seasonal timeseries for cubed sphere components."
            );
            return "";
        }

        if ( "$chunkLength" eq "" ) {
            mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
            print STDERR
                "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
            return "";
        }

        #need timeSeries freq=monthly chunkLength=something.  Then split apart into yearly data.
        my $requiredts    = "timeSeries[\@freq='monthly']\n";
        my $TSchunkLength = "";
        foreach my $node ( $ppcNode->findnodes("$requiredts") ) {
            $TSchunkLength = $node->findvalue('@chunkLength');
            if ( "$TSchunkLength" ne "" ) {
                print STDERR "will use monthly_ts cl=$TSchunkLength\n" if $opt_v;
                last;
            }
        }
        my $reqpath = "$component/ts/monthly/$TSchunkLength";
        if ( "$TSchunkLength" eq "" ) {
            my @existing = <$ppRootDir/$reqpath/*/*>;
            if ( scalar(@existing) eq 0 ) {
                mailuser(
                    "Cannot create $component $freq timeSeries unless you generate <timeSeries freq='monthly' chunkLength='Xyr'>"
                );
                print STDERR
                    "\nERROR: Cannot create $component $freq timeSeries unless you generate <timeSeries freq='monthly' chunkLength='Xyr'>\n";
                return "";
            }
            else {
                my @reqfiles = <$ppRootDir/$reqpath/*>;
                chomp( $TSchunkLength = `ls -1 $ppRootDir/$reqpath | sort -g | head -1` );
                $TSchunkLength =~ s/$ppRootDir\/$reqpath//;
                $TSchunkLength =~ s/\///g;
                print STDERR
                    "$component $freq timeSeries calculation found data at ts/monthly/$TSchunkLength\n"
                    if $opt_v;
            }
            $reqpath = "$component/ts/monthly/$TSchunkLength";
        } ## end if ( "$TSchunkLength" ...)
        if ($opt_v) { print "      TSchunkLength is $TSchunkLength\n"; }
        my $tmp = FREUtil::modifydate( $tEND, "+1 sec" );
        my $yrsSoFar = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $int = $TSchunkLength;
        $int =~ s/yr//;
        my $cl = $chunkLength;
        $cl =~ s/yr//;
        my $lcmchunk = lcm( $int, $cl );
        my $mod = $yrsSoFar % $lcmchunk;
        if ( $mod != 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $cl > $maxyrs ) { $maxyrs = $cl; }

        #check that all files up to current time exist
        my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
        my $diag_source = "";
        if ( scalar @monthnodes ) {
            my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        #set dates
        my $tENDprev = FREUtil::modifydate( $tEND,     "- $lcmchunk years" );
        my $tBEG     = FREUtil::modifydate( $tENDprev, "+ 1 sec" );
        my $tBEGf     = FREUtil::graindate( $tBEG,     'monthly' );
        my $tENDf     = FREUtil::graindate( $tEND,     'monthly' );
        my $tENDprevf = FREUtil::graindate( $tENDprev, 'monthly' );
        my $prevyear  = FREUtil::graindate( $tENDprev, 'year' );

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        my $forloop   = "";
        if ( "$variables" eq "" ) {
            $forloop = <<EOF;
  foreach file ( \$tempCache/$reqpath/$component.$tBEGf-$tENDf.*.nc )
    set var = `echo \$file | sed "s#.*/##;s/$component.$tBEGf-$tENDf.//"`
EOF
        }
        else {
            print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
            $variables =~ s/ /.nc /g;
            if ( "$variables" ne "" ) { $variables =~ s/$/.nc/g }
            $forloop .= <<EOF;
  foreach var ( $variables )
    set file = \$tempCache/$reqpath/$component.$tBEGf-$tENDf.\$var
EOF
        }

        my $check_ncks        = errorstr("NCKS ($component seasonal ts)");
        my $check_ncdump      = errorstr("NCDUMP ($component seasonal ts)");
        my $check_ncrcat      = errorstr("NCRCAT ($component seasonal ts)");
        my $check_timavg      = retryonerrorend("TIMAVG ($component seasonal ts)");
        my $retry_timavg      = retryonerrorstart("TIMAVG");
        my $check_ncatted     = errorstr("NCATTED ($component seasonal ts)");
        my $check_dmget       = errorstr("DMGET ($component seasonal ts)");
        my $check_splitncvars = errorstr("SPLITNCVARS ($component seasonal ts)");
        my $check_cpio        = errorstr("CPIO/TAR ($component seasonal ts)");
        my $check_nccopy      = errorstr("NCCOPY ($component seasonal ts)");
        my $csh               = setcheckpt("seasonalTS_$chunkLength");
        $csh .= <<EOF;

#####################################
echo 'timeSeries ($component seasonal from monthly ts )'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath
#$time_dmget dmget -d $reqpath "$component.$tBEGf-$tENDf.*.nc"
EOF
        if ($opt_z) { $csh .= begin_systime(); }
        my $totalseasons = 4 * $lcmchunk;
        my $startseason  = 1;
        my $startflag    = FREUtil::dateCmp( $tBEG, $sim0 );

        foreach my $season ( $startseason .. $totalseasons ) {
            my $nummonths = $season * 3 - 4;
            my $tSEASON   = FREUtil::modifydate( $tBEG, "+ $nummonths months" );
            my $tSEASONf  = FREUtil::graindate( $tSEASON, 'seasonal' );
            my ($year)    = $tSEASONf =~ /(\d{4,})\./;
            my $catfiles  = "";
            my $makecpio  = "";
            my $tmp       = FREUtil::graindate( $sim0, 'annual' );

            #if it is time, chunk the files.  only put chunked files into archive now.
            if ( ( $year - $tmp + 1 ) % $cl == 0 ) {
                $tmp = $year - $tmp + 1;
                my ($abbrev)       = $tSEASONf =~ /\d{4,}\.(\w{3})/;
                my $begin          = FREUtil::padzeros( $year - $cl + 1 );
                my $chunkedoutfile = "$component.$begin-$year.$abbrev.\$var";
                my $filelist       = "";
                foreach my $year ( $begin .. $year ) {
                    $year = FREUtil::padzeros($year);
                    $filelist .= "$component.$year.$abbrev.\$var ";
                }
                if ( $abbrev =~ "SON" and $aggregateTS ) {
                    $makecpio = createcpio( "\$tempCache/$outdirpath", $outdir,
                        "$component.$begin-$year", FREUtil::timeabbrev($freq), 1 );
                }
                my $compress = compress_csh( $chunkedoutfile, $check_nccopy );
                $catfiles = <<EOF;
if ( -e $chunkedoutfile ) rm -f $chunkedoutfile
$time_ncrcat ncrcat \$ncrcatopt $filelist $chunkedoutfile
$check_ncrcat
$compress
$time_mv $mvfile $chunkedoutfile \$outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $chunkedoutfile \$outdir/
   $checktransfer
endif
$time_mv $mv $chunkedoutfile \$tempCache/$outdirpath/
$time_rm rm -f $filelist

EOF
            } ## end if ( ( $year - $tmp + ...))
            if ( $season == 1 ) {
                if ( $startflag == 0 ) {
########################## FIRST DJF OF RUN ################################
                    $csh .= <<EOF;
  #season $season ($tSEASONf) note: december used twice
$forloop
    if ( ! -f \$file ) then
      if ( -f $ppRootDir/$reqpath/\$file:t ) then
         $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
         if ( \$status ) then
            echo "WARNING: data transfer failure, retrying..."
            $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
            $checktransfer
         endif
      else
         echo ERROR: necessary file not found: $ppRootDir/$reqpath/\$file:t
      endif
    endif
    set string = `ncdump -h \$file | grep UNLIMITED`
    set timename   = `echo \$string[1]`
    $time_ncks ncks \$ncksopt -d \$timename,1,2 -d \$timename,12,12 \$file janfeb.nc > ncks.out
    $check_ncks
    $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var janfeb.nc
    $retry_timavg
       $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var janfeb.nc
    $check_timavg
    $time_rm rm -f janfeb.nc
    $catfiles
  end

EOF
                } ## end if ( $startflag == 0 )
                else {
########################## FIRST DJF OF THIS PP ################################
                    my $check_prev = errorstr("Could not acquire previous december");
                    my $check_hist
                        = errorstr("Could not acquire previous december from history file");
                    $csh .= <<EOF;
  #season $season ($tSEASONf)
#$time_dmget dmget -d $reqpath "$component.*-$tENDprevf.*.nc"
$forloop
    if ( ! -f \$file ) then
      if ( -f $ppRootDir/$reqpath/\$file:t ) then
         $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
         if ( \$status ) then
            echo "WARNING: data transfer failure, retrying..."
            $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
            $checktransfer
         endif
      else
         echo ERROR: necessary file not found: $ppRootDir/$reqpath/\$file:t
      endif
    endif
    set string = `ncdump -h \$file | grep UNLIMITED`
    set timename   = `echo \$string[1]`
    $time_ncks ncks \$ncksopt -d \$timename,1,2 \$file janfeb.nc > ncks.out
    $check_ncks
    #get december from previous file
    set prev = (`ls ./$component.*-$tENDprevf.\$var`)
    if ( "\$prev" == "" ) then
      set prev = (`ls $ppRootDir/$reqpath/$component.*-$tENDprevf.\$var`)
      $time_cp $cp \$prev .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp \$prev .
         $checktransfer
      endif
      set prev = "./\$prev:t"
    endif
    if ( "\$prev" == "" && -e "$ppRootDir/$reqpath/$component.*-$tENDprevf.mon.nc.cpio") then
      $time_dmget dmget -d $ppRootDir/$reqpath "$component.*-$tENDprevf.mon.nc.cpio"
      $time_cp $cp $ppRootDir/$reqpath/$component.*-$tENDprevf.mon.nc.cpio .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $ppRootDir/$reqpath/$component.*-$tENDprevf.mon.nc.cpio .
         $checktransfer
      endif
      $time_uncpio $uncpio -ivI $component.*-$tENDprevf.mon.nc.cpio '*12.*.nc'
      $time_dmput dmput $reqpath "$component.*-$tENDprevf.mon.nc.cpio"
      set prev = (`ls ./$component.*-$tENDprevf.\$var`)
    endif
    if ( "\$prev" != "" ) then
       set decstring = `ncdump -h \$prev | grep UNLIMITED`
       $check_ncdump
       @ len = \$#decstring - 1
       set length = `echo \$decstring[\$len] | cut -c2-`
       $time_ncks ncks \$ncksopt -d \$timename,\$length,\$length \$prev dec.nc > ncks.out
       $check_ncks
EOF

                    #might need to get the data from the history file if previous pp is not done
                    my $convertDec = convertSegments( $segTime, $segUnits, $diag_source, 'dec' );

                    #check for zInterp
                    my $zInterp     = $ppcNode->findvalue('@zInterp');
                    my $zInterp_csh = "";
                    if ( "$zInterp" ne "" ) {
                        $zInterp_csh = zInterpolate( $zInterp, "\${prevyear}1201.$diag_source.nc",
                            'tmp.nc', $caltype, $variables, $diag_source );
                        $zInterp_csh .= "\nmv -f tmp.nc \${prevyear}1201.$diag_source.nc";
                    }

                    my $prevhistcpio = "$prevyear" . "0101.nc.cpio";
                    my $prevhisttar  = "$prevyear" . "0101.nc.tar";
                    $csh .= <<EOF;
    else
       if ( ! -e \$var ) then
            set prevyear = $prevyear
            if ( ! -e \${prevyear}1201.$diag_source.nc ) then
               if ( -e $opt_d/$prevhistcpio ) then
                  $time_dmget dmget "$opt_d/$prevhistcpio"
                  $time_uncpio $uncpio -ivI $opt_d/$prevhistcpio '*.$diag_source.nc'
                  $check_cpio
                  $time_dmput dmput "$opt_d/$prevhistcpio"
               else if ( -e $opt_d/$prevhisttar ) then
                  $time_dmget dmget "$opt_d/$prevhisttar"
                  $time_untar tar -xvf $opt_d/$prevhisttar --wildcards '*.$diag_source.nc'
                  $check_cpio
                  $time_dmput dmput "$opt_d/$prevhisttar"
               else
                  echo ERROR: Previous December (\${prevyear}1201.$diag_source.nc) is not available for seasonal calculations
                  exit 1
               endif
               set string = `ncdump -h \${prevyear}0101.$diag_source.nc | grep UNLIMITED`
               set timename   = `echo \$string[1]`
               $convertDec
               $zInterp_csh
            endif
            $time_splitncvars \$SPLITNCVARS -v \$var:r \${prevyear}1201.$diag_source.nc
            $check_splitncvars
       endif
       test -e \$var
       $check_hist
       $time_mv $mv \$var dec.nc
    endif
    test -e dec.nc
    $check_prev

    if ( -e decjanfeb.nc ) rm -f decjanfeb.nc
    $time_ncrcat ncrcat \$ncrcatopt dec.nc janfeb.nc decjanfeb.nc
    $check_ncrcat
    $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var decjanfeb.nc
    $retry_timavg
       $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var decjanfeb.nc
    $check_timavg
    $time_rm rm -f janfeb.nc dec.nc decjanfeb.nc
    $catfiles
  end

EOF
                } ## end else [ if ( $startflag == 0 )]
            } ## end if ( $season == 1 )
            else {
########################## REMAINING SEASONS ################################
                my $startmonth = $season * 3 - 3;
                my $endmonth   = $season * 3 - 1;
                $csh .= <<EOF;
  #season $season ($tSEASONf)
$forloop
    if ( ! -f \$file ) then
      if ( -f $ppRootDir/$reqpath/\$file:t ) then
         $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
         if ( \$status ) then
            echo "WARNING: data transfer failure, retrying..."
            $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
            $checktransfer
         endif
      else
         echo ERROR: necessary file not found: $ppRootDir/$reqpath/\$file:t
      endif
    endif
    set string = `ncdump -h \$file | grep UNLIMITED`
    set timename   = `echo \$string[1]`
    $time_ncks ncks \$ncksopt -d \$timename,$startmonth,$endmonth \$file season.nc > ncks.out
    $check_ncks
    $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var season.nc
    $retry_timavg
       $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var season.nc
    $check_timavg
    $time_rm rm -f season.nc
    $catfiles
  end
  $makecpio

EOF
            } ## end else [ if ( $season == 1 ) ]
        } ## end foreach my $season ( $startseason...)
        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);
        return $csh;
    } ## end sub seasonalTS

    #TIMEAVERAGES - MONTHLY
    sub monthlyAVfromhist {

        #taNode = $_[0] ;
        my $sim0    = $_[1];
        my $ppcNode = $_[0]->parentNode;

        #check for appropriate segment lengths
        my @reqStartMonths = segStartMonths( $segTime, $segUnits );

        my $src         = 'monthly';
        my $interval    = $_[0]->findvalue('@interval');
        my $outdir      = "$ppRootDir/$component/av/$src" . "_$interval";
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $tmp         = FREUtil::modifydate( $tEND, "+ 1 sec" );
        my $yrsSoFar    = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $int         = $interval;
        $int =~ s/yr//;
        my $mod = $yrsSoFar % $int;
        unless ( $mod == 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $int > $maxyrs ) { $maxyrs = $int; }

        my $hDateyr = $userstartyear;
        my @hDates  = ( FREUtil::padzeros( $hDateyr - $int + 1 ) .. "$hDateyr" );

        my $sim0f = FREUtil::graindate( $sim0, $src );
        my $t0f   = FREUtil::graindate( $t0,   $src );
        my $tENDf = FREUtil::graindate( $tEND, $src );
        my $range = FREUtil::graindate( $tEND, 'year' );
        if ( scalar @hDates > 1 ) { $range = FREUtil::padzeros( $range - $int + 1 ) . "-$range"; }
        foreach my $d (@hDates) { $historyfiles .= "$d" . "0101.nc.tar "; }

        my $diag_source = $_[0]->findvalue('@diag_source');
        my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
        if ( scalar @monthnodes and "$diag_source" eq "" ) {
            my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        $variables =~ s/ /,/g;

        my $zInterp    = $ppcNode->findvalue('@zInterp');
        my $do_zInterp = 0;
        if ( "$zInterp" ne "" ) { $do_zInterp = 1; }
        my $convertSeg = convertSegments( $segTime, $segUnits, $diag_source );
        my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");

        #my $check_cpio = errorstr("CPIO ($component $src $interval averages)");
        my $check_cpio_msg = "CPIO ($component $src $interval averages)";
        my $check_ncrcat   = errorstr("NCRCAT ($component $src $interval averages)");
        my $check_timavg   = retryonerrorend("TIMAVG ($component $src $interval averages)");
        my $retry_timavg   = retryonerrorstart("TIMAVG");
        my $check_plevel   = errorstr("PLEVEL ($component $src $interval averages)");
        my $check_ncdump   = errorstr("NCDUMP ($component $src $interval averages)");
        my $check_fregrid  = errorstr("FREGRID ($component $src $interval averages)");
        my $check_ncrename = errorstr("NCRENAME ($component $src $interval averages)");
        my $check_nccopy   = errorstr("NCCOPY ($component $src $interval averages)");

        my $csh = setcheckpt("monthlyAVfromhist_$interval");
        $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
EOF
        if ($opt_z) { $csh .= begin_systime(); }
        if ( "$sourceGrid" eq 'cubedsphere' ) {    #IF CUBIC
            my $tile = '.tile$i';

            $csh .= <<EOF;
   foreach hDate ( @hDates )
      foreach sourcefile ( `ls \$histDir/\$hDate*/*.$diag_source.tile*nc`)
        ln -s \$sourcefile .
      end
      foreach file ( `ls \$histDir/\$hDate*/*.grid_spec.tile*.nc`)
        ln -s \$file .
      end
   end
   foreach hDate ( @hDates )
   $convertSeg
   end

if ( "$variables" != '' ) then
    set static_vars = (`\$NCVARS -s0123 \$sourcefile`)
    set static_vars = `echo \$static_vars |sed 's/ /,/g'`
    set avg_vars = (average_T1,average_T2,average_DT,time_bnds)
    set vars = ("$variables","\$static_vars","\$avg_vars")
    unset static_vars avg_vars
endif
set month = 1
while (\$month <= 12)
set i = 1
while ( \$i <= 6 )

   set monthf = `echo \$month | sed 's/.*/0&/;s/.\\(..\\)/\\1/'`
   set histmonth = "\$monthf"

   if ( "$variables" != '' ) then
      $time_ncrcat ncrcat \$ncrcatopt -v \$vars *\${histmonth}01.$diag_source$tile.nc month.nc
   else
      $time_ncrcat ncrcat \$ncrcatopt *\${histmonth}01.$diag_source$tile.nc month.nc
   endif
   $check_ncrcat
   $time_rm rm -f *\${histmonth}01.$diag_source$tile.nc
EOF

            if ($do_zInterp) {
                $csh .= <<EOF;
      $time_timavg \$TIMAVG -o modellevels.nc month.nc
      $retry_timavg
         $time_timavg \$TIMAVG -o modellevels.nc month.nc
      $check_timavg
      $time_rm rm -f month.nc
EOF
                $csh
                    .= zInterpolate( $zInterp, 'modellevels.nc',
                    "$hDates[0]\${histmonth}01.$diag_source$tile.nc",
                    $caltype, $variables, $diag_source );

            }
            else {    #no zinterp
                $csh .= <<EOF;
      $time_timavg \$TIMAVG -o $hDates[0]\${histmonth}01.$diag_source$tile.nc month.nc
      $retry_timavg
         $time_timavg \$TIMAVG -o $hDates[0]\${histmonth}01.$diag_source$tile.nc month.nc
      $check_timavg
      $time_rm rm -f month.nc
EOF
            }

            if ( "$xyInterp" ne '' ) {    #CUBIC to LATLON

                my $fregrid_wt = '';
                if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                    print
                        "       land_frac found, weighting exchange grid cell with $hDates[0]\${histmonth}01.land_static\n"
                        if $opt_v;
                    $fregrid_wt
                        = "--weight_file $hDates[0]\${histmonth}01.land_static --weight_field land_frac";
                }
                my $call_and_check_fregrid = $call_tile_fregrid;
                $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                my $compress = compress_csh( "$component.$range.\$monthf.nc", $check_nccopy );
                $csh .= <<EOF;
@ i ++
end

   set fregrid_wt = "$fregrid_wt"
   set fregrid_in_date = $hDates[0]\${histmonth}01
   set fregrid_in = $hDates[0]\${histmonth}01.$diag_source
   set nlat = $nlat ; set nlon = $nlon
   set interp_method = $interpMethod
   set interp_options = "$xyInterpOptions"
   set ncvars_arg = -st0123
   set variables = ( $variables )
   set fregrid_remap_file = $xyInterpRegridFile
   set source_grid = $sourceGrid
   $call_and_check_fregrid

   mv \$fregrid_in.nc $component.$range.\$monthf.nc
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$range.\$monthf.nc" $component.$range.\$monthf.nc
   $check_ncatted

   $compress

   $time_mv $mvfile $component.$range.\$monthf.nc \$outdir/$component.$range.\$monthf.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile $component.$range.\$monthf.nc \$outdir/$component.$range.\$monthf.nc
      $checktransfer
   endif
   $time_rm rm $component.$range.\$monthf.nc
   $time_dmput dmput \$outdir/$component.$range.\$monthf.nc

EOF

            } ## end if ( "$xyInterp" ne '')
            else {    #CUBIC - no conversion
                my $compress = compress_csh( "$component.$range.\$monthf$tile.nc", $check_nccopy );
                $csh .= <<EOF;
   mv $hDates[0]\${histmonth}01.$diag_source$tile.nc $component.$range.\$monthf$tile.nc
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$range.\$monthf$tile.nc" $component.$range.\$monthf$tile.nc
   $check_ncatted
   $compress
   $time_mv $mvfile $component.$range.\$monthf$tile.nc \$outdir/$component.$range.\$monthf$tile.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile $component.$range.\$monthf$tile.nc \$outdir/$component.$range.\$monthf$tile.nc
      $checktransfer
   endif
   $time_rm rm $component.$range.\$monthf$tile.nc
   $time_dmput dmput \$outdir/$component.$range.\$monthf$tile.nc
   @ i++
end
EOF
            }

            $csh .= <<EOF;
   @ month++
end

EOF

        } ## end if ( "$sourceGrid" eq ...)
        else {    #IF NOT CUBIC

            $csh .= <<EOF;
foreach hDate ( @hDates )
   foreach file ( `ls \$histDir/\$hDate*/*.$diag_source.nc`)
     ln -s \$file .
   end
   $convertSeg
end
if ( "$variables" != '' ) then
    set static_vars = (`\$NCVARS -s0123 \$file`)
    set static_vars = `echo \$static_vars |sed 's/ /,/g'`
    set avg_vars = (average_T1,average_T2,average_DT,time_bnds)
    set vars = ("$variables","\$static_vars","\$avg_vars")
    unset static_vars avg_vars
endif

set month = 1
while (\$month <= 12)
   set monthf = `echo \$month | sed 's/.*/0&/;s/.\\(..\\)/\\1/'`
   set histmonth = "\$monthf"

   if ( -e month.nc ) rm -f month.nc
   if ( "$variables" != '' ) then
      $time_ncrcat ncrcat \$ncrcatopt -v \$vars *\${histmonth}01.$diag_source.nc month.nc
   else
      $time_ncrcat ncrcat \$ncrcatopt *\${histmonth}01.$diag_source.nc month.nc
   endif
   $check_ncrcat
   $time_rm rm -f *\${histmonth}01.$diag_source.nc
EOF

            if ($do_zInterp) {
                $csh .= <<EOF;
   $time_timavg \$TIMAVG -o modellevels.nc month.nc
   $retry_timavg
      $time_timavg \$TIMAVG -o modellevels.nc month.nc
   $check_timavg
EOF
                $csh .= zInterpolate( $zInterp, 'modellevels.nc', "$component.$range.\$monthf.nc",
                    $caltype, $variables, $component );
            }
            else {
                $csh .= <<EOF;
   $time_timavg \$TIMAVG -o $component.$range.\$monthf.nc month.nc
   $retry_timavg
      $time_timavg \$TIMAVG -o $component.$range.\$monthf.nc month.nc
   $check_timavg
EOF
            }

            # convert latlon/tripolar to latlon
            if ( "$xyInterp" ne '' ) {
                my $fregrid_wt = '';
                if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                    print
                        "       land_frac found, weighting exchange grid cell with $hDates[0]\${histmonth}01.land_static\n"
                        if $opt_v;
                    $fregrid_wt
                        = "--weight_file $hDates[0]\${histmonth}01.land_static --weight_field land_frac";
                }
                my $call_and_check_fregrid = $call_fregrid;
                $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDates[0]\${histmonth}01
    set fregrid_in = "$component.$range.\$monthf"
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st0123
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid
    mv \$fregrid_in.nc $component.$range.\$monthf.nc

EOF
            } ## end if ( "$xyInterp" ne '')

            my $compress = compress_csh( "$component.$range.\$monthf.nc", $check_nccopy );

            $csh .= <<EOF;
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$range.\$monthf.nc" $component.$range.\$monthf.nc
   $check_ncatted
   $compress
   $time_mv $mvfile $component.$range.\$monthf.nc \$outdir/$component.$range.\$monthf.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile $component.$range.\$monthf.nc \$outdir/$component.$range.\$monthf.nc
      $checktransfer
   endif
   $time_rm rm $component.$range.\$monthf.nc
   $time_dmput dmput \$outdir/$component.$range.\$monthf.nc

   $time_rm rm -f month.nc
   @ month++
end

EOF
        } ## end else [ if ( "$sourceGrid" eq ...)]

        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);

        return $csh;
    } ## end sub monthlyAVfromhist

    #TIMEAVERAGES - ANNUAL 1YR
    sub annualAV1yrfromhist {

        #taNode = $_[0] ;
        my $sim0       = $_[1];
        my $write2arch = $_[2];
        my $yr2do      = $_[3];

        #check for appropriate segment lengths
        my @reqStartMonths = segStartMonths( $segTime, $segUnits );

        my $ppcNode     = $_[0]->parentNode;
        my $src         = 'annual';
        my $interval    = $_[0]->findvalue('@interval');
        my $chunkLength = $_[0]->findvalue('@chunkLength');

        if ( "$yr2do" eq '' ) { $yr2do = $hDate; }
        my $yr2do0   = FREUtil::parseDate($yr2do);
        my $sim0f    = FREUtil::graindate( $sim0, $src );
        my $t0f      = FREUtil::graindate( $yr2do0, $src );
        my $yr2doEND = FREUtil::modifydate( $yr2do0, '+1 year -1 sec' );
        my $tENDf    = FREUtil::graindate( $yr2doEND, $src );
        if ( "$yr2do" eq "00010101" ) { $tENDf = "0001" }

        #print "annualAV1yrfromhist yr2do $yr2do yr2do0 $yr2do0 yr2doEND $yr2doEND tENDf $tENDf\n";
        my ($hDateyr) = FREUtil::splitDate($yr2do);

        my $diag_source = $_[0]->findvalue('@diagSource');
        my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
        if ( scalar @monthnodes and "$diag_source" eq "" ) {
            my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        $historyfiles .= "$yr2do" . ".nc.tar ";
        my $interval   = "1yr";
        my $outdirpath = "$component/av/$src" . "_$interval";
        my $outdir     = "$ppRootDir/$outdirpath";

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        $variables =~ s/ /,/g;

        if ( 1 > $maxyrs ) { $maxyrs = 1; }
        my $zInterp    = $ppcNode->findvalue('@zInterp');
        my $do_zInterp = 0;
        if ( "$zInterp" ne "" ) { $do_zInterp = 1; }
        my $check_cpio     = errorstr("CPIO ($component $src averages)");
        my $check_ncrcat   = errorstr("NCRCAT ($component $src averages)");
        my $check_timavg   = retryonerrorend("TIMAVG ($component $src averages)");
        my $retry_timavg   = retryonerrorstart("TIMAVG");
        my $check_ncatted  = errorstr("NCATTED ($component $src averages)");
        my $check_plevel   = errorstr("PLEVEL ($component $src averages)");
        my $check_ncdump   = errorstr("NCDUMP ($component $src averages)");
        my $check_fregrid  = errorstr("FREGRID ($component $src averages)");
        my $check_ncrename = errorstr("NCRENAME ($component $src averages)");
        my $check_nccopy   = errorstr("NCCOPY ($component $src averages)");
        my $csh            = setcheckpt('annualAV1yrfromhist');
        if ( "$write2arch" eq "1" ) {
            $csh          .= "set write2arch = 1\n";
            $mkdircommand .= "$outdir ";
        }
        else {
            $csh .= "set write2arch = 0\n";
        }
        $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src averages)'
set outdir = $outdir
if ( ! -e \$outdir && \$write2arch ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
EOF
        if ($opt_z) { $csh .= begin_systime(); }

        if ( "$sourceGrid" eq "cubedsphere" ) {    #IF CUBIC
            my $tile = '.tile$i';
            $csh .= <<EOF;
foreach sourcefile ( `ls \$histDir/$hDateyr*/*.$diag_source.tile*nc`)
  ln -s \$sourcefile .
end
foreach file ( `ls \$histDir/$hDateyr*/*.grid_spec.tile*.nc`)
  ln -s \$file .
end
set i = 1
while ( \$i <= 6 )
if ( "$variables" != '' ) then
   set static_vars = (`\$NCVARS -s0123 \$sourcefile`)
   set static_vars = `echo \$static_vars |sed 's/ /,/g'`
   set avg_vars = (average_T1,average_T2,average_DT,time_bnds)
   set vars = ("$variables","\$static_vars","\$avg_vars")
   $time_ncrcat ncrcat \$ncrcatopt -v \$vars *.$diag_source$tile.nc annual$tile.nc
   unset static_vars avg_vars vars
else
   $time_ncrcat ncrcat \$ncrcatopt *.$diag_source$tile.nc annual$tile.nc
endif
$check_ncrcat
$time_rm rm -f *.$diag_source$tile.nc
EOF

            if ($do_zInterp) {
                $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels$tile.nc annual$tile.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels$tile.nc annual$tile.nc
$check_timavg

EOF
                $csh .= zInterpolate( $zInterp, "modellevels$tile.nc",
                    "$yr2do.$diag_source$tile.nc", $caltype, $variables, $diag_source );

            }
            else {
                $csh .= <<EOF;
$time_timavg \$TIMAVG -o $yr2do.$diag_source$tile.nc annual$tile.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $yr2do.$diag_source$tile.nc annual$tile.nc
$check_timavg
$time_rm rm -f annual$tile.nc

EOF
            }

            if ( "$xyInterp" ne '' ) {    #CUBIC to LATLON

                my $fregrid_wt = '';
                if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                    print
                        "       land_frac found, weighting exchange grid cell with $yr2do.land_static\n"
                        if $opt_v;
                    $fregrid_wt = "--weight_file $yr2do.land_static --weight_field land_frac";
                }
                my $call_and_check_fregrid = $call_tile_fregrid;
                $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                my $compress = compress_csh( "\$tempCache/$outdirpath/$component.$tENDf.ann.nc",
                    $check_nccopy );
                $csh .= <<EOF;
@ i ++
end

    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $yr2do
    set fregrid_in = $yr2do.$diag_source
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st0123
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid

mv \$fregrid_in.nc $component.$tENDf.ann.nc
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$tENDf.ann.nc" $component.$tENDf.ann.nc
$check_ncatted

$time_mv $mv $component.$tENDf.ann.nc \$tempCache/$outdirpath/$component.$tENDf.ann.nc
if ( \$write2arch ) then
   $compress
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann.nc \$outdir/$component.$tENDf.ann.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann.nc \$outdir/$component.$tENDf.ann.nc
      $checktransfer
   endif
endif

EOF

            } ## end if ( "$xyInterp" ne '')
            else {    #CUBIC - no conversion
                my $compress
                    = compress_csh( "\$tempCache/$outdirpath/$component.$tENDf.ann$tile.nc",
                    $check_nccopy );
                $csh .= <<EOF;
mv $yr2do.$diag_source$tile.nc $component.$tENDf.ann$tile.nc
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$tENDf.ann$tile.nc" $component.$tENDf.ann$tile.nc
$check_ncatted

$time_mv $mv $component.$tENDf.ann$tile.nc \$tempCache/$outdirpath/$component.$tENDf.ann$tile.nc
if ( \$write2arch ) then
   $compress
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann$tile.nc \$outdir/$component.$tENDf.ann$tile.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann$tile.nc \$outdir/$component.$tENDf.ann$tile.nc
      $checktransfer
   endif
endif

@ i ++
end
EOF

            } ## end else [ if ( "$xyInterp" ne '')]

        } ## end if ( "$sourceGrid" eq ...)
        else {    #NOT CUBIC

            $csh .= <<EOF;
foreach file ( `ls \$histDir/$hDateyr*/*.$diag_source.nc`)
  ln -s \$file .
end
if ( -e annual.nc ) rm -f annual.nc
if ( "$variables" != '' ) then
   set static_vars = (`\$NCVARS -s0123 \$file`)
   set static_vars = `echo \$static_vars |sed 's/ /,/g'`
   set avg_vars = (average_T1,average_T2,average_DT,time_bnds)
   set vars = ("$variables","\$static_vars","\$avg_vars")
   $time_ncrcat ncrcat \$ncrcatopt -v \$vars *.$diag_source.nc annual.nc
   unset static_vars avg_vars vars
else
   $time_ncrcat ncrcat \$ncrcatopt *.$diag_source.nc annual.nc
endif
$check_ncrcat
$time_rm rm -f *.$diag_source.nc
EOF

            if ($do_zInterp) {
                $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels.nc annual.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels.nc annual.nc
$check_timavg

EOF
                $csh .= zInterpolate( $zInterp, 'modellevels.nc', "$component.$tENDf.ann.nc",
                    $caltype, $variables, $component );

            }
            else {
                $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$tENDf.ann.nc annual.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$tENDf.ann.nc annual.nc
$check_timavg

EOF
            }

            # convert latlon/tripolar to latlon
            if ( "$xyInterp" ne '' ) {
                my $fregrid_wt = '';
                if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                    print
                        "       land_frac found, weighting exchange grid cell with $yr2do.land_static\n"
                        if $opt_v;
                    $fregrid_wt = "--weight_file $yr2do.land_static --weight_field land_frac";
                }
                my $call_and_check_fregrid = $call_fregrid;
                $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $yr2do
    set fregrid_in = annual
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st0123
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid
    mv \$fregrid_in.nc $component.$tENDf.ann.nc

EOF
            } ## end if ( "$xyInterp" ne '')

            my $compress
                = compress_csh( "\$tempCache/$outdirpath/$component.$tENDf.ann.nc", $check_nccopy );

            $csh .= <<EOF;
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$tENDf.ann.nc" $component.$tENDf.ann.nc
$check_ncatted
$time_mv $mv $component.$tENDf.ann.nc \$tempCache/$outdirpath/$component.$tENDf.ann.nc
if ( \$write2arch ) then
   $compress
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann.nc \$outdir/$component.$tENDf.ann.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann.nc \$outdir/$component.$tENDf.ann.nc
      $checktransfer
   endif
endif
$time_rm rm -f annual.nc

EOF

        } ## end else [ if ( "$sourceGrid" eq ...)]
        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);
        return $csh;
    } ## end sub annualAV1yrfromhist

    #TIMEAVERAGES - ANNUAL XYR
    sub annualAVxyrfromann {

        #taNode = $_[0] ;
        my $sim0            = $_[1];
        my $ppcNode         = $_[2];
        my $annavnodes      = $_[3];
        my $annCalcInterval = $_[4];

        my $src         = 'annual';
        my $interval    = $_[0]->findvalue('@interval');
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $sim0f       = FREUtil::graindate( $sim0, $src );
        my $t0f         = FREUtil::graindate( $t0, $src );
        my $tENDf       = FREUtil::graindate( $tEND, $src );
        my $outdirpath  = "$component/av/$src" . "_$interval";
        my $outdir      = "$ppRootDir/$outdirpath";
        my $tmp         = FREUtil::modifydate( $tEND, "+ 1 sec" );
        my $yrsSoFar    = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $int         = $interval;
        $int =~ s/yr//;
        my $mod = $yrsSoFar % $int;
        unless ( $mod == 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $int > $maxyrs ) { $maxyrs = $int; }
        my $first = FREUtil::padzeros( $t0f - $int + 1 );

        #check for missing files
        my $diag_source = $_[0]->findvalue('@diagSource');
        my @monthnodes  = $_[0]->parentNode->findnodes('timeSeries[@freq="monthly"]');
        if ( scalar @monthnodes and "$diag_source" eq "" ) {
            my $monthnode
                = $_[0]->parentNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        my $csh = '';

        #always do 1yr ann av calculation, but only archive if annCalcInterval not 1yr
        if ( "$annCalcInterval" ne "1yr" and not $annavnodes ) { $annavnodes = 0; }
        my $newnode = XML::LibXML::Element->new('timeAverage');
        $newnode->setAttribute( 'source',   'annual' );
        $newnode->setAttribute( 'interval', '1yr' );
        $ppcNode->appendChild($newnode);
        my $annNode
            = $ppcNode->findnodes('timeAverage[@source="annual" and @interval="1yr"]')->get_node(1);
        foreach my $i ( 0 .. ( $int - 1 ) ) {
            my $annyr = $userstartyear;
            $annyr -= $i;
            $annyr = FREUtil::padzeros($annyr) . "0101";

           #print "\nNOTE: Calling annualAV1yrfromhist( $annNode, $sim0, $annavnodes, $annyr )\n\n";
            $csh .= annualAV1yrfromhist( $annNode, $sim0, $annavnodes, $annyr );
            last if "$annCalcInterval" eq "1yr";
        }

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        $variables =~ s/ /,/g;

        $csh .= setcheckpt("annualAVxyrfromann_$interval");
        $csh .= <<EOF;

#####################################
echo 'timeAverage ($component $src $interval averages)'
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$component/av/annual_1yr ) mkdir -p \$tempCache/$component/av/annual_1yr
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath
set anndir = $ppRootDir/$component/av/annual_1yr
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
cd \$tempCache/$component/av/annual_1yr
EOF
        if ($opt_z) { $csh .= begin_systime(); }

        my $endinterval = FREUtil::padzeros( $first + $int - 1 );
        until ( $endinterval > $tENDf ) {

            #print "in tA, endinterval($endinterval) tENDf($tENDf)\n";
            my $filelist = "";
            my $getlist  = "";
            foreach my $year ( $first .. $endinterval ) {
                $year = FREUtil::padzeros($year);
                if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {    # CUBIC
                    foreach my $i ( 1 .. 6 ) {
                        $filelist .= "\$anndir/$component.$year.ann.tile$i.nc ";
                        $getlist  .= "$component.$year.ann.tile$i.nc ";
                    }
                }
                else {                                                           # LATLON
                    $filelist .= "\$anndir/$component.$year.ann.nc ";
                    $getlist  .= "$component.$year.ann.nc ";
                }
            }
            my $first_file    = (split ' ', $getlist)[0];
            my $check_ncrcat  = errorstr("NCRCAT ($component $src $interval averages)");
            my $check_timavg  = retryonerrorend("TIMAVG ($component $src $interval averages)");
            my $retry_timavg  = retryonerrorstart("TIMAVG");
            my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
            my $check_dmget   = errorstr("DMGET ($component $src $interval averages)");
            my $check_nccopy  = errorstr("NCCOPY ($component $src $interval averages)");

            if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {    # CUBIC
                my $tile = '.tile$i';
                my $compress
                    = compress_csh(
                    "\$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc",
                    $check_nccopy );
                $csh .= <<EOF;
foreach file ($filelist)
   set f = \$file:t
   if ( ! -f \$f ) then
      $time_cp $cp \$file .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp \$file .
         $checktransfer
      endif
   endif
end
set i = 1
while ( \$i <= 6 )
   if ( -e xyears.nc ) rm -f xyears.nc
   set filelist = ""
   foreach file ($getlist)
      if (\$file =~ \*$tile\*) set filelist = ( \$filelist \$file )
   end
   if ( "$variables" != '' ) then
      set static_vars = (`\$NCVARS -s0123 \$file`)
      set static_vars = `echo \$static_vars |sed 's/ /,/g'`
      set avg_vars = (average_T1,average_T2,average_DT,time_bnds)
      set vars = ("$variables","\$static_vars","\$avg_vars")
      $time_ncrcat ncrcat \$ncrcatopt -v \$vars \$filelist \$work/xyears.nc
      unset static_vars avg_vars vars
   else
      $time_ncrcat ncrcat \$ncrcatopt \$filelist \$work/xyears.nc
   endif
   $check_ncrcat
   $time_timavg \$TIMAVG -o \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc \$work/xyears.nc
   $retry_timavg
     $time_timavg \$TIMAVG -o \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc \$work/xyears.nc
   $check_timavg
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$first-$endinterval.ann$tile.nc" \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc
   $check_ncatted
   $compress
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc \$outdir/$component.$first-$endinterval.ann$tile.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc \$outdir/$component.$first-$endinterval.ann$tile.nc
      $checktransfer
   endif
   $time_rm rm -f xyears.nc
   @ i++
end
EOF

            } ## end if ( "$sourceGrid" eq ...)
            else {    # LATLON
                my $compress
                    = compress_csh( "\$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc",
                    $check_nccopy );
                $csh .= <<EOF;
foreach file ($filelist)
   set f = \$file:t
   if ( ! -f \$f ) then
      $time_cp $cp \$file .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp \$file .
         $checktransfer
      endif
   endif
end
if ( -e xyears.nc ) rm -f xyears.nc
if ( "$variables" != '' ) then
   set static_vars = (`\$NCVARS -s0123 $first_file`)
   set static_vars = `echo \$static_vars |sed 's/ /,/g'`
   set avg_vars = (average_T1,average_T2,average_DT,time_bnds)
   set vars = ("$variables","\$static_vars","\$avg_vars")
   $time_ncrcat ncrcat \$ncrcatopt -v \$vars $getlist \$work/xyears.nc
   unset static_vars avg_vars vars
else
   $time_ncrcat ncrcat \$ncrcatopt $getlist \$work/xyears.nc
endif
$check_ncrcat
$time_timavg \$TIMAVG -o \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc \$work/xyears.nc
$retry_timavg
   $time_timavg \$TIMAVG -o \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc \$work/xyears.nc
$check_timavg
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$first-$endinterval.ann.nc" \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc
$check_ncatted
$compress
$time_mv $mvfile \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc \$outdir/$component.$first-$endinterval.ann.nc
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc \$outdir/$component.$first-$endinterval.ann.nc
   $checktransfer
endif
$time_rm rm -f \$work/xyears.nc
EOF
            } ## end else [ if ( "$sourceGrid" eq ...)]

            $first       = FREUtil::padzeros( $endinterval + 1 );
            $endinterval = FREUtil::padzeros( $first + $int - 1 );
        } ## end until ( $endinterval > $tENDf)
        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);
        return $csh;
    } ## end sub annualAVxyrfromann

    #TIMESERIES - monthly from daily ts
    sub monthlyTSfromdailyTS {

        #tsNode = $_[0] ;
        my $sim0        = $_[1];
        my $startofrun  = $_[2];
        my $ppcNode     = $_[0]->parentNode;
        my $avgatt      = $_[0]->findvalue('@averageOf');
        my $freq        = $_[0]->findvalue('@freq');
        my $t0f         = FREUtil::graindate( $t0, $freq );
        my $tENDf       = FREUtil::graindate( $tEND, $freq );
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        if ( "$chunkLength" eq "" ) {
            print STDERR
                "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
            mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
            return "";
        }
        my $outdir = "$ppRootDir/$component/ts/$freq/$chunkLength";
        $chunkLength =~ s/yr//;
        my $yrsSoFar = &Delta_Format( FREUtil::dateCalc( $sim0, $t0 ), 0, "%yd" );
        my $mod = ( $yrsSoFar + 1 ) % $chunkLength;
        if ( $mod != 0 ) { return ""; }    #don't do any calculations until a chunk is ready to go.
        $mkdircommand .= "$outdir ";
        if ( $chunkLength > $maxyrs ) { $maxyrs = $chunkLength; }
        my $indir    = "$ppRootDir/$component/ts/$avgatt/$chunkLength" . "yr";
        my $hDateyr  = $userstartyear;
        my @hDates   = ( FREUtil::padzeros( $hDateyr - $chunkLength + 1 ) .. "$hDateyr" );
        my $in_start = FREUtil::graindate( FREUtil::modifydate( $tEND, "-$chunkLength yr +1 sec" ),
            $avgatt );
        my $in_end = FREUtil::graindate( $tEND, $avgatt );
        my $out_start
            = FREUtil::graindate( FREUtil::modifydate( $tEND, "-$chunkLength yr +1 sec" ), $freq );
        my $out_end = FREUtil::graindate( $tEND, $freq );
        #
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        if ( "$variables" eq "" ) {
            $variables = $dtvars{"all_$component"};
            $variables =~ s/,/ /g;
        }
        my $dmgetvars = $variables;
        if ( "$variables" ne "" ) {
            print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
            $dmgetvars =~ s/ /.nc \$in./g;
            $dmgetvars =~ s/^/$time_dmget dmget -d $indir \$in./;
            $dmgetvars =~ s/$/.nc/;
        }

        my $numtimelevels = gettimelevels( $freq, $chunkLength );
        my $check_ncrcat  = errorstr("NCRCAT ($component $freq ts calculated from $avgatt ts)");
        my $check_cpio    = errorstr("CPIO ($component $freq ts calculated from $avgatt ts)");
        my $check_dmget   = errorstr("DMGET ($component $freq ts calculated from $avgatt ts)");
        my $check_ncatted = errorstr("NCATTED ($component $freq ts calculated from $avgatt ts)");
        my $check_ncdump  = errorstr("NCDUMP ($component $freq ts calculated from $avgatt ts)");
        my $check_timavg
            = retryonerrorend("TIMAVG ($component $freq ts calculated from $avgatt ts)");
        my $retry_timavg = retryonerrorstart("TIMAVG");
        my $check_ncks   = errorstr("NCKS ($component $freq ts calculated from $avgatt ts)");
        my $check_ncap   = errorstr("NCAP ($component $freq ts calculated from $avgatt ts)");
        my $check_nccopy = errorstr("NCCOPY ($component $freq ts calculated from $avgatt ts)");
        my $check_levels = '';

        if ( "$caltype" eq "NOLEAP" or "$caltype" eq "noleap" ) {
            $check_levels
                = errorstr(
                "WRONG NUMBER OF TIME LEVELS (contains \$length, should be $numtimelevels) IN \$outdir/\$out.\$var.nc"
                );
        }
        my $csh = setcheckpt('monthlyTSfromdailyTS');
        $csh .= <<EOF;
#####################################
echo 'timeSeries ($component $freq calculated from $avgatt TS)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir

EOF
        if ($opt_z) { $csh .= begin_systime(); }
        my $compress = compress_csh( "\$out.\$var.nc", $check_nccopy );
        $csh .= <<EOF;
set in = '$component.$in_start-$in_end'
set out = '$component.$out_start-$out_end'

$dmgetvars
foreach var ( $variables )
   if ( ! -e $indir/\$in.\$var.nc ) then
      $time_dmget dmget $indir/\$in.day.nc.cpio
      $time_cp $cp $indir/\$in.day.nc.cpio .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $indir/\$in.day.nc.cpio .
         $checktransfer
      endif
      $time_uncpio $uncpio -ivI \$in.day.nc.cpio \$in.\$var.nc
      $check_cpio
      $time_dmput dmput "$indir/\$in.day.nc.cpio"
   else
      $time_cp $cp $indir/\$in.\$var.nc .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $indir/\$in.\$var.nc .
         $checktransfer
      endif
   endif

   set d1 = 0
   set d2 = 0

   foreach y1 ( @hDates )
      set monthi = 0

      foreach days ( 31 28 31 30 31 30 31 31 30 31 30 31 )
        @ d1 = \$d2 + 1
        @ d2 = \$d2 + \$days

        @ monthi ++
        set m1 = `printf '%02i' \$monthi`

        set t = `ncdump -h \$in.\$var.nc | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
        $time_ncks ncks \$ncksopt -d \$t,\$d1,\$d2 \$in.\$var.nc \$y1\$m1.\$var.daily.nc
        $check_ncks
        $time_timavg \$TIMAVG -o \$y1\$m1.\$var.nc \$y1\$m1.\$var.daily.nc
        $retry_timavg
           $time_timavg \$TIMAVG -o \$y1\$m1.\$var.nc \$y1\$m1.\$var.daily.nc
        $check_timavg
        $time_rm rm -f \$y1\$m1.\$var.daily.nc
      end
   end

   $time_rm rm -f \$in.\$var.nc
   if ( -e \$out.\$var.nc ) rm -f \$out.\$var.nc
   $time_ncrcat ncrcat \$ncrcatopt *??.\$var.nc \$out.\$var.nc
   $check_ncrcat
   $time_ncatted ncatted -h -O -a filename,global,m,c,"\$out.\$var.nc" \$out.\$var.nc
   $check_ncatted
   $compress
   set tmpstring = `ncdump -h \$out.\$var.nc | grep UNLIMITED`
   $time_mv $mvfile \$out.\$var.nc $outdir/
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$out.\$var.nc $outdir/
      $checktransfer
   endif
   $time_rm rm \$out.\$var.nc
   $time_rm rm -f *??.\$var.nc
   @ len = \$#tmpstring - 1
   set length = `echo \$tmpstring[\$len] | cut -c2-`
   test \$length = $numtimelevels
   $check_levels
end

EOF

        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);

        return $csh;
    } ## end sub monthlyTSfromdailyTS

    #TIMESERIES - HOURLY, DAILY, MONTHLY, ANNUAL
    sub directTS {

        #tsNode = $_[0] ;
        my $sim0       = $_[1];
        my $startofrun = $_[2];
        my $ppcNode    = $_[0]->parentNode;
        my $avgatt     = $_[0]->findvalue('@averageOf');
        my $freq       = $_[0]->findvalue('@freq');
        my $source     = $_[0]->findvalue('@source');
        if ( "$source" eq "" ) { $source = $ppcNode->findvalue('@source'); }
        if ( "$avgatt" ne "" ) {
            if ( "$avgatt" eq "daily" ) {
                return monthlyTSfromdailyTS( $_[0], $sim0, $startofrun );
            }
            else {
                print STDERR
                    "WARNING: $freq TS calculated from $avgatt TS is not supported. Skipping.\n";
                return "";
            }
        }
        my $sim0f = FREUtil::graindate( $sim0, $freq );
        my $t0f   = FREUtil::graindate( $t0,   $freq );
        my $tENDf = FREUtil::graindate( $tEND, $freq );
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $chunkstr    = $chunkLength;
        if ( "$chunkLength" eq "" ) {
            print STDERR
                "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
            mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
            return "";
        }
        my $outdirpath = "$component/ts/$freq/$chunkLength";
        my $outdir     = "$ppRootDir/$outdirpath";

        my $iunit;
        if ( $chunkLength =~ /(\d*)(?:y|yr|years?)/i ) {
            $iunit       = "years";
            $chunkLength = $1;
        }
        elsif ( $chunkLength =~ /(\d*)(?:mo|mon|months)/i ) {
            $iunit       = "months";
            $chunkLength = $1;
        }
        else {
            print STDERR
                "ERROR: Cannot create $component $freq timeSeries because can't parse chunkLength=$chunkLength.\n";
            mailuser(
                "ERROR: Cannot create $component $freq timeSeries because can't parse chunkLength=$chunkLength."
            );
            return;
        }

        my $yrsSoFar = &Delta_Format( FREUtil::dateCalc( $sim0, $t0 ), 0, "%yd" );
        my $mod = ( $yrsSoFar + 1 ) % $chunkLength;
        if ( $mod != 0 and "$iunit" eq "years" ) {
            return "";
        }    #don't do any calculations until a chunk is ready to go.
        $mkdircommand .= "$outdir ";
        if ( $chunkLength > $maxyrs ) { $maxyrs = $chunkLength; }

        my $hDateyr = $userstartyear;
        my $hDatemo = substr( $userstartmo, 2, 2 );
        my @hDates  = ();
        my $start   = '';
        if ( "$iunit" eq "years" ) {
            @hDates = ( FREUtil::padzeros( $hDateyr - $chunkLength + 1 ) .. "$hDateyr" );
            $start
                = FREUtil::graindate( FREUtil::modifydate( $tEND, "-$chunkLength $iunit +1 sec" ),
                $freq );
        }
        else {
            @hDates = ("$hDateyr");

       #the following gives wrong results, bug in Date:Manip
       #$start = FREUtil::graindate(FREUtil::modifydate($tEND,"-$chunkLength months +1 sec"),$freq);
       #the following is a cheap trick to fix the problem
            $start = FREUtil::modifydate( $tEND, "-$chunkLength months + 5 days" );
            $start = FREUtil::graindate( $start, "mon" );
            $start .= "01";
            $start = FREUtil::graindate( $start, $freq );
        }

        #print "start $start, tENDf $tENDf, chunkLength $chunkLength, iunit $iunit\n";

        foreach my $d (@hDates) { $historyfiles .= "$d$hDatemo" . "01.nc.tar "; }

        #determine whether to interpolate z levels
        my $zInterp    = $ppcNode->findvalue('@zInterp');
        my $do_zInterp = 0;
        if ( "$zInterp" ne "" ) { $do_zInterp = 1; }

        #get variables
        my $uservariables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        $uservariables =~ s/ /,/g;
        my $availablevars = $dtvars{"all_$source"};
        $availablevars =~ s/^/,/g;
        $availablevars =~ s/$/,/g;
        $availablevars .= 'hght,slp,' if $do_zInterp;
        my $variables = '';
        foreach my $v ( split( ',', $uservariables ) ) {

            if ( $availablevars =~ /,$v,/ ) {
                $variables = "$variables $v";
            }
            else {
                $variables = "$variables $v";
                print STDERR
                    "WARNING: $freq $component post-processing requested for variable $v but it does not exist in the $source diag table.\n"
                    ; #Don't actually skip the variable until refineDiag supported as available variables.
            }
        }
        $variables =~ s/^ //g;
        $variables =~ s/ /,/g;
        if ( "$variables" ne "" ) {
            print STDERR "        from xml, vars are '$variables'\n" if $opt_v;
        }

        my $numtimelevels = gettimelevels( $freq, $chunkLength );

        #my $check_cpio = errorstr("CPIO ($component $freq ts from $source)");
        my $check_cpio_msg    = "CPIO ($component $freq ts from $source)";
        my $check_plevel      = errorstr("PLEVEL ($component $freq ts from $source)");
        my $check_splitncvars = errorstr("SPLITNCVARS ($component $freq ts from $source)");
        my $check_ncrcat      = errorstr("NCRCAT ($component $freq ts from $source)");
        my $check_ncatted     = errorstr("NCATTED ($component $freq ts from $source)");
        my $check_ncdump      = errorstr("NCDUMP ($component $freq ts from $source)");
        my $check_timavg      = retryonerrorend("TIMAVG ($component $freq ts from $source)");
        my $retry_timavg      = retryonerrorstart("TIMAVG");
        my $check_ncks        = errorstr("NCKS ($component $freq ts from $source)");
        my $check_filesexist
            = errorstr("NO USABLE VARIABLES EXIST ($component $freq ts from $source)");
        my $check_fregrid  = errorstr("FREGRID ($component $freq ts from $source)");
        my $check_ncrename = errorstr("NCRENAME ($component $freq ts from $source)");
        my $check_nccopy   = errorstr("NCCOPY ($component $freq ts from $source)");
        my $check_levels   = '';

        if ( "$caltype" eq "NOLEAP" or "$caltype" eq "noleap" ) {
            $check_levels
                = errorstr(
                "WRONG NUMBER OF TIME LEVELS (contains \$length, should be $numtimelevels) IN \$outdir/$component.$start-$tENDf.\$file"
                );
        }
        my $csh = setcheckpt( "directTS_$freq" . "_$chunkstr" );
        $csh .= <<EOF;

#####################################
echo 'timeSeries ($component $freq from $source)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath

EOF
        if ($opt_z) { $csh .= begin_systime(); }

        my $tmp_month = '01';
        my $tmpsrcstr = "$source.nc";
        if ( "$sourceGrid" eq 'cubedsphere' ) { $tmpsrcstr = "$source.tile*.nc"; }

        $csh .= <<EOF;
   foreach hDate ( @hDates )
      set nhistfiles = 0
      foreach file ( `ls \$histDir/\$hDate*/*.$tmpsrcstr`)
        ln -s \$file .
        @ nhistfiles ++
      end
      foreach file ( `ls \$histDir/\$hDate*/*.grid_spec.tile*.nc`)
        ln -s \$file .
      end
      if ( \$nhistfiles == 0 ) then
         echo 'ERROR: No history files matching \$hDate*/*.$tmpsrcstr'
      endif
   end
   mkdir -p byVar
EOF

        if ($do_zInterp) {
            if ( "$sourceGrid" eq 'cubedsphere' ) {

                # cat, call plevel, on tiles
                $csh .= <<EOF;
if ( -e modellevels.nc ) rm -f modellevels*.nc
set i = 1
while ( \$i <= 6 )
$time_ncrcat ncrcat \$ncrcatopt *.$source.tile\$i.nc $hDate.modellevels.tile\$i.nc
$check_ncrcat
@ i ++
end
EOF
                foreach my $i ( 1 .. 6 ) {
                    $csh .= zInterpolate( $zInterp, "$hDate.modellevels.tile$i.nc",
                        "$hDate.$source.tile$i.nc", $caltype, $variables, $source );
                }

                # convert tiles to latlon
                if ( "$xyInterp" ne '' ) {

                    my $fregrid_wt = '';
                    if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                        print
                            "       land_frac found, weighting exchange grid cell with $hDate.land_static\n"
                            if $opt_v;
                        $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
                    }
                    my $call_and_check_fregrid = $call_tile_fregrid;
                    $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                    $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                    $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                    $csh .= <<EOF;

    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = $hDate.$source
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st0123
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid

mv \$fregrid_in.nc all.nc

EOF
                } ## end if ( "$xyInterp" ne '')
            } ## end if ( "$sourceGrid" eq ...)
            else {    # not cubic
                $csh .= <<EOF;
if ( -e modellevels.nc ) rm -f modellevels.nc
$time_ncrcat ncrcat \$ncrcatopt *.$source.nc modellevels.nc
$check_ncrcat
$time_rm rm -f *.$source.nc
EOF
                $csh .= zInterpolate( $zInterp, 'modellevels.nc', 'all.nc', $caltype, $variables,
                    "all" );

                # convert latlon/tripolar to latlon
                if ( "$xyInterp" ne '' ) {
                    my $fregrid_wt = '';
                    if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                        print
                            "       land_frac found, weighting exchange grid cell with $hDate.land_static\n"
                            if $opt_v;
                        $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
                    }
                    my $call_and_check_fregrid = $call_fregrid;
                    $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                    $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                    $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                    $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = 'all'
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid

EOF
                } ## end if ( "$xyInterp" ne '')
            } ## end else [ if ( "$sourceGrid" eq ...)]
        } ## end if ($do_zInterp)
        else {    # no zInterpolation
            if ( "$sourceGrid" eq 'cubedsphere' ) {
                $csh .= <<EOF;
#if ( -e all.nc ) rm -f all.nc
set i = 1
while ( \$i <= 6 )
$time_ncrcat ncrcat \$ncrcatopt *.$source.tile\$i.nc $hDate.$source.tile\$i.nc
$check_ncrcat
@ i ++
end
EOF

                # convert tiles to latlon
                if ( "$xyInterp" ne '' ) {

                    my $fregrid_wt = '';
                    if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                        print
                            "       land_frac found, weighting exchange grid cell with $hDate.land_static\n"
                            if $opt_v;
                        $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
                    }
                    my $call_and_check_fregrid = $call_tile_fregrid;
                    $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                    $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                    $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                    $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = $hDate.$source
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st0123
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid

mv \$fregrid_in.nc all.nc

EOF
                } ## end if ( "$xyInterp" ne '')
            } ## end if ( "$sourceGrid" eq ...)
            else {    #not cubic, just ncrcat
                $csh .= <<EOF;
if ( -e all.nc ) rm -f all.nc
$time_ncrcat ncrcat \$ncrcatopt *.$source.nc all.nc
$check_ncrcat
$time_rm rm -f *.$source.nc

EOF

                # convert latlon/tripolar to latlon
                if ( "$xyInterp" ne '' ) {

                    my $fregrid_wt = '';
                    if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                        print
                            "       land_frac found, weighting exchange grid cell with $hDate.land_static\n"
                            if $opt_v;
                        $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
                    }
                    my $call_and_check_fregrid = $call_fregrid;
                    $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                    $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                    $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                    $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = 'all'
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid

EOF
                } ## end if ( "$xyInterp" ne '')
            } ## end else [ if ( "$sourceGrid" eq ...)]
        } ## end else [ if ($do_zInterp) ]
        if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {
            $csh .= "set filestosplit = ( `ls -1 | egrep \"$hDate.$source.tile..nc\"` )\n";
        }
        else {
            $csh .= "set filestosplit = ( all.nc )\n";
        }

        # make sure file has bounds, splitncvars, adjust output, send to archive
        my $variablesopt = '';
        $variablesopt = "-v $variables" if "$variables" ne '';
        my $compress = compress_csh( "\$file", $check_nccopy );
        $csh .= <<EOF;
foreach filetosplit ( \$filestosplit )

# Determine if fields average_T1 and ( *_bounds or *_bnds ) exist in the
# netCDF file.  If not, add in time_bounds.
if ( `ncdump -h \$filetosplit | grep -c " average_T1("` == 1 && `ncdump -h \$filetosplit | grep -c "_b\\(ou\\)\\?nds("` == 0) then
   ncdump -v average_T1,average_T2 \$filetosplit | /home/fms/bin/addbounds.pl | ncgen -o tmp.nc
   set taxis = `ncdump -h \$filetosplit | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
   $time_ncks ncks \$ncksopt -C -A -v \${taxis}_bounds tmp.nc \$filetosplit
   $check_ncks
   $time_ncatted ncatted -h -O -a bounds,\$taxis,c,c,"\${taxis}_bounds" \$filetosplit
   $check_ncatted
endif

$time_splitncvars \$SPLITNCVARS -o byVar $variablesopt \$filetosplit
$check_splitncvars

cd byVar
test `ls | wc -l` -gt 0
$check_filesexist
if ( `ls | wc -l` > 0 ) then
foreach file ( *.nc )
     set label = "\$file:r.nc"
     $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$start-$tENDf.\$label" \$file
     $check_ncatted
     set tmpstring = `ncdump -h \$file | grep UNLIMITED`
     @ len = \$#tmpstring - 1
     set length = `echo \$tmpstring[\$len] | cut -c2-`
     test \$length = $numtimelevels
     $check_levels
     $compress
     $time_mv $mvfile \$file \$outdir/$component.$start-$tENDf.\$label
     if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile \$file \$outdir/$component.$start-$tENDf.\$label
         $checktransfer
     endif
     $time_mv $mv \$file \$tempCache/$outdirpath/$component.$start-$tENDf.\$label
end
cd \$work
$time_rm rm -rf byVar

end
EOF

        #cpio the timeseries
        if ($aggregateTS) {
            my $abbrev = FREUtil::timeabbrev($freq);
            my $cpioTS = '';
            if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" ne '' ) {
                $cpioTS
                    = createcpio( "\$tempCache/$outdirpath", $outdir,
                    "$component.$start-$tENDf.tile?",
                    $abbrev, 1 );
            }
            else {
                $cpioTS
                    = createcpio( "\$tempCache/$outdirpath", $outdir, "$component.$start-$tENDf",
                    $abbrev, 1 );
            }
            if   ( "$freq" eq "monthly" ) { $cpiomonTS .= $cpioTS; }
            else                          { $csh       .= $cpioTS; }
        }

        $csh .= "\nendif\n";

        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);

        return $csh;
    } ## end sub directTS

    #TIMEAVERAGES - MONTHLY
    sub monthlyAVfromav {

        #taNode = $_[0] ;
        my $sim0    = $_[1];
        my $subint  = $_[2];
        my $ppcNode = $_[0]->parentNode;

        my $src         = 'monthly';
        my $interval    = $_[0]->findvalue('@interval');
        my $outdir      = "$ppRootDir/$component/av/$src" . "_$interval";
        my $srcdir      = "$ppRootDir/$component/av/$src" . "_$subint" . "yr";
        my $chunkLength = $_[0]->findvalue('@chunkLength');

        my $tmp = FREUtil::modifydate( $tEND, "+ 1 sec" );
        my $yrsSoFar = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $int = $interval;
        $int =~ s/yr//;
        my $mod = $yrsSoFar % $int;
        unless ( $mod == 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $int > $maxyrs ) { $maxyrs = $int; }

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        $variables =~ s/ /,/g;

        #check for missing files
        my $diag_source = $_[0]->findvalue('@diagSource');
        my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
        if ( scalar @monthnodes and "$diag_source" eq "" ) {
            my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        my $sim0f = FREUtil::graindate( $sim0, $src );
        my $t0f   = FREUtil::graindate( $t0,   $src );
        my $tENDf = FREUtil::graindate( $tEND, $src );
        my $end   = FREUtil::graindate( $tEND, 'year' );
        if ( $end < $int ) { return ""; }    #nothing to do yet
        my $start = FREUtil::padzeros( $end - $int + 1 );

        my $substart = $start;
        my $subend   = FREUtil::padzeros( $start + $subint - 1 );
        my $filelist = "";
        until ( $subend > $end ) {
            if ( $substart == $subend ) { $filelist .= "$component.$substart.\$monthf\$tile.nc "; }
            else { $filelist .= "$component.$substart-$subend.\$monthf\$tile.nc "; }
            $substart = FREUtil::padzeros( $substart + $subint );
            $subend   = FREUtil::padzeros( $subend + $subint );
        }
        my $getlist = $filelist;
        $getlist =~ s/\$monthf\$tile/*/g;
        my $first_file = (split ' ', $filelist)[0];

        #   print "filelist is $filelist\n";
        #   print "getlist is $getlist\n";
        my $tilestart = "set tile = ''";
        my $tileend   = '';
        if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {
            $tilestart = "set tileN=1\nwhile (\$tileN <= 6)\nset tile = .tile\$tileN";
            $tileend   = "@ tileN++\nend";
        }

        my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
        my $check_ncrcat  = errorstr("NCRCAT ($component $src $interval averages)");
        my $check_timavg  = retryonerrorend("TIMAVG ($component $src $interval averages)");
        my $retry_timavg  = retryonerrorstart("TIMAVG");
        my $check_dmget   = errorstr("DMGET ($component $src $interval averages)");
        my $check_nccopy  = errorstr("NCCOPY ($component $src $interval averages)");
        my $csh           = setcheckpt("monthlyAVfromav_$interval");
        my $compress = compress_csh( "$component.$start-$end.\$monthf\$tile.nc", $check_nccopy );
        $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages from $subint yr averages)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir

EOF
        if ($opt_z) { $csh .= begin_systime(); }
        $csh .= <<EOF;

cd $srcdir
$time_dmget dmget "$getlist"
set files = (`ls $getlist`)
cd \$work
foreach file (\$files)
   $time_cp $cp $srcdir/\$file .
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_cp $cp $srcdir/\$file .
      $checktransfer
   endif
end

$tilestart
#get static variables from first file (e.g. 1850.01.nc) from list_ncvars
#hard-code average vars and time_bnds which are skipped in list_ncvars but needed for timavg.csh
if ( "$variables" != '' ) then
    set static_vars = (`\$NCVARS -s0123 $first_file`)
    set static_vars = `echo \$static_vars |sed 's/ /,/g'`
    set avg_vars = (average_T1,average_T2,average_DT,time_bnds)
    set vars = ("$variables","\$static_vars","\$avg_vars")
    unset static_vars avg_vars
endif
set month = 1
while (\$month <= 12)
    set monthf = `echo \$month | sed 's/.*/0&/;s/.\\(..\\)/\\1/'`
    if ( -e month.nc ) rm -f month.nc
    if ( "$variables" != '' ) then
        $time_ncrcat ncrcat \$ncrcatopt -v \$vars $filelist month.nc
    else
        $time_ncrcat ncrcat \$ncrcatopt $filelist month.nc
    endif
    $check_ncrcat
    $time_timavg \$TIMAVG -o $component.$start-$end.\$monthf\$tile.nc month.nc
    $retry_timavg
    $time_timavg \$TIMAVG -o $component.$start-$end.\$monthf\$tile.nc month.nc
    $check_timavg
    $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$start-$end.\$monthf\$tile.nc" $component.$start-$end.\$monthf\$tile.nc
    $check_ncatted
    $compress
    $time_mv $mvfile $component.$start-$end.\$monthf\$tile.nc \$outdir/
    if ( \$status ) then
        echo "WARNING: data transfer failure, retrying..."
        $time_mv $mvfile $component.$start-$end.\$monthf\$tile.nc \$outdir/
        $checktransfer
    endif
    $time_rm rm $component.$start-$end.\$monthf\$tile.nc
    $time_dmput dmput \$outdir/$component.$start-$end.\$monthf\$tile.nc
    $time_rm rm -f month.nc
    @ month++
end
$tileend

EOF

        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);

        return $csh;
    } ## end sub monthlyAVfromav

    #TIMEAVERAGES - ANNUAL XYR
    sub annualAVfromav {

        #taNode = $_[0] ;
        my $sim0   = $_[1];
        my $subint = $_[2];

        my $src         = 'annual';
        my $interval    = $_[0]->findvalue('@interval');
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $sim0f       = FREUtil::graindate( $sim0, $src );
        my $t0f         = FREUtil::graindate( $t0, $src );
        my $tENDf       = FREUtil::graindate( $tEND, $src );
        my $outdir      = "$ppRootDir/$component/av/$src" . "_$interval";
        my $srcdir      = "$ppRootDir/$component/av/$src" . "_$subint" . "yr";
        my $tmp         = FREUtil::modifydate( $tEND, "+ 1 sec" );
        my $yrsSoFar    = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $int         = $interval;
        $int =~ s/yr//;
        my $mod = $yrsSoFar % $int;
        unless ( $mod == 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $int > $maxyrs ) { $maxyrs = $int; }
        my $first = FREUtil::padzeros( $t0f - $int + 1 );

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        $variables =~ s/ /,/g;

        #check for missing files
        my $diag_source = $_[0]->findvalue('@diagSource');
        my @monthnodes  = $_[0]->parentNode->findnodes('timeSeries[@freq="monthly"]');
        if ( scalar @monthnodes and "$diag_source" eq "" ) {
            my $monthnode
                = $_[0]->parentNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        my $csh = setcheckpt("annualAVfromav_$interval");
        $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages from $subint yr averages)'
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
EOF
        if ($opt_z) { $csh .= begin_systime(); }

        my $endinterval = FREUtil::padzeros( $first + $int - 1 );
        until ( $endinterval > $tENDf ) {

            #print "in tA, endinterval($endinterval) tENDf($tENDf)\n";
            my $substart = $first;
            my $subend   = FREUtil::padzeros( $first + $subint - 1 );
            my $filelist = "";
            until ( $subend > $tENDf ) {
                $filelist .= "$component.$substart-$subend.ann\$tile.nc ";
                $substart = FREUtil::padzeros( $substart + $subint );
                $subend   = FREUtil::padzeros( $subend + $subint );
            }

            my $tilestart = "set tile = ''";
            my $tileend   = '';
            if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {
                $tilestart = "set tileN=1\nwhile (\$tileN <= 6)\nset tile = .tile\$tileN";
                $tileend   = "@ tileN++\nend";
            }

            my $check_ncrcat  = errorstr("NCRCAT ($component $src $interval averages)");
            my $check_timavg  = retryonerrorend("TIMAVG ($component $src $interval averages)");
            my $retry_timavg  = retryonerrorstart("TIMAVG");
            my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
            my $check_dmget   = errorstr("DMGET ($component $src $interval averages)");
            my $check_nccopy  = errorstr("NCCOPY ($component $src $interval averages)");
            my $compress
                = compress_csh( "$component.$first-$endinterval.ann\$tile.nc", $check_nccopy );
            $csh .= <<EOF;
cd $srcdir
$tilestart

$time_dmget dmget "$filelist"

cd \$work
foreach file ($filelist)
   $time_cp $cp $srcdir/\$file .
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_cp $cp $srcdir/\$file .
      $checktransfer
   endif
end

if ( -e xyears.nc ) rm -f xyears.nc
if ( "$variables" != '' ) then
   set static_vars = (`\$NCVARS -s0123 \$file`)
   set static_vars = `echo \$static_vars |sed 's/ /,/g'`
   set avg_vars = (average_T1,average_T2,average_DT,time_bnds)
   set vars = ("$variables","\$static_vars","\$avg_vars")
   $time_ncrcat ncrcat \$ncrcatopt -v \$vars $filelist xyears.nc
   unset static_vars avg_vars vars
else
   $time_ncrcat ncrcat \$ncrcatopt $filelist xyears.nc
endif
$check_ncrcat
$time_timavg \$TIMAVG -o $component.$first-$endinterval.ann\$tile.nc xyears.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$first-$endinterval.ann\$tile.nc xyears.nc
$check_timavg
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$first-$endinterval.ann\$tile.nc" $component.$first-$endinterval.ann\$tile.nc
$check_ncatted
$compress
$time_mv $mvfile $component.$first-$endinterval.ann\$tile.nc \$outdir/$component.$first-$endinterval.ann\$tile.nc
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$first-$endinterval.ann\$tile.nc \$outdir/$component.$first-$endinterval.ann\$tile.nc
   $checktransfer
endif
$time_rm rm $component.$first-$endinterval.ann\$tile.nc
$time_rm rm -f xyears.nc

$tileend

EOF
            $first       = FREUtil::padzeros( $endinterval + 1 );
            $endinterval = FREUtil::padzeros( $first + $int - 1 );
        } ## end until ( $endinterval > $tENDf)
        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);
        return $csh;
    } ## end sub annualAVfromav

    #create static variables file
    sub staticvars {
        my $diag_source = $_[0];
        my $ptmpDir     = $_[1];
        my $tmphistdir  = $_[2];
        my $refinedir   = $_[3];

        #note: checking ncks: gives error messages when it shouldn't?
        my $check_ncks        = errorstr("NCKS ($component static variables)");
        my $check_cpio        = errorstr("CPIO ($component static variables)");
        my $check_ncatted     = errorstr("NCATTED ($component static variables)");
        my $check_splitncvars = errorstr("SPLITNCVARS ($component static variables)");
        my $check_fregrid     = errorstr("FREGRID ($component static variables)");
        my $check_ncrename    = errorstr("NCRENAME ($component static variables)");
        my $check_ncatted     = errorstr("NCATTED ($component static variables)");
        my $check_nccopy      = errorstr("NCCOPY ($component static variables)");
        my $compress = compress_csh( "$ppRootDir/$component/$component.static.nc", $check_nccopy );

        $historyfiles .= "$hDate" . ".nc.tar ";

        my $csh = setcheckpt('staticvars');
        $csh .= <<EOF;
#####################################
if ( ! -e $ppRootDir/$component/$component.static.nc ) then
   echo 'static variables ($component)'
   cd \$work
   find \$work/* -maxdepth 1 -exec rm -rf {} \\;
   mkdir -p $ppRootDir/$component
   $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*$diag_source\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*$diag_source\\*
      $checktransfer
   endif
   # Get files listed as associated_files
   foreach file ( $tmphistdir/$hDate.nc/*$diag_source* )
      # Get a list of all associated_files
      set assocFiles = `ncdump -h \$file | $grepAssocFiles`
      foreach assocFile ( \$assocFiles )
         $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*\${assocFile:r}.\\*
      end
   end

   $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*$diag_source\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*$diag_source\\*
$checktransfer
   endif
   # Get files listed as associated_files
   foreach file ( $tmphistdir/$hDate.nc/*$diag_source* )
      # Get a list of all associated_files
      set assocFiles = `ncdump -h \$file | $grepAssocFiles`
      foreach assocFile ( \$assocFiles )
         $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*\${assocFile:r}.\\*
      end
   end

   foreach file ( `ls \$histDir/*/*nc`)
     ln -s \$file .
   end
   set output_files = ( )
EOF

        if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {

            #DATA LEFT ON CUBED SPHERE GRID
            $csh = setcheckpt('staticvars');
            $csh .= <<EOF;
#####################################
if ( ! -e $ppRootDir/$component/$component.static.tile6.nc ) then
   echo 'static variables ($component)'
   cd \$work
   find \$work/* -maxdepth 1 -exec rm -rf {} \\;
   mkdir -p $ppRootDir/$component
   $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*$diag_source\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*$diag_source\\*
$checktransfer
   endif
   # Get files listed as associated_files
   foreach file ( \\*$diag_source\\* )
      # Get a list of all associated_files
      set assocFiles = `ncdump -h \$file | $grepAssocFiles`
      foreach assocFile ( \$assocFiles )
         $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*\${assocFile:r}.\\*
      end
   end

   $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*$diag_source\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*$diag_source\\*
$checktransfer
   endif
   # Get files listed as associated_files
   foreach file ( \\*$diag_source\\* )
      # Get a list of all associated_files
      set assocFiles = `ncdump -h \$file | $grepAssocFiles`
      foreach assocFile ( \$assocFiles )
         $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*\${assocFile:r}.\\*
      end
   end

   foreach file ( `ls \$histDir/*/*nc`)
      if ( ! -e `basename \$file` ) ln -s \$file .
   end
EOF

            foreach my $i ( 1 .. 6 ) {
                $csh .= <<EOF;
   set files = (`ls -1 $hDate.$diag_source*tile$i.nc | grep -v grid_spec | grep -v ocean_geometry`)
   set static = (`\$NCVARS -s012 \$files`) # only support up to 2D static fields
   if ( "\$static" != "" ) then
      foreach file ( \$files )
         set static = (`\$NCVARS -s012 \$file`)
         if ( "\$static" != "" ) then
            set static = `echo \$static | tr ' ' ','`
            $time_splitncvars \$SPLITNCVARS -s -v \$static -f $ppRootDir/$component/$component.static.tile$i.nc \$file
$check_splitncvars
         endif
      end
   endif
endif
EOF
            }
            return $csh;
        } ## end if ( "$sourceGrid" eq ...)
        elsif ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" ne '' ) {

            #DATA CONVERTED FROM CUBED SPHERE TO LATLON

            my $fregrid_wt = '';
            if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                print
                    "       land_frac found, weighting exchange grid cell with $hDate.land_static\n"
                    if $opt_v;
                $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
            }
            my $call_and_check_fregrid = $call_tile_fregrid;
            $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
            $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
            $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
            $call_and_check_fregrid =~ s/set order1/if ( "\$interpvars" != "" ) then\n set order1/;
            my $cubiccsh = <<EOF;

   set output_files = ( )
   set tiles = (`ls -1 $hDate.$diag_source*.tile1.nc | grep -v grid_spec | grep -v ocean_geometry`)
   foreach tfile ( \$tiles )
     if ( ! -w \$tfile ) then
      set i = 1
      while ( \$i <= 6 )
        set tf = \$tfile:r:r.tile\$i.nc
        $time_cp cp \$tf copy
        $time_rm rm -f \$tf
        $time_mv $mv copy \$tf
        chmod 644 \$tf
        @ i ++
      end
     endif
     set fregrid_wt = "$fregrid_wt"
     set fregrid_in_date = $hDate
     set fregrid_in = \$tfile:r:r
     set nlat = $nlat ; set nlon = $nlon
     set interp_method = $interpMethod
     set interp_options = "$xyInterpOptions"
     set ncvars_arg = -s2
     set variables = ( )
     set fregrid_remap_file = $xyInterpRegridFile
     set source_grid = $sourceGrid

     set onedvars = `\$NCVARS -s01 \$fregrid_in.tile1.nc`
     if ( "\$onedvars" != "" ) then
        set onedvarlist = `echo \$onedvars | tr ' ' ','`
        $time_splitncvars \$SPLITNCVARS -s -v \$onedvarlist -f $ppRootDir/$component/$component.static.nc \$fregrid_in.tile1.nc
     endif

# call and check fregrid start
$call_and_check_fregrid
if (-e \$fregrid_in.nc) set output_files = (\$output_files \$fregrid_in.nc)
endif
# call and check fregrid end

     end
EOF
            $csh .= $cubiccsh;
        } ## end elsif ( "$sourceGrid" eq ...)
        else {
            #DATA ALREADY LATLON

            # convert latlon/tripolar to latlon
            if ( "$xyInterp" ne '' ) {

                my $fregrid_wt = '';
                if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                    print
                        "       land_frac found, weighting exchange grid cell with $hDate.land_static\n"
                        if $opt_v;
                    $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
                }
                my $call_and_check_fregrid = $call_fregrid;
                $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                $call_and_check_fregrid
                    =~ s/set order1/if ( "\$interpvars" != "" ) then\n set order1/;
                $csh .= <<EOF;
         set output_files = ( )
         set files = (`ls -1 $hDate.$diag_source*.nc | grep -v grid_spec | grep -v ocean_geometry`)
         foreach file ( \$files )
           set fregrid_wt = "$fregrid_wt"
           set fregrid_in_date = $hDate
           set fregrid_in = \$file:r
           set nlat = $nlat ; set nlon = $nlon
           set interp_method = $interpMethod
           set interp_options = "$xyInterpOptions"
           set ncvars_arg = -s2
           set variables = ( )
           set fregrid_remap_file = $xyInterpRegridFile
           set source_grid = $sourceGrid

           $call_and_check_fregrid

           if (-e \$fregrid_in.nc ) set output_files = (\$output_files \$fregrid_in.nc)
         endif
         end

EOF
            } ## end if ( "$xyInterp" ne '')
            else {

                $csh .= <<EOF;
   set output_files = (`ls -1 $hDate.$diag_source*.nc | grep -v grid_spec | grep -v ocean_geometry`)
EOF
            }
        } ## end else [ if ( "$sourceGrid" eq ...)]

        # process latlon files for static variables
        $csh .= <<EOF;
   if ( \$#output_files > 0 ) then
      set static = (`\$NCVARS -s012 \$output_files`) # only support up to 2D static fields
      if ( "\$static" != "" ) then
         foreach file ( \$output_files )
            set static = (`\$NCVARS -s012 \$file`)
            if ( "\$static" != "" ) then
               set static = `echo \$static | tr ' ' ','`
               $time_splitncvars \$SPLITNCVARS -s -v \$static -f $ppRootDir/$component/$component.static.nc \$file
               $check_splitncvars
            endif
         end
         $time_dmput dmput $ppRootDir/$component/$component.static.nc
      endif
   endif
   $compress
endif
EOF
        return $csh;
    } ## end sub staticvars

    #TIMESERIES - from smaller timeSeries
    sub TSfromts {

        #tsNode = $_[0] ;
        my $sim0     = $_[1];
        my $subchunk = $_[2];
        my $ppcNode  = $_[0]->parentNode;

        my $freq        = $_[0]->findvalue('@freq');
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $outdirpath  = "$component/ts/$freq/$chunkLength";
        my $outdir      = "$ppRootDir/$outdirpath";
        if ( "$chunkLength" eq "" ) {
            mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
            print STDERR
                "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
            return "";
        }
        my $subchunkyr = "$subchunk" . "yr";
        my $reqpath    = "$ppRootDir/$component/ts/$freq/$subchunk" . "yr";
        my $tmp        = FREUtil::modifydate( $tEND, "+1 sec" );
        my $yrsSoFar   = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $cl         = $chunkLength;
        $cl =~ s/yr//;
        my $mod = $yrsSoFar % $cl;
        unless ( $mod == 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $cl > $maxyrs ) { $maxyrs = $cl; }

        #check that all files up to current time exist
        my @nodes       = $ppcNode->findnodes("timeSeries[\@freq='$freq']");
        my $diag_source = "";
        if ( scalar @nodes ) {
            my $node = $ppcNode->findnodes("timeSeries[\@freq='$freq']")->get_node(1);
            $diag_source = $node->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        my $tENDf = FREUtil::graindate( $tEND, $freq );
        my $start = FREUtil::modifydate( $tEND, "-$cl years +1 sec" );
        if ( "$start" eq "0001010300:00:00" ) {
            $start = "0001010100:00:00";
        }    #omg, hack, date::manip bugs
        my $end = FREUtil::modifydate( $start, "+$subchunk years -1 sec" );
        my $startf = FREUtil::graindate( $start, $freq );
        my $endf   = FREUtil::graindate( $end,   $freq );

#print "TSfromts tEND $tEND cl $cl subchunk $subchunk start $start startf $startf end $end endf $endf\n";

        my $filelist   = "";
        my $getlist    = "";
        my $cpiolist   = "";
        my $periodlist = "";
        until ( $endf > $tENDf ) {
            $filelist = "$filelist $component.$startf-$endf.\$var";
            $cpiolist
                = "$cpiolist $component.$startf-$endf." . FREUtil::timeabbrev($freq) . ".nc.cpio";
            $getlist    = "$getlist $component.$startf-$endf.\*.nc";
            $periodlist = "$periodlist $component.$startf-$endf";
            $start      = FREUtil::modifydate( $start, " + $subchunk years" );
            $end        = FREUtil::modifydate( $end, " + $subchunk years" );
            $startf     = FREUtil::graindate( $start, $freq );
            $endf       = FREUtil::graindate( $end, $freq );
        }

        #print "filelist is $filelist\n";
        #print "getlist is $getlist\n";
        #print "cpiolist is $cpiolist\n";

        my $start = FREUtil::modifydate( $tEND, "-$cl years +1 sec" );
        my $startf = FREUtil::graindate( $start, $freq );

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        if ( "$variables" ne "" ) {
            print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
        }
        $variables =~ s/ /.nc /g;
        if ( "$variables" ne "" ) { $variables =~ s/$/.nc/g }
        my $varlist_from_xml = "";
        if ( "$variables" ne "" ) {
            $varlist_from_xml = "set varlist = ( $variables )";
        }

        my $numtimelevels = gettimelevels( $freq, $chunkLength );
        my $check_ncatted
            = errorstr("NCATTED ($component $freq $chunkLength ts from $subchunk yr ts)");
        my $check_ncrcat
            = errorstr("NCRCAT ($component $freq $chunkLength ts from $subchunk yr ts)");

        #my $check_cpio = errorstr("CPIO ($component $freq $chunkLength ts from $subchunk yr ts)");
        my $check_cpio_msg = "CPIO ($component $freq $chunkLength ts from $subchunk yr ts)";
        my $check_dmget = errorstr("DMGET ($component $freq $chunkLength ts from $subchunk yr ts)");
        my $check_nccopy
            = errorstr("NCCOPY ($component $freq $chunkLength ts from $subchunk yr ts)");
        my $check_levels = '';
        if ( "$caltype" eq "NOLEAP" or "$caltype" eq "noleap" ) {
            $check_levels
                = errorstr(
                "WRONG NUMBER OF TIME LEVELS (contains \$length, should be $numtimelevels) IN \$outdir/$component.$startf-$tENDf.\$var"
                );
        }
        my $check_vars = errorstr(
            "NOT ALL VARIABLES EXIST FOR ($component $freq $chunkLength ts from $subchunk yr ts)");

        my $compress = compress_csh( "$component.$startf-$tENDf.\$var", $check_nccopy );

        my $csh = setcheckpt( "TSfromts_$freq" . "_$chunkLength" );
        $csh .= <<EOF;
#####################################
echo 'timeSeries ($component $freq $chunkLength ts from $subchunk yr ts)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath

EOF
        if ($opt_z) { $csh .= begin_systime(); }
        $csh .= <<EOF;

cd $reqpath
set cpiosexist = 1
foreach f ( $cpiolist )
   if ( ! -e \$f ) set cpiosexist = 0
end
if ( \$cpiosexist ) then
   cd $reqpath
   $time_dmget dmget $cpiolist
   set mylist = (`ls $cpiolist`)
   cd \$work
   foreach cpio ( \$mylist )
      $time_cp $cp $reqpath/\$cpio .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $reqpath/\$cpio .
         $checktransfer
      endif
      $time_uncpio $uncpio -ivI \$cpio || ( echo "$check_cpio_msg"; echo "$check_cpio_msg" > \$work/.errors )
   end
   set varlist = `ls -1 $getlist | cut -f3- -d'.' | sort -u`
   $varlist_from_xml
else
   cd $reqpath
   set varlistprev = start
   foreach f ( $periodlist )
      set varlist = `ls -1 \$f.*.nc | cut -f3- -d'.' | sort -u`
      if ( \$#varlist == 0 ) break
      if ( "\$varlistprev" != "start" && \$#varlist != \$varlistprev ) then
         echo "WARNING: different number of variables found for different time periods: \$#varlist vs \$varlistprev, extracting cpio files to retrieve all variables"
         set varlistprev = 'error'
         break
      else
         set varlistprev = \$#varlist
      endif
   end
   test \$#varlist != 0 -o "\$varlistprev" != "error"
   $check_vars
   $varlist_from_xml
   $time_dmget dmget "$getlist"
   cd \$work
   foreach var (\$varlist)
      foreach file ( $filelist )
         if ( ! -f \$tempCache/$component/ts/$freq/$subchunkyr/\$file ) then
            $time_cp $cp $reqpath/\$file \$tempCache/$component/ts/$freq/$subchunkyr/\$file
            if ( \$status ) then
               echo "WARNING: data transfer failure, retrying..."
               $time_cp $cp $reqpath/\$file \$tempCache/$component/ts/$freq/$subchunkyr/\$file
               $checktransfer
            endif
         endif
         ln -s \$tempCache/$component/ts/$freq/$subchunkyr/\$file .
      end
   end
endif


cd \$work
foreach var (\$varlist)
     if ( -e $component.$startf-$tENDf.\$var ) rm -f $component.$startf-$tENDf.\$var
     $time_ncrcat ncrcat \$ncrcatopt $filelist $component.$startf-$tENDf.\$var
     $check_ncrcat
     $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$startf-$tENDf.\$var" $component.$startf-$tENDf.\$var
     $check_ncatted
     set tmpstring = `ncdump -h $component.$startf-$tENDf.\$var | grep UNLIMITED`
     @ len = \$#tmpstring - 1
     set length = `echo \$tmpstring[\$len] | cut -c2-`
     test \$length = $numtimelevels
     $check_levels
     $compress
     $time_mv $mvfile $component.$startf-$tENDf.\$var $outdir/
     if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $component.$startf-$tENDf.\$var $outdir/
         $checktransfer
     endif
     $time_mv $mv \$work/$component.$startf-$tENDf.\$var \$tempCache/$outdirpath/
end

EOF

        if ($aggregateTS) {
            $csh .= createcpio( "\$tempCache/$outdirpath", $outdir, "$component.$startf-$tENDf",
                FREUtil::timeabbrev($freq), 1 );
        }
        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);

        return $csh;
    } ## end sub TSfromts

    #TIMESERIES - from smaller timeSeries
    sub seaTSfromts {

        #tsNode = $_[0] ;
        my $sim0     = $_[1];
        my $subchunk = $_[2];
        my $ppcNode  = $_[0]->parentNode;

        my $freq        = $_[0]->findvalue('@freq');
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $outdirpath  = "$component/ts/$freq/$chunkLength";
        my $outdir      = "$ppRootDir/$outdirpath";
        if ( "$chunkLength" eq "" ) {
            mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
            print STDERR
                "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
            return "";
        }
        my $subchunkyr = "$subchunk" . "yr";
        my $reqpath    = "$ppRootDir/$component/ts/$freq/$subchunk" . "yr";
        my $req        = "$component/ts/$freq/$subchunk" . "yr";
        my $tmp        = FREUtil::modifydate( $tEND, "+1 sec" );
        my $yrsSoFar   = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $cl         = $chunkLength;
        $cl =~ s/yr//;
        my $mod = $yrsSoFar % $cl;
        unless ( $mod == 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $cl > $maxyrs ) { $maxyrs = $cl; }

        #check that all files up to current time exist
        my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
        my $diag_source = "";
        if ( scalar @monthnodes ) {
            my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        my $tENDf = FREUtil::graindate( $tEND, 'year' );
        my $start = FREUtil::modifydate( $tEND,  "-$cl years +1 sec" );
        my $end   = FREUtil::modifydate( $start, "+$subchunk years -1 sec" );
        my $startf = FREUtil::graindate( $start, 'year' );
        my $endf   = FREUtil::graindate( $end,   'year' );

        my $filelist = "";
        my $cpiolist = "";
        until ( $endf > $tENDf ) {
            $filelist = "$filelist $component.$startf-$endf.\$sea.\$var";
            $cpiolist
                = "$cpiolist $component.$startf-$endf." . FREUtil::timeabbrev($freq) . ".nc.cpio";
            $start = FREUtil::modifydate( $start, " + $subchunk years" );
            $end   = FREUtil::modifydate( $end,   " + $subchunk years" );
            $startf = FREUtil::graindate( $start, 'year' );
            $endf   = FREUtil::graindate( $end,   'year' );
        }

        #get variables
        my $variables  = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        my $setvarlist = "";
        if ( "$variables" eq "" ) {
            $setvarlist
                = "set varlist = (`ls -1 | grep -v '.nc.cpio' | cut -f4-5 -d'.' | sort -u`)\n";
            $variables = '$varlist';
        }
        else {
            print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
            $variables =~ s/ /.nc /g;
            if ( "$variables" ne "" ) { $variables =~ s/$/.nc/g }
            $setvarlist = "set varlist = ( $variables )\n";
        }

        my $start = FREUtil::modifydate( $tEND, "-$cl years +1 sec" );
        my $startf = FREUtil::graindate( $start, 'year' );
        my $numtimelevels = gettimelevels( $freq, $chunkLength );

        my $check_ncatted
            = errorstr("NCATTED ($component $freq $chunkLength ts from $subchunk yr ts)");
        my $check_ncrcat
            = errorstr("NCRCAT ($component $freq $chunkLength ts from $subchunk yr ts)");
        my $check_cpio_msg = "CPIO ($component $freq $chunkLength ts from $subchunk yr ts)";
        my $check_dmget = errorstr("DMGET ($component $freq $chunkLength ts from $subchunk yr ts)");
        my $check_nccopy
            = errorstr("NCCOPY ($component $freq $chunkLength ts from $subchunk yr ts)");
        my $check_levels = '';

        if ( "$caltype" eq "NOLEAP" or "$caltype" eq "noleap" ) {
            $check_levels
                = errorstr(
                "WRONG NUMBER OF TIME LEVELS (contains \$length, should be $numtimelevels) IN \$outdir/$component.$startf-$tENDf.\$sea.\$var"
                );
        }
        my $check_vars
            = errorstr(
            "MISSING FILE $reqpath/\$file, $component.$startf-$tENDf.\$sea.\$var NOT CREATED ($component $freq $chunkLength ts from $subchunk yr ts)"
            );

        my @pieces = split ' ', $filelist;
        my $dmgetcommand = "";
        foreach my $piece (@pieces) {
            $piece =~ s/\$sea.\$var/*.nc/g;
            $dmgetcommand .= "$time_dmget dmget \"$piece\"\n";
        }
        my $compress = compress_csh( "$component.$startf-$tENDf.\$sea.\$var", $check_nccopy );
        my $csh = setcheckpt("seaTSfromts_$chunkLength");
        $csh .= <<EOF;
#####################################
echo 'timeSeries ($component $freq $chunkLength ts from $subchunk yr ts)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath

EOF
        if ($opt_z) { $csh .= begin_systime(); }
        $csh .= <<EOF;

cd $reqpath
set cpiosexist = 1
foreach f ( $cpiolist )
   if ( ! -e \$f ) set cpiosexist = 0
end
if ( \$cpiosexist ) then
   $time_dmget dmget $cpiolist
   set mylist = (`ls $cpiolist`)
   cd \$work
   foreach cpio ( \$mylist )
      $time_cp $cp $reqpath/\$cpio .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $reqpath/\$cpio .
         $checktransfer
      endif
      $time_uncpio $uncpio -ivI \$cpio || ( echo "$check_cpio_msg"; echo "$check_cpio_msg" > \$work/.errors )
   end
   $setvarlist
else
   $setvarlist
   $dmgetcommand
   cd \$work
   foreach sea ( DJF MAM JJA SON )
      foreach var (\$varlist)
         foreach file ( $filelist )
            if ( ! -f \$tempCache/$req/\$file ) then
               $time_cp $cp $reqpath/\$file \$tempCache/$req/\$file
               if ( \$status ) then
                  echo "WARNING: data transfer failure, retrying..."
                  $time_cp $cp $reqpath/\$file \$tempCache/$req/\$file
                  $checktransfer
               endif
            endif
            ln -s \$tempCache/$req/\$file .
         end
      end
   end
endif

cd \$work
foreach sea (DJF MAM JJA SON)
   foreach var (\$varlist)
      set missingfiles = 0
      foreach file ($filelist)
         test -e \$file
         $check_vars
         if ( ! -e \$file ) set missingfiles = 1
      end
      if ( \$missingfiles == 0 ) then

      if ( -e $component.$startf-$tENDf.\$sea.\$var ) rm -f $component.$startf-$tENDf.\$sea.\$var
      $time_ncrcat ncrcat \$ncrcatopt $filelist $component.$startf-$tENDf.\$sea.\$var
      $check_ncrcat
      $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$startf-$tENDf.\$sea.\$var" $component.$startf-$tENDf.\$sea.\$var
      $check_ncatted
      set tmpstring = `ncdump -h $component.$startf-$tENDf.\$sea.\$var | grep UNLIMITED`
      @ len = \$#tmpstring - 1
      set length = `echo \$tmpstring[\$len] | cut -c2-`
      test \$length = $numtimelevels
      $compress
      $time_mv $mvfile $component.$startf-$tENDf.\$sea.\$var \$outdir/
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $component.$startf-$tENDf.\$sea.\$var \$outdir/
         $checktransfer
      endif
      $time_mv $mv $component.$startf-$tENDf.\$sea.\$var \$tempCache/$outdirpath/
      $check_levels

      endif
   end
end

EOF
        if ($aggregateTS) {
            $csh .= createcpio( "\$tempCache/$outdirpath", $outdir, "$component.$startf-$tENDf",
                FREUtil::timeabbrev($freq), 1 );
        }
        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);

        return $csh;
    } ## end sub seaTSfromts

    #TIMEAVERAGES - SEASONAL
    sub seasonalAVfromhist {

        #taNode = $_[0] ;
        my $sim0    = $_[1];
        my $ppcNode = $_[0]->parentNode;

        my $src         = 'seasonal';
        my $interval    = $_[0]->findvalue('@interval');
        my $outdir      = "$ppRootDir/$component/av/$src" . "_$interval";
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $tmp         = FREUtil::modifydate( $tEND, "+ 1 sec" );
        my $yrsSoFar    = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $int         = $interval;
        $int =~ s/yr//;
        my $mod = $yrsSoFar % $int;
        unless ( $mod == 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $int > $maxyrs ) { $maxyrs = $int; }
        my $hDateyr = $userstartyear;
        my @hDates  = ( FREUtil::padzeros( $hDateyr - $int + 1 ) .. "$hDateyr" );
        my $tBEG    = FREUtil::modifydate( $tEND, "- $int years + 1 sec" );
        my $range   = FREUtil::graindate( $tEND, 'year' );
        if ( scalar @hDates > 1 ) { $range = FREUtil::padzeros( $range - $int + 1 ) . "-$range"; }
        foreach my $d (@hDates) { $historyfiles .= "$d" . "0101.nc.tar "; }

        my $diag_source = $_[0]->findvalue('@diagSource');
        my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
        if ( scalar @monthnodes and "$diag_source" eq "" ) {
            my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        #get variables
        my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
        $variables =~ s/ /,/g;

        my $zInterp    = $ppcNode->findvalue('@zInterp');
        my $do_zInterp = 0;
        if ( "$zInterp" ne "" ) { $do_zInterp = 1; }
        my $check_ncatted  = errorstr("NCATTED ($component $src $interval averages)");
        my $check_cpio     = errorstr("CPIO/TAR ($component $src $interval averages)");
        my $check_cpio_msg = "CPIO ($component $src $interval averages)";
        my $check_ncrcat   = errorstr("NCRCAT ($component $src $interval averages)");
        my $check_timavg   = retryonerrorend("TIMAVG ($component $src $interval averages)");
        my $retry_timavg   = retryonerrorstart("TIMAVG");
        my $check_plevel   = errorstr("PLEVEL ($component $src $interval averages)");
        my $check_ncdump   = errorstr("NCDUMP ($component $src $interval averages)");
        my $check_dmget    = errorstr("DMGET ($component $src $interval averages)");
        my $check_ncap     = errorstr("NCAP ($component $src $interval averages)");
        my $check_nccopy   = errorstr("NCCOPY ($component $src $interval averages)");
        my $check_numfiles = errorstr(
            "INCORRECT NUMBER OF SEASONS IN SEASONAL FILE ($component $src $interval averages)");
        my $check_fregrid  = errorstr("FREGRID ($component $src $interval averages)");
        my $check_ncrename = errorstr("NCRENAME ($component $src $interval averages)");
        my $convertSeg     = convertSegments( $segTime, $segUnits, $diag_source );
        my $convertDec     = convertSegments( $segTime, $segUnits, $diag_source, 'dec' );
        my $decSeg         = ( split ' ', $convertDec )[-4];
        $decSeg =~ s/.*(\d\d01).*/$1/;

        my $csh = setcheckpt("seasonalAVfromhist_$interval");
        $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
mkdir out
EOF
        if ($opt_z) { $csh .= begin_systime(); }

        my $startseason  = 1;
        my $totalseasons = $int * 4;

        if ( "$sourceGrid" eq 'cubedsphere' ) {    #IF CUBIC

            my $tmpsrcstr = "$diag_source.tile*.nc";
            $csh .= <<EOF;
   foreach hDate ( @hDates )
      set nhistfiles = 0
      foreach file ( `ls \$histDir/\$hDate*/*.$tmpsrcstr`)
        ln -s \$file .
        @ nhistfiles ++
      end
      foreach file ( `ls \$histDir/\$hDate*/*.grid_spec.tile*.nc`)
        ln -s \$file .
      end
      if ( \$nhistfiles == 0 ) then
         echo 'ERROR: No history files matching \$hDate*/*.$tmpsrcstr'
      endif
      $convertSeg
   end
EOF
            foreach my $season ( $startseason .. $totalseasons ) {
                my $startmo      = $season * 3 - 4;
                my $tSEASON      = FREUtil::modifydate( $tBEG, "+ $startmo months" );
                my $seahist      = FREUtil::graindate( $tSEASON, 'day' );
                my $tSEASONf     = FREUtil::graindate( $tSEASON, 'seasonal' );
                my ($year)       = $tSEASONf =~ /(\d{4,})\./;
                my ($prevyear)   = $seahist =~ /(\d{4,})\d{4}/;
                my $prevhistcpio = "$prevyear" . $decSeg . ".nc.cpio";
                my $prevhisttar  = "$prevyear" . $decSeg . ".nc.tar";
                my $nextd        = FREUtil::modifydate( $tSEASON, "+ 12 months" );
                my $nextdec      = FREUtil::graindate( $nextd, 'day' ) . ".$diag_source.nc";
                my $tile         = '.tile$i';

                my $nextdec    = FREUtil::graindate( $nextd, 'day' ) . ".$diag_source";
                my $hfilelist1 = "";
                my $hfilelist2 = "";
                my $hfilelist3 = "";
                my $hfilelist4 = "";
                my $hfilelist5 = "";
                my $hfilelist6 = "";
                foreach my $s ( $startmo .. ( $startmo + 2 ) ) {
                    my $t = FREUtil::modifydate( $tBEG, "+ $s months" );
                    my $shist = FREUtil::graindate( $t, 'day' );
                    $hfilelist1 = "$hfilelist1 $shist.$diag_source.tile1.nc";
                    $hfilelist2 = "$hfilelist2 $shist.$diag_source.tile2.nc";
                    $hfilelist3 = "$hfilelist3 $shist.$diag_source.tile3.nc";
                    $hfilelist4 = "$hfilelist4 $shist.$diag_source.tile4.nc";
                    $hfilelist5 = "$hfilelist5 $shist.$diag_source.tile5.nc";
                    $hfilelist6 = "$hfilelist6 $shist.$diag_source.tile6.nc";
                }
                $csh .= <<EOF;
echo season $season ==============================================================
EOF
                if ( $season == 1 ) {
                    $csh .= <<EOF;
if ( ! -e $seahist.$diag_source.tile1.nc ) then
   if ( -e $ppRootDir/.dec/$seahist.$diag_source.tile1.nc ) then
      $time_dmget dmget $ppRootDir/.dec/$seahist.$diag_source.tile?.nc
      $time_cp $cp $ppRootDir/.dec/$seahist.$diag_source.tile?.nc .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $ppRootDir/.dec/$seahist.$diag_source.tile?.nc .
         $checktransfer
      endif
      $time_rm rm -f $ppRootDir/.dec/$seahist.$diag_source.tile?.nc
   else if ( -e $opt_d/$prevhistcpio ) then
      $time_dmget dmget $opt_d/$prevhistcpio
      $time_uncpio $uncpio -ivI $opt_d/$prevhistcpio '*.$diag_source.tile*.nc'
      $check_cpio
      $time_dmput dmput $opt_d/$prevhistcpio
      set prevyear = $prevyear
      set i = 1
      while ( \$i <= 6 )
        $convertDec
        @ i ++
      end
   else if ( -e $opt_d/$prevhisttar ) then
      $time_dmget dmget $opt_d/$prevhisttar
      $time_untar tar -xvf $opt_d/$prevhisttar --wildcards '*.$diag_source.tile*.nc'
      $check_cpio
      $time_dmput dmput $opt_d/$prevhisttar
      set prevyear = $prevyear
      set i = 1
      while ( \$i <= 6 )
        $convertDec
        @ i ++
      end
   else
      set t = `ncdump -h $nextdec.tile1.nc | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
      set att_copy = (`ncdump -h $nextdec.tile1.nc | sed -ne "s/.*\${t}:\\(.*\\) =.*/\$t@\\1=\$t@\\1;/gp"`)
      if ( `ncdump -h $nextdec.tile1.nc | grep -c " average_T1("` == 1 ) then
         # A field with 'long_name =  "time axis boundary"' should be in
         # the file.  Be sure to use the same name in the following
         # commands.  We can rather safely assume the same field name
         # will be used in all the tile files.
         set tbnds_var = `ncdump -h $nextdec.tile1.nc | grep 'long_name = "time axis boundaries"' | awk -F : '{ print $1 }'`

         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${tbnds_var}=\${tbnds_var}-365; \$att_copy" $nextdec.tile1.nc $seahist.$diag_source.tile1.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${tbnds_var}=\${tbnds_var}-365; \$att_copy" $nextdec.tile2.nc $seahist.$diag_source.tile2.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${tbnds_var}=\${tbnds_var}-365; \$att_copy" $nextdec.tile3.nc $seahist.$diag_source.tile3.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${tbnds_var}=\${tbnds_var}-365; \$att_copy" $nextdec.tile4.nc $seahist.$diag_source.tile4.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${tbnds_var}=\${tbnds_var}-365; \$att_copy" $nextdec.tile5.nc $seahist.$diag_source.tile5.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${tbnds_var}=\${tbnds_var}-365; \$att_copy" $nextdec.tile6.nc $seahist.$diag_source.tile6.nc
         $check_ncap
      else
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile1.nc $seahist.$diag_source.tile1.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile2.nc $seahist.$diag_source.tile2.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile3.nc $seahist.$diag_source.tile3.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile4.nc $seahist.$diag_source.tile4.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile5.nc $seahist.$diag_source.tile5.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile6.nc $seahist.$diag_source.tile6.nc
         $check_ncap
      endif
   endif
endif
EOF
                } ## end if ( $season == 1 )

                my $compress = compress_csh( "$component.$tSEASONf.nc", $check_nccopy );

                $csh .= <<EOF;
if ( -e sea1.nc ) $time_rm rm -f sea?.nc
$time_ncrcat ncrcat \$ncrcatopt $hfilelist1 sea1.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist2 sea2.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist3 sea3.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist4 sea4.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist5 sea5.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist6 sea6.nc
$check_ncrcat
$time_rm rm $hfilelist1 $hfilelist2 $hfilelist3 $hfilelist4 $hfilelist5 $hfilelist6
EOF

                #put code here to handle 1yr seasons case
                if ( $int == 1 ) {
                    if ($do_zInterp) {
                        foreach my $t ( 1 .. 6 ) {
                            $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels$t.nc sea$t.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels$t.nc sea$t.nc
$check_timavg
EOF
                            $csh
                                .= zInterpolate( $zInterp, "modellevels$t.nc",
                                "$component.$tSEASONf.tile$t.nc",
                                $caltype, $variables, $component );
                        }
                        $csh .= "$time_rm rm modellevels?.nc\n";

                    }
                    else {
                        foreach my $t ( 1 .. 6 ) {
                            $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$tSEASONf.tile$t.nc sea$t.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$tSEASONf.tile$t.nc sea$t.nc
$check_timavg
EOF
                        }
                    }

                    my $fregrid_wt = '';
                    if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                        print
                            "       land_frac found, weighting exchange grid cell with $hDate.land_static\n"
                            if $opt_v;
                        $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
                    }
                    my $call_and_check_fregrid = $call_tile_fregrid;
                    $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                    $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                    $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                    $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = $component.$tSEASONf
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid

    $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$tSEASONf.nc" $component.$tSEASONf.nc
    $check_ncatted

$compress
$time_mv $mvfile $component.$tSEASONf.nc \$outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$tSEASONf.nc \$outdir/
   $checktransfer
endif
$time_rm rm $component.$tSEASONf.nc
if ( -e \$outdir/$component.$tSEASONf.nc ) $time_rm rm -f sea1.nc sea2.nc sea3.nc sea4.nc sea5.nc sea6.nc
EOF
                } ## end if ( $int == 1 )
                else {    #int > 1
                    foreach my $t ( 1 .. 6 ) {
                        $csh .= <<EOF;
$time_timavg \$TIMAVG -o out/$component.$tSEASONf.tile$t.nc sea$t.nc
$retry_timavg
   $time_timavg \$TIMAVG -o out/$component.$tSEASONf.tile$t.nc sea$t.nc
$check_timavg
$time_rm rm -f sea$t.nc
EOF
                    }
                }
            } ## end foreach my $season ( $startseason...)

            my $startmo = ( $totalseasons + 1 ) * 3 - 4;
            my $tSEASON = FREUtil::modifydate( $tBEG, "+ $startmo months" );
            my $nextdec = FREUtil::graindate( $tSEASON, 'day' ) . ".$diag_source";
            $csh .= <<EOF;
$time_mv $mvfile $nextdec.tile* $ppRootDir/.dec/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $nextdec.tile* $ppRootDir/.dec/
   $checktransfer
endif
$time_rm rm $nextdec.tile*
EOF

            if ( $int > 1 ) {
                $csh .= <<EOF;
$time_mv $mv out/* .
rmdir out
EOF
                foreach my $season ( 'DJF', 'MAM', 'JJA', 'SON' ) {
                    my $dates = "$range" . ".$season";
                    $csh .= <<EOF;
echo season $season =========================================================
test $int = `ls -1 $component.*.$season.tile1.nc | wc -l`
$check_numfiles
set i = 1
while ( \$i <= 6 )
  set list = `ls -1 $component.*.$season.tile\$i.nc`
  if ( -e sea\$i.nc ) $time_rm rm -f sea\$i.nc
  $time_ncrcat ncrcat \$ncrcatopt \$list sea\$i.nc
  $check_ncrcat
  $time_rm rm -f \$list
EOF

                    if ($do_zInterp) {
                        $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels\$i.nc sea\$i.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels\$i.nc sea\$i.nc
$check_timavg
EOF
                        $csh
                            .= zInterpolate( $zInterp, 'modellevels$i.nc',
                            "$component.$dates.tile\$i.nc",
                            $caltype, $variables, $component );
                    }
                    else {
                        $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$dates.tile\$i.nc sea\$i.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$dates.tile\$i.nc sea\$i.nc
$check_timavg
EOF
                    }

                    #apparently we are assuming we want to convert to latlon...?
                    my $fregrid_wt = '';
                    if ( $component =~ /land/ and $dtvars{all_land_static} =~ /\bland_frac\b/ ) {
                        print
                            "       land_frac found, weighting exchange grid cell with $hDate.land_static\n"
                            if $opt_v;
                        $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
                    }
                    my $call_and_check_fregrid = $call_tile_fregrid;
                    $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
                    $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
                    $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
                    my $compress = compress_csh( "$component.$dates.nc", $check_nccopy );
                    $csh .= <<EOF;
@ i ++
end
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = $component.$dates
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set interp_options = "$xyInterpOptions"
    set ncvars_arg = -st0123
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    set source_grid = $sourceGrid
    $call_and_check_fregrid

    $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$dates.nc" $component.$dates.nc
    $check_ncatted

$compress
$time_mv $mvfile $component.$dates.nc \$outdir/$component.$dates.nc
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$dates.nc \$outdir/$component.$dates.nc
   $checktransfer
endif
$time_rm rm $component.$dates.nc
$time_dmput dmput \$outdir/$component.$dates.nc
$time_rm rm -f sea1.nc sea2.nc sea3.nc sea4.nc sea5.nc sea6.nc
EOF
                } ## end foreach my $season ( 'DJF',...)
            } ## end if ( $int > 1 )

        } ## end if ( "$sourceGrid" eq ...)
        else {    #ELSE NOT CUBIC

            my $tmpsrcstr = "$diag_source.nc";
            $csh .= <<EOF;
   foreach hDate ( @hDates )
      set nhistfiles = 0
      foreach file ( `ls \$histDir/\$hDate*/*.$tmpsrcstr`)
        ln -s \$file .
        @ nhistfiles ++
      end
      if ( \$nhistfiles == 0 ) then
         echo 'ERROR: No history files matching \$hDate*/*.$tmpsrcstr'
      endif
      $convertSeg
   end
EOF

            foreach my $season ( $startseason .. $totalseasons ) {
                my $startmo = $season * 3 - 4;
                my $plus    = "+";
                if ( "$startmo" =~ /^-/ ) { $plus = ''; }
                my $tSEASON = FREUtil::modifydate( $tBEG, "$plus $startmo months" );
                my $seahist  = FREUtil::graindate( $tSEASON, 'day' );
                my $tSEASONf = FREUtil::graindate( $tSEASON, 'seasonal' );
                my ($year)   = $tSEASONf =~ /(\d{4,})\./;
                my ($prevyear)   = $seahist =~ /(\d{4,})\d{4}/;
                my $prevhistcpio = "$prevyear" . $decSeg . ".nc.cpio";
                my $prevhisttar  = "$prevyear" . $decSeg . ".nc.tar";
                my $nextd = FREUtil::modifydate( $tSEASON, "+ 12 months" );
                my $nextdec = FREUtil::graindate( $nextd, 'day' ) . ".$diag_source.nc";
                my $hfilelist = "";

                foreach my $s ( $startmo .. ( $startmo + 2 ) ) {
                    my $plus = "+";
                    if ( "$s" =~ /^-/ ) { $plus = ''; }
                    my $t = FREUtil::modifydate( $tBEG, "$plus $s months" );
                    my $shist = FREUtil::graindate( $t, 'day' );
                    $hfilelist = "$hfilelist $shist.$diag_source.nc";
                }

                if ( $season == 1 ) {
                    $csh .= <<EOF;
echo season $season ==============================================================
if ( ! -e $seahist.$diag_source.nc ) then
   if ( -e $ppRootDir/.dec/$seahist.$diag_source.nc ) then
      $time_dmget dmget $ppRootDir/.dec/$seahist.$diag_source.nc
      $time_cp $cp $ppRootDir/.dec/$seahist.$diag_source.nc .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $ppRootDir/.dec/$seahist.$diag_source.nc .
         $checktransfer
      endif
      $time_rm rm -f $ppRootDir/.dec/$seahist.$diag_source.nc
   else if ( -e $opt_d/$prevhistcpio ) then
      $time_dmget dmget $opt_d/$prevhistcpio
      $time_uncpio $uncpio -ivI $opt_d/$prevhistcpio '*.$diag_source.nc'
      $check_cpio
      $time_dmput dmput $opt_d/$prevhistcpio
      set prevyear = $prevyear
      $convertDec
   else if ( -e $opt_d/$prevhisttar ) then
      $time_dmget dmget $opt_d/$prevhisttar
      $time_untar tar -xvf $opt_d/$prevhisttar --wildcards '*.$diag_source.nc'
      $check_cpio
      $time_dmput dmput $opt_d/$prevhisttar
      set prevyear = $prevyear
      $convertDec
   else
      set t = `ncdump -h $nextdec | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
      set att_copy = (`ncdump -h $nextdec | sed -ne "s/.*\${t}:\\(.*\\) =.*/\$t@\\1=\$t@\\1;/gp"`)
      #set hasAVT1 = `ncdump -v average_T1 $nextdec | wc -l`
      if ( `ncdump -h $nextdec | grep -c " average_T1("` == 1 ) then
         # A field with 'long_name =  "time axis boundary"' should be in
         # the file.  Be sure to use the same name in the following
         # commands.  We can rather safely assume the same field name
         # will be used in all the tile files.
         set tbnds_var = `ncdump -h $nextdec.tile1.nc | grep 'long_name = "time axis boundaries"' | awk -F : '{ print $1 }'`

         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${tbnds_var}=\${tbnds_var}-365; \$att_copy" $nextdec $seahist.$diag_source.nc
         $check_ncap
      else
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec $seahist.$diag_source.nc
         $check_ncap
      endif
   endif
endif
EOF
                } ## end if ( $season == 1 )
                else {
                    $csh .= <<EOF;
echo season $season ==============================================================
EOF
                }

                $csh .= <<EOF;
if ( -e sea.nc ) $time_rm rm -f sea.nc
$time_ncrcat ncrcat \$ncrcatopt $hfilelist sea.nc
$check_ncrcat
$time_rm rm -f $hfilelist
EOF

                #put code here to handle 1yr seasons case
                if ( $int == 1 ) {
                    my $compress = compress_csh( "$component.$tSEASONf.nc", $check_nccopy );
                    if ($do_zInterp) {
                        $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels.nc sea.nc
$check_timavg

EOF
                        $csh .= zInterpolate( $zInterp, 'modellevels.nc', "$component.$tSEASONf.nc",
                            $caltype, $variables, $component );
                        $csh .= <<EOF;
$compress
$time_mv $mvfile $component.$tSEASONf.nc \$outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$tSEASONf.nc \$outdir/
   $checktransfer
endif

EOF
                    } ## end if ($do_zInterp)
                    else {
                        $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$tSEASONf.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$tSEASONf.nc sea.nc
$check_timavg
$compress
$time_mv $mvfile $component.$tSEASONf.nc \$outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$tSEASONf.nc \$outdir/
   $checktransfer
endif
$time_rm rm $component.$tSEASONf.nc
if ( -e \$outdir/$component.$tSEASONf.nc ) $time_rm rm -f sea.nc
EOF
                    }
                } ## end if ( $int == 1 )
                else {
                    $csh .= <<EOF;
$time_timavg \$TIMAVG -o out/$component.$tSEASONf.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o out/$component.$tSEASONf.nc sea.nc
$check_timavg
if ( -e out/$component.$tSEASONf.nc ) $time_rm rm -f sea.nc
EOF
                }
            } ## end foreach my $season ( $startseason...)

            my $startmo = ( $totalseasons + 1 ) * 3 - 4;
            my $tSEASON = FREUtil::modifydate( $tBEG, "+ $startmo months" );
            my $nextdec = FREUtil::graindate( $tSEASON, 'day' ) . ".$diag_source.nc";
            $csh .= <<EOF;
$time_mv $mvfile $nextdec $ppRootDir/.dec/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $nextdec $ppRootDir/.dec/
   $checktransfer
endif
$time_rm rm $nextdec
cd out
EOF

            if ( $int > 1 ) {
                foreach my $season ( 'DJF', 'MAM', 'JJA', 'SON' ) {
                    my $dates = "$range" . ".$season";
                    $csh .= <<EOF;
echo season $season =========================================================
test $int = `ls -1 $component.*.$season.nc | wc -l`
$check_numfiles
set list = `ls -1 $component.*.$season.nc`
if ( -e sea.nc ) $time_rm rm -f sea.nc
$time_ncrcat ncrcat \$ncrcatopt \$list sea.nc
$check_ncrcat
$time_rm rm -f \$list
EOF

                    if ($do_zInterp) {
                        $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels.nc sea.nc
$check_timavg

EOF
                        $csh .= zInterpolate( $zInterp, 'modellevels.nc', "$component.$dates.nc",
                            $caltype, $variables, $component );
                    }
                    else {
                        $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$dates.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$dates.nc sea.nc
$check_timavg
EOF
                    }

                    my $compress = compress_csh( "$component.$dates.nc", $check_nccopy );

                    $csh .= <<EOF;
$time_ncatted ncatted -h -O -a filename,global,m,c,"\$outdir/$component.$dates.nc" $component.$dates.nc
$check_ncatted
$compress
$time_mv $mvfile $component.$dates.nc \$outdir/$component.$dates.nc
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$dates.nc \$outdir/$component.$dates.nc
   $checktransfer
endif
$time_rm rm $component.$dates.nc
$time_dmput dmput \$outdir/$component.$dates.nc
$time_rm rm sea.nc
EOF
                } ## end foreach my $season ( 'DJF',...)
            } ## end if ( $int > 1 )

            #END NOT CUBIC
        } ## end else [ if ( "$sourceGrid" eq ...)]

        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);

        return $csh;
    } ## end sub seasonalAVfromhist

    #TIMEAVERAGES - SEASONAL (doesn't support cubedsphere)
    sub seasonalAVfromav {

        #taNode = $_[0] ;
        my $sim0    = $_[1];
        my $subint  = $_[2];
        my $ppcNode = $_[0]->parentNode;

        my $src         = 'seasonal';
        my $interval    = $_[0]->findvalue('@interval');
        my $outdir      = "$ppRootDir/$component/av/$src" . "_$interval";
        my $srcdir      = "$ppRootDir/$component/av/$src" . "_$subint" . "yr";
        my $chunkLength = $_[0]->findvalue('@chunkLength');
        my $tmp         = FREUtil::modifydate( $tEND, "+ 1 sec" );
        my $yrsSoFar    = &Delta_Format( FREUtil::dateCalc( $sim0, $tmp ), 0, "%yd" );
        my $int         = $interval;
        $int =~ s/yr//;
        my $mod = $yrsSoFar % $int;
        unless ( $mod == 0 ) { return ""; }
        $mkdircommand .= "$outdir ";
        if ( $int > $maxyrs ) { $maxyrs = $int; }

        #check for missing files
        my $diag_source = $_[0]->findvalue('@diagSource');
        my @monthnodes  = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
        if ( scalar @monthnodes and "$diag_source" eq "" ) {
            my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
            $diag_source = $monthnode->getAttribute('@source');
        }
        if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
        if ( "$diag_source" eq "" ) { $diag_source = $component . "_month"; }

        my $end = FREUtil::graindate( $tEND, 'year' );
        my $start = FREUtil::padzeros( $end - $int + 1 );

        my $substart = $start;
        my $subend   = FREUtil::padzeros( $start + $subint - 1 );
        my $filelist = "";
        my $getlist  = "";
        until ( $subend > $end ) {
            if   ( $substart == $subend ) { $filelist .= "$component.$substart.\$sea.nc "; }
            else                          { $filelist .= "$component.$substart-$subend.\$sea.nc "; }
            $substart = FREUtil::padzeros( $substart + $subint );
            $subend   = FREUtil::padzeros( $subend + $subint );
        }
        my $getlist = $filelist;
        $getlist =~ s/\$sea/*/g;

        #   print "filelist is $filelist\n";
        #   print "getlist is $getlist\n";

        my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
        my $check_ncrcat  = errorstr("NCRCAT ($component $src $interval averages)");
        my $check_timavg  = retryonerrorend("TIMAVG ($component $src $interval averages)");
        my $retry_timavg  = retryonerrorstart("TIMAVG");
        my $check_dmget   = errorstr("DMGET ($component $src $interval averages)");
        my $check_nccopy  = errorstr("NCCOPY ($component $src $interval averages)");
        my $csh           = setcheckpt("seasonalAVfromav_$interval");
        $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages from $subint yr averages)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir

EOF
        if ($opt_z) { $csh .= begin_systime(); }
        my $compress = compress_csh( "$component.$start-$end.\$sea.nc", $check_nccopy );
        $csh .= <<EOF;

cd $srcdir
$time_dmget dmget "$getlist"

foreach sea (DJF MAM JJA SON)
     cd \$work
     foreach file ($filelist)
        $time_cp $cp $srcdir/\$file .
        if ( \$status ) then
           echo "WARNING: data transfer failure, retrying..."
           $time_cp $cp $srcdir/\$file .
           $checktransfer
        endif
     end
     if ( -e \$sea.nc ) rm -f \$sea.nc
     $time_ncrcat ncrcat \$ncrcatopt $filelist \$sea.nc
     $check_ncrcat
     $time_timavg \$TIMAVG -o $component.$start-$end.\$sea.nc \$sea.nc
     $retry_timavg
        $time_timavg \$TIMAVG -o $component.$start-$end.\$sea.nc \$sea.nc
     $check_timavg
     $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$start-$end.\$sea.nc" $component.$start-$end.\$sea.nc
     $check_ncatted
     $compress
     $time_mv $mvfile $component.$start-$end.\$sea.nc \$outdir/$component.$start-$end.\$sea.nc
     if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $component.$start-$end.\$sea.nc \$outdir/$component.$start-$end.\$sea.nc
         $checktransfer
     endif
     $time_rm rm $component.$start-$end.\$sea.nc
     $time_dmput dmput \$outdir/$component.$start-$end.\$sea.nc
     $time_rm rm -f \$sea.nc
end

EOF

        if ($opt_z) { $csh .= end_systime(); }
        $csh .= mailerrors($outdir);

        return $csh;
    } ## end sub seasonalAVfromav

    #hsmget history data into work area
    #provide directory for user to put new history files
    #run user scripts
    #package the new data into new history file
    sub refineDiag {
        my ( $tmphistdir, $stdoutdir, $ptmpDir, $basedate, $refinedir, $gridspec, $mdbi ) = @_;

        my $newhistorydir = "$opt_d" . "_refineDiag";
        my $csh           = <<EOF;

set refineRequestsExit = 0
set refineError = 0
#make additional data available to the refineDiag user scripts
set basedate = '$basedate'
set gridspec = '$gridspec'

set historyyear = `echo $hDate | sed 's/[0-9][0-9][0-9][0-9]\$//'`
cd \$histDir
foreach historyfile ( `ls \$historyyear????.nc.cpio \$historyyear????.nc.tar`)
   set hsmdate = \$historyfile:r

   #set up refineDiag input data and output directory
   set refineDiagDir = "$tmphistdir/history_refineDiag/\$hsmdate"
   mkdir -p \$refineDiagDir

   $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w \$work \$hsmdate/\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w \$work \$hsmdate/\\*
      $checktransfer
   endif
   cd \$work/\$hsmdate
EOF

        my @refineScripts = split ',', $opt_D;
        foreach my $s (@refineScripts) {
            if ( !-e "$s" ) { die "ERROR: Your refineDiag script does not exist: $s\n"; }
            $csh .= <<EOF;
   #source user refineDiag script: $s
   source $s
   set refineStatus = \$status
   if ( \$refineStatus < 0 ) then
      echo "NOTE: RefineDiag script $s requested no further processing after refineDiag scripts complete"
      set refineRequestsExit = 1
   else if ( \$refineStatus ) then
      echo "ERROR: RefineDiag script got an error status \$refineStatus"
      set refineError = 1
   endif

EOF
        }

        $csh .= <<EOF;

   #append the new variables to the refineDiag.log file
   cd \$refineDiagDir
   set refinedCount = `ls -1 *nc | wc -l`
   if ( \$refinedCount ) then

      foreach refinedFile ( `ls *nc` )
         echo "$refinedir/\$hsmdate.tar,\$refinedFile" >> $stdoutdir/postProcess/refineDiag.log
         \$NCVARS -st01234 \$refinedFile >> $stdoutdir/postProcess/refineDiag.log
      end

      #save new or modified refineDiag history file
      if ( -f $newhistorydir/\$hsmdate.tar ) then
         $time_hsmget \$hsmget -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/modify_refineDiag \$hsmdate/\\*
         if ( \$status ) then
            echo "WARNING: hsmget reported failure, retrying..."
            $time_hsmget \$hsmget -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/modify_refineDiag \$hsmdate/\\*
            $checktransfer
         endif
         mv -f * $tmphistdir/modify_refineDiag/\$hsmdate/
         mv -f $tmphistdir/modify_refineDiag/\$hsmdate/* .
         rm -rf $tmphistdir/modify_refineDiag
         $time_hsmput \$hsmput -s tar -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/history_refineDiag \$hsmdate
         if ( \$status ) then
            echo "WARNING: hsmput reported failure, retrying..."
            $time_hsmput \$hsmput -s tar -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/history_refineDiag \$hsmdate
            $checktransfer
         endif
      else
         $time_hsmput \$hsmput -s tar -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/history_refineDiag \$hsmdate
         if ( \$status ) then
            echo "WARNING: hsmput reported failure, retrying..."
            $time_hsmput \$hsmput -s tar -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/history_refineDiag \$hsmdate
            $checktransfer
         endif
      endif
   endif
end

if ( \$refineError ) exit \$refineError
if ( \$refineRequestsExit ) exit 0

EOF

        return $csh;
    } ## end sub refineDiag

 #write c-shell runscript, chmod, and optionally submit
    sub writescript {
        my ($script, $outscript, $batchCmd, $statefile) = @_;

        #print "Preparing '$batchCmd'\n";

        ( my $volume, my $directory, my $filename ) = File::Spec->splitpath($outscript);
        if ( !-e $directory ) { mkdir $directory || die "Cannot make directory $directory\n"; }

	$script =~ s|(#SBATCH --comment)=?(.*)|$1=$2,epmt| if $opt{epmt};

        open( OUT, "> $outscript" );
        print OUT $script;
        close(OUT);

	epmt_transform($outscript) if $opt{epmt};

        my $status = system("chmod 755 $outscript");
        if ($status) { die "Sorry, I couldn't chmod $outscript"; }

        if ($opt_s) {
            $batchCmd = "sleep 2;$batchCmd";
            print "\nExecuting '$batchCmd $outscript'\n" if $opt_v;
            my $batch_submit_output = `$batchCmd $outscript`;
            print "\n$batch_submit_output";

            $batch_submit_output =~ s/^$//mg;
            my ($newjobid) = (split '\n', $batch_submit_output)[-1] =~ /Submitted batch job (\d+)/;

            #print "New jobid='$newjobid'\n";
            if ( ! $newjobid and ! $batch_submit_output) {
                print "No jobid resulted from the job submission of $hDate.\n";
                print "ERROR: Unable to submit job, exiting.\n";
                exit 1;
            }
            elsif ( ! $newjobid  ) {
                print
                    "ERROR: the jobid returned has the wrong format: a frepp or batch system issue occurred.\n";
                exit 1;
            }
            if ( "$statefile" ne "" ) {
                open( STATEFILE, ">$statefile" ) or die $!;
                print STATEFILE "$newjobid\n";
                close STATEFILE;
            }

        } ## end if ($opt_s)
        else {
            print "TO SUBMIT: $batchCmd $outscript\n";
        }
    } ## end sub writescript

    sub getTemplate {
        my $platform = $_[0];

        my $cshscripttmpl = '';
        if ( "$platform" eq 'x86_64' ) {
            $cshscripttmpl = <<'EOF';
#!/bin/csh -f
#SBATCH --job-name
#SBATCH --time
#SBATCH --ntasks=1
#SBATCH --output
#SBATCH --chdir
#SBATCH --comment
#SBATCH --mail-type=NONE
#SBATCH --mail-user
#INFO:component=
#INFO:max_years=
EOF
            $cshscripttmpl .= <<EOF;

if ( \$?SLURM_JOBID ) then
    setenv JOB_ID \$SLURM_JOBID
else
    setenv JOB_ID `mktemp -u INT-XXXXXX`
endif

setenv FRE_STDOUT_PATH
if ( -d "$workdir" ) then
  rm -rf $workdir
endif
mkdir -p $workdir
EOF
        }

        $cshscripttmpl .= <<'EOF';
#=======================================================================
#version_info
#=======================================================================
unalias *
set echo
#get_site_config
########################################################################
#-------------------- variables set by script --------------------------
########################################################################
set name
set rtsxml
set work
set tempCache
set root
set archive
set scriptName
set oname
set ptmpDir
set histDir
set platform
set target
set segment_months
set prevjobstate
set statefile
set experID
set realizID
set runID
set tripleID

#platform_csh

#write_to_statefile

limit stacksize unlimited
setenv FMS_FRE_FREPP
set NCVARS = list_ncvars.csh
set TIMAVG = "timavg.csh -mb"
set PLEVEL = plevel.sh
set SPLITNCVARS = split_ncvars.pl
set MPPNCCOMBINE = mppnccombine
set FREGRID = fregrid
set checkptfile = $scriptName:t
set errors_found = 0
if (! -d $work) mkdir -p $work
if (! -d $tempCache) mkdir -p $tempCache
which ncks
which ncrcat

#set up HSM
set hsmget = "hsmget -v -m $FRE_COMMANDS_HOME/site/gfdl/hsmget.mk -t";
set hsmput = "hsmput -v -m $FRE_COMMANDS_HOME/site/gfdl/hsmput.mk -t";
if ( $?HSM_HOME ) then
   if ( -d $HSM_HOME ) then
     set hsmget = 'hsmget -v -t';
     set hsmput = 'hsmput -v -t';
   endif
endif

#checkpointing option to skip to certain point in script
set options = ( )
set argv = (`getopt g: $*`)
while ("$argv[1]" != "--")
    switch ($argv[1])
        case -g:
            set checkpt = $argv[2]; shift argv; breaksw
    endsw
    shift argv
end
shift argv

EOF

        return $cshscripttmpl;
    } ## end sub getTemplate

    sub segmentLengthInMonths {
        my ( $segTime, $segUnits ) = getSegmentLength();
        return $segTime if $segUnits eq 'months';
        return $segTime * 12 if $segUnits eq 'years';
        print STDERR
            "WARNING: Unable to convert segment unit $segUnits into months; setting segment_months = 1";
        return 1;
    }

    sub getSegmentLength {
        my ( $segTime, $segUnits );
        if ($opt_S) {
            $segTime  = $opt_S;
            $segUnits = "months";
        }
        else {
            $segTime  = FREUtil::getxpathval('runtime/production/segment/@simTime');
            $segUnits = FREUtil::getxpathval('runtime/production/segment/@units');
            if ( "$segUnits" eq "month" ) { $segUnits = "months"; }
            if ( "$segUnits" eq "year" )  { $segUnits = "years"; }
        }
        return ( $segTime, $segUnits );
    }

    sub epmt_transform {
	my $scriptfile = shift;
	papiex_tag_file($scriptfile, $fre->property('FRE.tool.modules.use'));
	rename("$scriptfile.tags", $scriptfile);
    }
}

__END__
__Python__

import re

# Set up postp operation dictionaries
cp = {'op_name' : 'cp',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for cp:        real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:cp;op_instance:OP_INSTANCE";'}
dmput = {'op_name' : 'dmput',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for dmput:     real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:dmput;op_instance:OP_INSTANCE";'}
dmget = {'op_name' : 'dmget',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for dmget:     real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:dmget;op_instance:OP_INSTANCE";'}
fregrid = {'op_name' : 'fregrid',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for fregrid:   real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:fregrid;op_instance:OP_INSTANCE";'}
hsmget = {'op_name' : 'hsmget',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for hsmget:    real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:hsmget;op_instance:OP_INSTANCE";'}
hsmput = {'op_name' : 'hsmput',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for hsmput:    real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:hsmput;op_instance:OP_INSTANCE";'}
gcp = {'op_name' : 'gcp',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for gcp:       real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:gcp;op_instance:OP_INSTANCE";'}
mv = {'op_name' : 'mv',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for move:      real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:mv;op_instance:OP_INSTANCE";'}
ncatted = {'op_name' : 'ncatted',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for ncatted:   real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:ncatted;op_instance:OP_INSTANCE";'}
nccopy = {'op_name' : 'nccopy',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for nccopy:    real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:nccopy;op_instance:OP_INSTANCE";'}
ncks = {'op_name' : 'ncks',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for ncks:      real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:ncks;op_instance:OP_INSTANCE";'}
ncrcat = {'op_name' : 'ncrcat',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for ncrcat:    real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:ncrcat;op_instance:OP_INSTANCE";'}
plevel = {'op_name' : 'plevel',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for plevel:    real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:plevel;op_instance:OP_INSTANCE";'}
rm = {'op_name' : 'rm',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for remove:    real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:rm;op_instance:OP_INSTANCE";'}
splitvars = {'op_name' : 'splitvars',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for splitvars: real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:splitvars;op_instance:OP_INSTANCE";'}
tar = {'op_name' : 'tar',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for tar:       real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:tar;op_instance:OP_INSTANCE";'}
timavg = {'op_name' : 'timavg',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for timavg:    real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:timavg;op_instance:OP_INSTANCE";'}
untar = {'op_name' : 'untar',
    'op_instance' : 0,
    's_string' : '/usr/bin/time -f "     TIME for untar:     real %e user %U sys %S"',
    'r_string' : 'setenv PAPIEX_TAGS "op:untar;op_instance:OP_INSTANCE";'}

op_list = [
    cp,
    dmput,
    dmget,
    fregrid,
    hsmget,
    hsmput,
    gcp,
    mv,
    ncatted,
    nccopy,
    ncks,
    ncrcat,
    plevel,
    rm,
    splitvars,
    tar,
    timavg,
    untar
]

jtag_dict = {'exp_name' : 'set name =',
             'exp_component' : '#INFO:component=',
             'exp_time' : 'set oname =',
             'exp_platform' : 'set platform =',
             'exp_target' : 'set target =',
             'exp_seg_months' : 'set segment_months ='}

def papiex_tag_file(fin_name, fms_modulefiles):

    fout_name = fin_name + '.tags'

    # Read in the file
    with open(fin_name, 'r') as file :
        script = file.read()

    # Replace the timing string with the PAPIEX_TAGS template string
    for op in op_list:
        script = script.replace(op['s_string'],op['r_string'])

    lines = script.splitlines()
    del script

    script = []
    pline = ''
    first_time = True

    # Reset op_instance (cnt) for each file
    for op in op_list:
        op['op_instance'] = 0

    # Reset the EPMT_JOB_TAGS root
    EPMT_JOB_TAGS = "epmt annotate EPMT_JOB_TAGS='"

    # Since all the information needed is in the top of the file, form the EPMT_JOB_TAG first
    sname = {}
    for line in lines:
      # No information of interest after this line
      if '#platform_csh' in line: break
      for k,v in jtag_dict.items():
        if v in line:
          l = len(v)
          EPMT_JOB_TAGS = EPMT_JOB_TAGS + k + ":" + line[l:].lstrip() + ";"
          if k == 'exp_name': sname['exp_name'] = line[l:].lstrip()
          if k == 'exp_component': sname['exp_component'] = line[l:].lstrip()
          if k == 'exp_time': sname['exp_time'] = line[l:].lstrip()

    EPMT_JOB_TAGS = EPMT_JOB_TAGS + 'script_name:' \
                                  + sname['exp_name'] +"_" \
                                  + sname['exp_component'] +"_" \
                                  + sname['exp_time'] + "'"

    epmt_instrument = 'setenv PAPIEX_OPTIONS $PAPIEX_OLD_OPTIONS; setenv LD_PRELOAD $PAPIEX_LD_PRELOAD; setenv PAPIEX_OUTPUT $PAPIEX_OLD_OUTPUT;'
    epmt_uninstrument = 'unsetenv PAPIEX_OUTPUT PAPIEX_OPTIONS LD_PRELOAD'


    for line in lines:

        # Place the EPMT_JOB_TAGS
        if '#INFO:max_years' in pline:
           script.append('')
           script.append('source $MODULESHOME/init/csh')
           script.append('module use ' + fms_modulefiles)
           script.append('module load epmt')
           script.append('set PAPIEX_OLD_OUTPUT=$PAPIEX_OUTPUT')
           script.append('set PAPIEX_OLD_OPTIONS=$PAPIEX_OPTIONS')
           script.append(epmt_uninstrument)
           script.append(EPMT_JOB_TAGS)
           script.append(epmt_instrument)
           script.append('')

        # Refine the PAPIEX_TAGS for a particular operation
        if "PAPIEX_TAGS" in line:
            # Is this operation actually a retrun of the previous? If so, mark as such. 
            # Note that the operations sequence value is *not* incremented. This is
            # intended to assist in identifying operation correlations and/or
            # pathologies across jobs that should be similar.
            if 'failure, retrying' in pline:
                retry = ';retry:1'
            else:
                retry = ''
            # Increment the operation instance. 
            # op_instance correlates to a specific line in the script.
            this_op = re.search('PAPIEX_TAGS "op:(.*);op_instance:OP_INSTANCE',line)
            this_op = this_op.group(1)
            for op in op_list:
                if this_op == op['op_name']:
                    op['op_instance'] += 1
                    line = line.replace("OP_INSTANCE",str(op['op_instance'])+retry)
        script.append(line)
        pline = line

    script[-1] += '\n'

    # Write the file out again
    with open(fout_name, 'w') as file:
        file.write('\n'.join(script))

    del script

