#!/usr/bin/perl
# -*- cperl -*-
# $Id: frepp,v 18.0.2.52.2.1.2.89.2.74 2014/12/17 15:42:41 arl Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: History/diagnostics post-processing
# ------------------------------------------------------------------------------

use strict;
use File::Spec;
use File::Temp;
#use File::stat;
use File::Basename;
use Text::Wrap;
use Getopt::Long(':config', 'no_ignore_case');
use Date::Manip;
use XML::LibXML;

use lib (File::Basename::fileparse(File::Spec->rel2abs($0)))[1] . "../lib";
use FRE();
use FREExperiment();
use FREAnalysis qw(analysis);
use FREUtil;
use FRETargets qw(standardize);

use Config;
use lib "/app/perl/lib/perl5/$Config{version}";
use lib "/app/perl/lib/perl5/site_perl/$Config{version}";
use lib "/app/perl/lib64/perl5/$Config{version}/$Config{archname}";
use lib "/app/perl/lib64/perl5/site_perl/$Config{version}/$Config{archname}";
use Env::Modulecmd;
Env::Modulecmd::load ('moab');


use vars qw( $expt $nml $err $username %dtvars $root);
use vars qw( $mkdircommand $hDate $t0 $tEND $sim0 $ppRootDir $component $cpiomonTS $aggregateTS $historyfiles);
use vars qw( $do_static $segTime $segUnits $caltype);
use vars qw( $analysisdir $absfrepp $relfrepp $perlerrors );
use vars qw( $archivedir $rootdir $workdir $tempCache $rtsVersion $platform $versionId $batchSubmit );
use vars qw( $maxyrs $maxdisk $cubic $nlat $nlon $interpMethod $getgridspec $basenpes $call_fregrid );
use vars qw( $checktransfer $statefile $state $writestate $didsomething $userstartyear $userstartmo $call_tile_fregrid );
use vars qw( $mosaic_type $sourceGrid $xyInterp $xyInterpRegridFile );

{

  package frepp;

  use constant VERSION => '$Id: frepp,v 18.0.2.52.2.1.2.89.2.74 2014/12/17 15:42:41 arl Exp $';

#Usage:    $relfrepp [ -AB:C:O:RY:Z:c:d:f:hlmMp:oqr:S:st:u:vx:z ] experiment [ experiment2 ... ]
  use constant OPTLIST =>
  (
      'forceCombine|f',
      'time|t=s',
      'component|c=s',
      'limitstatic|l',
      'dir|history|d=s',
      'unique|u=s',
      'moab|m=s',
      'override|o',

      'wait|w=s',
      'plus|p=i',

      'refineDiag|D:s',
      'refineDiagOnly|H',

      'AnalysisOnly|A',
      'Regenerate|R',
      'OutputFigureDir|O=s',
      'AnalysisStartYear|Y=s',
      'AnalysisEndYear|Z=s',

      'MailOnComplete|M',
      'Walltime|W=s',
      'debug|Q',
      'quiet|q',
      'verbose|v',
      'VeryVerbose|V',

      'help|h',
      'runparams|r=s',
      'submit|s',
      'xmlfile|x=s',
      'platform|Platform|P=s',
      'target|Target|T=s',

      'Calendar|C=s',
      'Basedate|B=s',
      'Segment|S=s',
      'oldStyleTimestamps|e',
      'statistics|z',
      'mppnccombine-opts=s'
  );

}

{

   my %opt =
   (
     'platform'  => FREDefaults::Platform(),
     'xmlfile'   => FREDefaults::XMLFile(),
     'target'    => FREDefaults::Target()
   );

   Getopt::Long::GetOptions(\%opt, frepp::OPTLIST) or (print 'bad opts' and die "\n");
   if ($opt{Version}) {print frepp::VERSION,"\n" and exit(0);}
   use vars qw( $opt_d $opt_D $opt_f $opt_l $opt_p $opt_M $opt_m $opt_q $opt_Q $opt_t $opt_r $opt_x $opt_s $opt_v $opt_V  $opt_A $opt_B $opt_C $opt_O $opt_R $opt_S $opt_Y $opt_Z $opt_c $opt_H $opt_h $opt_o $opt_u $opt_z $opt_w $opt_P $opt_T );
   $opt_d=($opt{dir} =~ s|\/$||g);
   $opt_f=$opt{forceCombine};
   $opt_l=$opt{limitstatic};
   $opt_o=$opt{override};
   $opt_p=$opt{plus};
   $opt_M=$opt{MailOnComplete};
   $opt_m=$opt{moab};
   $opt_q=$opt{quiet};
   $opt_Q=$opt{debug};
   $opt_t=$opt{time};
   $opt_r=$opt{runparams};
   $opt_x=$opt{xmlfile};
   $opt_s=$opt{submit};
   $opt_v=$opt{verbose};
   $opt_V=$opt{VeryVerbose};
   $opt_A=$opt{AnalysisOnly};
   $opt_B=$opt{Basedate};
   $opt_C=$opt{Calendar};
   $opt_O=$opt{OutputFigureDir};
   $opt_R=$opt{Regenerate};
   $opt_S=$opt{Segment};
   $opt_Y=$opt{AnalysisStartYear};
   $opt_Z=$opt{AnalysisEndYear};
   $opt_c=$opt{component};
   $opt_H=$opt{refineDiagOnly};
   $opt_h=$opt{help};
   $opt_u=$opt{unique};
   $opt_z=$opt{statistics};
   $opt_D=$opt{refineDiag};
   $opt_w=$opt{wait};
   $opt_P=$opt{platform};
   $opt_T=$opt{target};

   ################### PROCESS ARGS, SET DEFAULTS #########################
   if ( -l $0 ) {
   $absfrepp = File::Spec->rel2abs( readlink($0) );
   } else {
   $absfrepp = File::Spec->rel2abs( $0 );
   }
   $relfrepp = basename($absfrepp);

   #getopts( 'AB:C:O:RY:Z:c:d:f:hlmMp:oqr:S:st:u:vVx:z' ) || die "\aSyntax: $0 [-AB:C:O:RY:Z:c:d:f:hlmMp:oqr:S:st:u:vVx:z]\n";

   if ( $opt_h or "$#ARGV" eq "-1" ) {
   print <<EOF;

Synopsis: $relfrepp is the FRE postprocessing utility.

Usage:    $relfrepp [ -AB:C:O:RY:Z:c:d:f:hlmMp:oqr:S:st:u:vx:z ] experiment [ experiment2 ... ]

          OPTIONS FOR COMBINING MULTIPROCESSOR HISTORY FILES
          -f           = force combine of all "raw" history data and then exit

          OPTIONS FOR REFINING HISTORY FILES BEFORE POSTPROCESSING
          -D script    = comma separated list of scripts to run on history data
          -H           = refineDiag only: do not do regular frepp processing

          OPTIONS FOR POSTPROCESSING DATA
          -t time      = beginning of model year to process.  To process 1982, use
                           '-t 1982' or '-t 19820101'.
          -p num       = "plus num years": additional years to process: OPTION NO LONGER SUPPORTED
          -c component = component to process, or keyword 'split' to process all in parallel
          -l           = limit static variable processing to the diag source file in the xml
          -d dir       = path to history data
          -w jobid     = place hold on current job so that it waits for jobid to complete
                         (PP/AN cannot set holds based on job names, it is not supported by moab)
          -o           = override job dependencies

          OPTIONS FOR ANALYSIS FIGURES
          -A           = run analysis only
          -R           = regenerate, submit analysis scripts regardless of whether they already exist
          -O dir       = where to put output figures. This argument is normally
                         used with -A (run analysis only) and must be used if the
                         xml file is not yours.
          -Y year      = specify a four digit year as your analysis's start year, ex -Y 1984
                         This year overrides the startYear specifed in the <analysis> tag.
          -Z year      = specify a four digit year as your analysis's end year, ex -Z 1985
                         This year overrides the endYear specifed in the <analysis> tag.

          OPTIONS FOR TIMING/DEBUGGING/STATISTICS/SCHEDULING
          -M           = send mail to user when job is complete
          -m opts      = moab scheduler options for msub command
          -W time      = change the max wallclock time for the job, ie, -W 00:20:00
          -u label     = specify unique output dir. frepp -u 2 yields .../pp_2/...
          -Q           = don't print the error checks into the script.  For evaluating csh.
          -q           = don't print the analysis figure checks to stdout.
          -v           = verbose flag
          -V           = very verbose flag

          GENERAL FRE OPTIONS
          -h           = show this help message, then exit
          -r runparams = regression test run.  Combine netcdf files, but no further processing
          -s           = automatically submit the script to the batch scheduler
          -P platform  = platform (default on PP/AN: gfdl.default)
          -T target    = target (default on PP/AN: prod)
          -x xmlfile   = specify xml file (default: ./rts.xml)
          experiment   = experiment to create scripts for; must be found in xml file

EOF
   exit 1;
   }

   #still there but no longer advertised / DEBUGGING
   #          OPTIONS REQUIRED WHEN FULL XML IS NOT AVAILABLE
   #          -C calendar  = specify calendar type from coupler_nml, ie julian
   #          -B basedate  = specify reference date: initial date for simulation, ie "0 0 0 0 0 0"
   #                            from diag table date or coupler_nml current_date
   #          -S segment   = Segment length in months.  Supports 1,2,3,4,6 or 12.
   #setting this option inside script for now
   #          -z           = insert timing calls

   # Check of both -D and -r have been given
   print STDERR "WARNING: Both options -r and -D are given.  The -r option takes precedence.\n" if ( $opt_r and $opt_D );

   chomp( my $beginTime = `date +\%s` );

   $opt_x = 'rts.xml' unless $opt_x; #set default filename for experiments xml file
   if ( ! -f $opt_x ) {
   mailuser("XML file does not exist: $opt_x");
   sysmailuser();
   die "ERROR: XML file does not exist: $opt_x\n";
   }

   if ( !$opt_t or ("$opt_t" eq "") ) {
   print STDERR "WARNING: You did not specify a model date\n" unless $opt_A;
   }

   if ( $opt_V ) { $opt_v = 1; }

   if ( $opt_M and not $opt_p ) { $opt_M = "#\$ -m e";} else { $opt_M = ""; }

   if ( $opt_O ) { print STDERR "NOTE: There has been a change to the behavior of the -O option. Your scripts will be written directly to '$opt_O' and not to '$opt_O/scripts/postProcess'\n"; }

   unless ( $opt_c ) {
   print STDERR "NOTE: adding '-c split'; frepp will do each component in a separate batch job\n";
   $opt_c = 'split';
   }

   $versionId = ' $Id: frepp,v 18.0.2.52.2.1.2.89.2.74 2014/12/17 15:42:41 arl Exp $';

   $perlerrors = "";
   $component = "";
   $maxyrs=0;
   $maxdisk=0;
   $do_static = 1;
   $historyfiles="";
   %dtvars = ();
   $basenpes = 1;
   $aggregateTS = 1;
   $didsomething = 0;

   #initialize hsmfiles string
   my $hsmfiles="";

   #for grepping and sorting associated files
   my $grepAssocFiles = <<'EOF';
grep ':associated_files' | cut -d '"' -f2 | sed "s/\w*://g" | tr ' ' '\n' | sort -u
EOF
   chomp $grepAssocFiles;

#begin generating version string
my $abs_xml_path = File::Spec->rel2abs($opt_x);
my $createdate = Date::Manip::ParseDate('now');
my $version_head = "# FMS postprocessing script created at $createdate via:\n# $0 ";
$version_head .= "-x $abs_xml_path ";

   $username = $ENV{'USER'};


   #variables for timing statistics
   $opt_z = 1;
   if ($opt_Q) { $opt_z = 0; }
   my $time_ncatted = "";
   my $time_ncks = "";
   my $time_ncmerge = "";
   my $time_ncrcat = "";
   my $time_nccatm = "";
   my $time_plevel = "";
   my $time_splitncvars = "";
   my $time_timavg = "";
   my $time_uncpio = "";
   my $time_untar = "";
   my $time_mkcpio = "";
   my $time_mktar = "";
   my $time_taxis2mid = "";
   my $time_mv = "";
   my $time_rm = "";
   my $time_dmget = "";
   my $time_ncap = "";
   my $time_zgrid = "";
   my $time_dmput = "";
   my $time_cp = "";
   my $time_fregrid = "";
   my $time_ncrename = "";
   my $time_hsmget = "";
   my $time_hsmput = "";
   my $time_combine = "";

   # When frepp is run with -A option, the -t option is not required.
   # Then set the date to a valid date.  This isn't really ideal, but
   # this is how frepp did it in the past.
   if ($opt_t =~ /^$/ and $opt_A) {
     $opt_t = '00010101';
   }
   #clean up opt_t
   #
   # opt_t should be of the form \d{4,}\d{2}\d{2}.  It is possible a user
   # will pass in only a year (\d{4}).  As we move forward to allow for
   # years past 9999, we need to set some guidance on how opt_t is
   # interpreted.  Thus, we somewhat arbitrarily decide that if
   # length($opt_t) < 7, we assume a year has been passed in, 8 and
   # beyond, assume the from above.
   #
   # There should also be a method to correctly know how many digits are
   # in a year, when the year is needed later on in the script.
   #
   # $t0 holds $opt_t in the Date::Manip date format 'yyyymmddhh:mm:ss'
   $t0 = FREUtil::parseDate($opt_t);
   if ($t0 == undef) {
     print STDERR "ERROR: The date passed in via the '-t' option ('$opt_t') is not a valid date.\n";
     exit 1;
   }
   # Hold required information in the correct format in these three variables
   # should not use $opt_t anywhere as it may not have the correct format.
   ($userstartyear, $userstartmo) = $t0 =~ /(\d{4,})(\d{2}\d{2})\d{2}:\d{2}:\d{2}/;
   ($hDate) = $t0 =~ /(\d{4,}\d{4})\d{2}:\d{2}:\d{2}/;

   #assume we are processing 1 year
   $tEND = FREUtil::modifydate($t0,'+1 year -1 sec');
   if ( $opt_v ) {
     print "t0 is $t0 (from -t argument)\n";
     print "tEND is $tEND (from t0 + 1 year)\n";
   }


   #set default platform to ia64 for hpcs.*, x86_64 for gfdl.*
   $platform = 'ia64';
   if ( $opt_P =~ /^gfdl\./ ) { $platform = 'x86_64'; }
   chomp $platform;
   my $platformcsh;

   #These things vary by platform
   my $cp = 'cp';
   my $mv = 'mv';
   my $mvfile = 'mv';
   my $cpio = 'cpio';
   my $uncpio = 'cpio';
   my $timecmd = '/usr/bin/time';
   my $timereal = 'e';
   my $systimecmd = 'date +\%s';
   my $maxruntime = '60:00:00';  #needs work
   if ( "$opt{Walltime}" ne '' ) { $maxruntime = "$opt{Walltime}"; }

   #-------------- SET UP PARSER FOR XML DOCUMENT -------------------------
   #set up FRE4
   my $fre = FRE->new('frepp', %opt) or exit(1);

   $root = $fre->{rootNode};
   $rtsVersion = $fre->{version};
   if ( "$rtsVersion" eq "" ) {
   $rtsVersion = 1;
   print STDERR "WARNING: rtsVersion information not found in your xml file, assuming rtsVersion 1.\n";
   print STDERR "         The latest version available is version 2.  Automate conversion with\n";
   print STDERR "            /home/fms/bin/rtsversion2 [in.xml] [out.xml]\n";
   print STDERR "         Run '/home/fms/bin/rtsversion2' with no arguments for a help message.\n";
   } elsif ( $rtsVersion == 1 ) {
   print STDERR "NOTE: You are using rtsVersion 1.  A newer version is available.  \n";
   print STDERR "      The latest version available is version 2.  Automate conversion with\n";
   print STDERR "         /home/fms/bin/rtsversion2 [in.xml] [out.xml]\n";
   print STDERR "      Run '/home/fms/bin/rtsversion2' with no arguments for a help message.\n";
   } elsif ( "$rtsVersion" > "4" ) {
   print STDERR "WARNING: This frerun is designed for version 3/4 xml and your xml is version $rtsVersion.\n";
   }
   my $project = $fre->project();

   #------------ LOOP OVER EXPTS GIVEN AS SCRIPT ARGUMENTS ----------------
   foreach $expt ( @ARGV ) {
   print "Setting up experiment '$expt'...\n" if $opt_v;
   unless ( FREUtil::checkExptExists($expt) ) { next; }

   my $exp = FREExperiment->new($fre, $expt) or exit(1);
   $fre->setCurrentExperimentName($expt);
   # Get the refineDiag scripts from the XML if -D given
   # on the command line with no string
   if (defined($opt{refineDiag}) and not $opt_D) {
     $opt_D = join ',', $exp->extractPPRefineDiagScripts;
   }
   $rootdir = $exp->rootDir();
   if ( (! -d $rootdir) or (! -w $rootdir) and (! $opt_O) ) {
      system("mkdir -p $rootdir");
   }
   if ( (! -d $rootdir) or (! -w $rootdir) and (! $opt_O) ) {
      mailuser("Can't write to your root directory $rootdir");
      sysmailuser();
      die "ERROR: Can't write to your root directory $rootdir\n";
   }
   $workdir = $exp->workDir();
   $archivedir = $exp->archiveDir();
   my $postprocessdir = $exp->postProcessDir();
   my $analysisdir = $exp->analysisDir();
   my $scriptsdir = $exp->scriptsDir();
   my $stdoutdir = $exp->stdoutDir();
   my $ptmpDir = $exp->ptmpDir();
   my $tempCache = (split /\//,$workdir)[0] . "/tempCache";
   my $statedir = $exp->stateDir()."/postProcess";
   my $outscriptdir = "$scriptsdir/postProcess";
   if ( "$opt_u" ne '' ) {$outscriptdir .= "/$opt_u";}
   if ( $opt_O ) {$outscriptdir = "$opt_O";}
   unless ( -d "$outscriptdir" or $opt_A ) { system "mkdir -p $outscriptdir"; }
   unless ( -d "$stdoutdir/postProcess" or $opt_A ) { system "mkdir -p $stdoutdir/postProcess"; }
   if ( "$opt_u" ne '' ) { $statedir .= "/$opt_u"; }
   unless ( -d "$statedir" or $opt_A ) { system "mkdir -p $statedir"; }
   my $aoutscriptdir = "$scriptsdir/analysis";
   if ( $opt_O ) {$aoutscriptdir = "$opt_O";}
   my $shortxml = $abs_xml_path;
   $shortxml =~ s/.+\/(.+\.xml)(\.$expt\.o.+)?/$1/;
   #if ( -e "$archivedir/$shortxml" ) {
   #   print "Running ln -s $abs_xml_path $archivedir/$shortxml\n" if $opt_v;
   #   system("ln -s $abs_xml_path $archivedir/$shortxml");
   #}

   my $tmphistdir = "";
   if ( "$workdir" eq "" ) {
      die "ERROR: No workDir from xml\n";
      $tmphistdir = "\$TMPDIR/$expt"."_$hDate";
      $workdir = "\$TMPDIR/$expt"."_$hDate/work";
   } else {
      $tmphistdir = "$workdir/$expt"."_$hDate";
      $workdir = "$workdir/$expt"."_$hDate/work";
   }

   if ( !$opt_d ) {                #set appropriate history directory
      if ( $opt_r ) {
         $opt_d = "$archivedir/$opt_r/history";
      } else {
         $opt_d = "$archivedir/history";
      }
   }
   if ( "$opt_d" eq '$archive/$name/history' ) {
      $opt_d = "$archivedir/history";
   }
   my $histDir = $opt_d;
   if ( ! -d "$histDir" ) {
      print STDERR "\nNOTE: Creating history dir ($histDir)\n" if $opt_v;
      system "mkdir -p $histDir";
   }
   print "\nDIRECTORIES: FRE4\nworkdir $workdir\nrootdir $rootdir\narchivedir $archivedir\nanalysisdir $analysisdir\noutscriptdir $outscriptdir\naoutscriptdir $aoutscriptdir\nhistDir $histDir\nptmpDir $ptmpDir\nstatedir $statedir\n\n" if $opt_v;

   my $refinedir = "$opt_d"."_refineDiag";
   $ptmpDir .= $archivedir;
   if ( "$opt_u" ne '' ) { $ptmpDir .= "/$opt_u"; }

   #set whether to aggregate time series files in archive
   my $agg = FREUtil::getxpathval('postProcess/@archiveTimeSeries');
   if ( "$agg" eq 'byVariable' ) { $aggregateTS = 0; }

   #may need to change platform here
   my $freppplatform = FREUtil::getxpathval('postProcess/@platform');
   if ( "$freppplatform" ne "" and "$freppplatform" ne "$platform" ) {
      $platform = $freppplatform;
   }

   #set platform specific variables
   print STDERR "Using platform $platform\n" if $opt_v;
   $batchSubmit = "msub -d /home/$username/ ";
   if ( "$platform" eq 'sgi' ) {
      $cpio = 'cpio -C 524288';
      $cp = 'cp -b 2097152';
      $mv = 'mv -b 2097152';
      $mvfile = '/lopt/bin/mvfile';
      $timecmd = '/bin/time';
      $maxruntime = '18:00:00';
      $systimecmd = '/usr/etc/amtime1970';
      $timereal = 'E';
      $platformcsh = <<'EOF';
set path = (/usr/local/nco-3.0.1/bin/ /usr/local/netcdf-3.6.0-p1/bin $path)
setenv NETCDF_FFIOSPEC "cache:256:2"
set ncks = /usr/local/bin/ncks

#sanity check
which ncatted
EOF
   } elsif ( "$platform" eq 'ia64' ) {
      $batchSubmit = 'qsub';
      $cp = '/usr/cluster/bin/cxfscp';
      $cpio = 'cpio -C 524288';
      $uncpio = 'cpio -C 2097152';
      $mvfile = '/usr/cluster/bin/cxfscp';
      $platformcsh = $exp->fre->default_platform_csh . $exp->fre->platformValue('csh');
      $platformcsh .= <<'EOF';

setenv NC_BLKSZ 64K
set ncksopt = "-a -h -F --64bit --header_pad 16384"
set ncrcatopt = "-h -O --64bit -t 2 --header_pad 16384"
EOF
   } elsif ( "$platform" eq 'x86_64' ) {
      $cp = 'gcp -v';
      $cpio = 'cpio -C 524288';
      $uncpio = 'cpio -C 2097152';
      $mvfile = 'gcp -v';
      $platformcsh = $exp->fre->default_platform_csh . $exp->fre()->platformValue('csh');
      $platformcsh .= <<'EOF';

setenv NC_BLKSZ 64K
set ncksopt = "-a -h -F --64bit --header_pad 16384"
set ncrcatopt = "-h -O --64bit -t 2 --header_pad 16384"
EOF

   } elsif ( "$platform" eq 'ifc' ) {
   } else {
      mailuser("platform $platform not supported for postprocessing");
      print STDERR "ERROR: You specified '$freppplatform' for the post-processing platform in the <postProcess> tag.\nPlatform must be either 'ia64' or 'sgi' (for the Origins)\n";
   }

   if ( "$opt_w" ne '' ) {
      if ( "$platform" eq 'ia64' ) {
         $opt_w = " -hold_jid $opt_w";
      } else {
         $opt_w = " -l depend=afterok:$opt_w";
      }
   }


   # Job schooling is only available if queue is not stage
   #
   # If queue is one of the bigvftmp, the request the entire node, and tell
   # moab to use all the physical cores
   my $pbsqueue = '';
   my $pbsenv = $ENV{'PBS_ENVIRONMENT'};
   if ($pbsenv =~ m/^PBS_BATCH$/) {
     $pbsqueue = $ENV{'PBS_O_QUEUE'};
   } else {
     # get queue information from $opt_m
     ( $pbsqueue ) = $opt_m =~ m/-q +(\S+)/;
   }

   if ($pbsqueue =~ m/batch|bigvftmp/) {
     # Use job schooling
     # The moab -l options control the schooling
     my $moab_lopt = '';
     ( $moab_lopt ) = $opt_m =~ m/-l *(\S+)/;
     my @moab_lopts = split(',',$moab_lopt);

     my $hostname = $ENV{HOST};
     if ($hostname =~ m/^pp/ and !grep(/host=/,@moab_lopts)) {
       # if on one of the pp nodes, then set the -lhost moab option to the current
       # pp host, to continue the job schooling
       push @moab_lopts,"host=$hostname.princeton.rdhpcs.noaa.gov";
     }

     if ($pbsqueue =~ m/bigvftmp/) {
       $opt_m .= " -q boost_bigvftmp" unless ($opt_m =~ m/-q +\b.*bigvftmp\b/);
       push @moab_lopts,"naccesspolicy=singlejob" unless grep(/naccesspolicy=singlejob/,@moab_lopts);
       $basenpes = $fre->property('FRE.scheduler.bigvftmp.coresPerJob.max');
     } elsif ($pbsqueue =~ m/batch/) {
       unless ($opt_m =~ m/-q +\b.*batch\b/) {
         $opt_m .= " -q boost_batch";
       }
     }
     # Now reset the moab -l option
     if (scalar(@moab_lopts)>0) {
       # Remove any -l options already part of opt_m
       $opt_m =~ s/-l *\S+//;
       # put -l options back in
       $opt_m .= " -l ".join(',',@moab_lopts);
     }
   }

   #variables for timing statistics
   if ( $opt_z ) {
     $time_ncatted     = "$timecmd".' -f "     TIME for ncatted:   real %'."$timereal".' user %U sys %S"';
     $time_ncks        = "$timecmd".' -f "     TIME for ncks:      real %'."$timereal".' user %U sys %S"';
     $time_ncmerge     = "$timecmd".' -f "     TIME for ncmerge:   real %'."$timereal".' user %U sys %S"';
     $time_ncrcat      = "$timecmd".' -f "     TIME for ncrcat:    real %'."$timereal".' user %U sys %S"';
     $time_nccatm      = "$timecmd".' -f "     TIME for nccatm:    real %'."$timereal".' user %U sys %S"';
     $time_plevel      = "$timecmd".' -f "     TIME for plevel:    real %'."$timereal".' user %U sys %S"';
     $time_splitncvars = "$timecmd".' -f "     TIME for splitvars: real %'."$timereal".' user %U sys %S"';
     $time_timavg      = "$timecmd".' -f "     TIME for timavg:    real %'."$timereal".' user %U sys %S"';
     $time_uncpio      = "$timecmd".' -f "     TIME for uncpio:    real %'."$timereal".' user %U sys %S"';
     $time_untar       = "$timecmd".' -f "     TIME for untar:     real %'."$timereal".' user %U sys %S"';
     $time_mkcpio      = "$timecmd".' -f "     TIME for mkcpio:    real %'."$timereal".' user %U sys %S"';
     $time_mktar       = "$timecmd".' -f "     TIME for mktar:     real %'."$timereal".' user %U sys %S"';
     $time_taxis2mid   = "$timecmd".' -f "     TIME for taxis2mid: real %'."$timereal".' user %U sys %S"';
     $time_mv          = "$timecmd".' -f "     TIME for move:      real %'."$timereal".' user %U sys %S"';
     $time_rm          = "$timecmd".' -f "     TIME for remove:    real %'."$timereal".' user %U sys %S"';
     $time_dmget       = "$timecmd".' -f "     TIME for dmget:     real %'."$timereal".' user %U sys %S"';
     $time_ncap        = "$timecmd".' -f "     TIME for ncap:      real %'."$timereal".' user %U sys %S"';
     $time_zgrid       = "$timecmd".' -f "     TIME for zgrid:     real %'."$timereal".' user %U sys %S"';
     $time_dmput       = "$timecmd".' -f "     TIME for dmput:     real %'."$timereal".' user %U sys %S"';
     $time_cp          = "$timecmd".' -f "     TIME for cp:        real %'."$timereal".' user %U sys %S"';
     $time_fregrid     = "$timecmd".' -f "     TIME for fregrid:   real %'."$timereal".' user %U sys %S"';
     $time_ncrename    = "$timecmd".' -f "     TIME for ncrename:  real %'."$timereal".' user %U sys %S"';
     $time_hsmget      = "$timecmd".' -f "     TIME for hsmget:    real %'."$timereal".' user %U sys %S"';
     $time_hsmput      = "$timecmd".' -f "     TIME for hsmput:    real %'."$timereal".' user %U sys %S"';
     $time_combine     = "$timecmd".' -f "     TIME for combine:   real %'."$timereal".' user %U sys %S"';
  }

   my $version_info = "$version_head";
   if ( $opt_f ) { $version_info .= "-f "; }
   if ( $opt_P ) { $version_info .= "-P $opt_P "; }
   if ( $opt_T ) { $version_info .= "-T $opt_T "; }
   if ( $opt_D ) { $version_info .= "-D $opt_D "; }
   if ( $opt_t ) { $version_info .= "-t $hDate "; } # Using corrected $opt_t value
   if ( $opt_p ) { $version_info .= "-p $opt_p "; }
   if ( $opt_c ) { $version_info .= "-c $opt_c "; }
   if ( $opt_d ) { $version_info .= "-d $opt_d "; }
   if ( $opt_u ) { $version_info .= "-u $opt_u "; }
   if ( $opt_r ) { $version_info .= "-r $opt_r "; }
   if ( $opt_H ) { $version_info .= "-H "; }
   if ( $opt_m ) { $version_info .= "-m '$opt_m' "; }
   $version_info .= "$expt";
   my $this_frepp_cmd = $version_info;
   $this_frepp_cmd =~ s/.*# //smg;

   my $outscript = "$outscriptdir/$expt";
   my $pbs_job_name = "$expt";

   if ( "$opt_u" ne '' ) {
     $pbs_job_name .= "_$opt_u";
   }

   if ( $opt_r ) {
      $outscript .= "_$opt_r";
      $maxruntime = "01:00:00";
      $pbs_job_name .= "_$opt_r";
   } elsif ( $opt_D ) {
      $outscript .= "_refineDiag";
      $pbs_job_name .= "_refineDiag";
   }
   $outscript .= "_$hDate";
   $pbs_job_name .= "_$hDate";

   my $cshscripttmpl = getTemplate($platform);

   #environment setup for FRE
   my $freCommandsHomeDir = FRE::home();
   my $siteconfig = <<EOF;
  setenv FRE_COMMANDS_HOME_FREPP $freCommandsHomeDir
EOF
   $cshscripttmpl =~ s/#get_site_config/$siteconfig/;

   #platform_csh_from_xml and check for FRE version mismatch
   if ( "$platformcsh" ne "" ) {
      $platformcsh = <<EOF;
#platform_csh_from_xml
$platformcsh
if ( "\$FRE_COMMANDS_HOME" != "\$FRE_COMMANDS_HOME_FREPP" ) then
  echo "ERROR: FRE version mismatch:"
  echo "       Frepp version: \$FRE_COMMANDS_HOME_FREPP"
  echo "       XML loads version: \$FRE_COMMANDS_HOME"
  exit 1
endif
EOF
      my $fremodule = `echo $ENV{LOADEDMODULES} | tr ':' '\n' | egrep '^fre/.+'`;
      chomp $fremodule;
      my $xmlfremodule = $platformcsh;
      my @fremodulecsh = ();
      # Loop through the CSH and remove all comments
      foreach ( split (/\n/, $xmlfremodule )){
          if ( $_ =~ /#/ ){
              my $noncomment = (split( /#/, $_))[0];
              if ( $noncomment =~ /\S/ ){
                  push @fremodulecsh, $noncomment;
              }
          } else {
              push @fremodulecsh, $_;
          }
      }
      $xmlfremodule = join( "\n", @fremodulecsh );
      $xmlfremodule =~ s/.*module load (fre\/\S+)\s*.*/$1/s;
      if ( "$fremodule" ne "$xmlfremodule" ) {
         print STDERR "ERROR: FRE version mismatch. Must use the same version of FRE in the shell and XML.\n";
         print STDERR "       frepp version: $fremodule\n";
         print STDERR "         xml version: $xmlfremodule\n";
         exit 1;
      }
   }
   $cshscripttmpl =~ s/#platform_csh_from_xml/$platformcsh/;

   if ( "$platform" eq 'ia64' ) {
      $cshscripttmpl =~ s/#\$ -l h_cpu/#\$ -l h_cpu=$maxruntime/;
      $cshscripttmpl =~ s/#\$ -o/#\$ -o $stdoutdir\/postProcess/;
   } else {
      $cshscripttmpl =~ s/#PBS -N/#PBS -N $pbs_job_name/;
      $cshscripttmpl =~ s/#PBS -l walltime/#PBS -l walltime=$maxruntime/;
      $cshscripttmpl =~ s/#PBS -o/#PBS -o $stdoutdir\/postProcess\//;
      $cshscripttmpl =~ s/setenv FRE_STDOUT_PATH/setenv FRE_STDOUT_PATH $stdoutdir\/postProcess\/$pbs_job_name.o\$JOB_ID/;
   }
   $cshscripttmpl =~ s/(-soft -l fre_info=)/$1ppVersion\@$relfrepp -hard/;
   $cshscripttmpl =~ s/version_info/$versionId\n$version_info/;
   $cshscripttmpl =~ s/set name/set name = $expt/;
   $cshscripttmpl =~ s/set rtsxml/set rtsxml = $abs_xml_path/;
   $cshscripttmpl =~ s/set work/set work = $workdir/;
   $cshscripttmpl =~ s/set tempCache/set tempCache = $tempCache/;
   $cshscripttmpl =~ s/set root/set root = $rootdir/;
   $cshscripttmpl =~ s/set archive/set archive = $archivedir/;
   $cshscripttmpl =~ s/set scriptName/set scriptName = $outscript/;
   $cshscripttmpl =~ s/set oname/set oname = $hDate/;
   $cshscripttmpl =~ s/set histDir/set histDir = $opt_d/;
   $cshscripttmpl =~ s/set ptmpDir/set ptmpDir = $ptmpDir/;
   $cshscripttmpl =~ s/set platform/set platform = $opt_P/;
   $cshscripttmpl =~ s/set target/set target = $opt_T/;

   if ( $opt_r ) {  #if a regression test, no further postprocessing
      $cshscripttmpl =~ s/(-soft -l fre_info=)/$1ppYears\@$maxyrs+/;
      writescript($cshscripttmpl,$outscript,"$batchSubmit$opt_w $opt_m",$statefile);
      $opt_w = '';
      next;
   }
   my $ppNode = FREUtil::getppNode($expt);
   unless ( $opt_f ) {
   unless ( $ppNode ) {  #if no pp node, no further postprocessing
      if ( "$platform" eq 'ia64' ) {
         $cshscripttmpl =~ s/#\$ -l h_cpu.*/#\$ -l h_cpu=01:00:00/;
      } else {
         $cshscripttmpl =~ s/#PBS -l walltime.*/#PBS -l walltime=01:00:00/;
      }
      $cshscripttmpl =~ s/(-soft -l fre_info=)/$1ppYears\@$maxyrs+/;
      writescript($cshscripttmpl,$outscript,"$batchSubmit$opt_w $opt_m",$statefile);
      $opt_w = '';
      next;
   }
   }
   if ( "$opt_M" ne "" ) {
      $cshscripttmpl =~ s/#\$ -r y/#\$ -r y\n$opt_M/;
   }

   #calendar
   if ( $opt_C ) {
      $caltype = $opt_C;
   } else {
      if ( $opt_v ) { print "Getting namelists...\n"; }
         $nml = $exp->extractNamelists();
         $caltype = $nml->namelistSingleQuotedStringGet("coupler_nml", "calendar") || "julian";
         print STDERR "caltype = $caltype\n" if $opt_v;
   }

   #diag table date -> sim0 (simulation begin date)
   my $basedate = "";
   my @diagtablecontent = split('\n',$exp->extractTable('diagTable'));
   if ( $opt_B ) {
      $basedate = $opt_B;
   } else {
      #look in coupler_nml if basedate set to $baseDate
      chomp( $basedate = $diagtablecontent[1] );
      $basedate =~ s/^\s*//g;
      if( "$basedate" eq "\$baseDate" ) {
         #$basedate = $nml->namelistSingleQuotedStringGet("coupler_nml", "current_date") || "0 0 0 0 0 0";

         $basedate = $nml->namelistGet("coupler_nml");
         if( "$basedate" eq "" ) {
            $basedate = "0 0 0 0 0 0";
         } else {
            $basedate =~ s/.*current_date\s*=\s*(\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+)\s*(.*)/$1/s;
            chomp $basedate;
            $basedate =~ s/^\s*//g;
         }
      }
   }
   print "basedate = $basedate\n" if $opt_v;

   my $gridspec = $exp->extractVariableFile('gridSpec');
   if ( "$gridspec" eq '' ) {
      die "ERROR: gridSpec for platform $opt_P was not found in $opt_x.\n";
   } elsif (! -e $gridspec) {
      die "ERROR: gridSpec file does not exist: $gridspec\n";
   } else {
      print STDERR "NOTE: Using gridSpec $gridspec\n" if $opt_v;
   }

   #if refineDiag run, insert refineDiag csh here
   if ( $opt_D ) {
      $cshscripttmpl .= refineDiag($tmphistdir,$stdoutdir,$ptmpDir,$basedate,$refinedir,$gridspec);
   }

   if ( $opt_f or $opt_D ) {
      #separate mppnccombine from rest of script due to splitting components
      unless ( $opt_H ) {
         $cshscripttmpl .= "\n/usr/bin/perl $absfrepp -x $abs_xml_path -t $hDate -s -v ";
         if ( $opt_P ) { $cshscripttmpl .= "-P $opt_P "; }
         if ( $opt_T ) { $cshscripttmpl .= "-T $opt_T "; }
         if ( $opt_d ) { $cshscripttmpl .= "-d $opt_d "; }
         if ( $opt_u ) { $cshscripttmpl .= "-u $opt_u "; }
         if ( $opt_c ) { $cshscripttmpl .= "-c $opt_c "; }
         if ( $opt_m ) { $cshscripttmpl .= "-m '$opt_m' "; }
         if ( $opt_M ) { $cshscripttmpl .= "-M "; }
         if ( $opt_o ) { $cshscripttmpl .= "-o "; }
         #add hold for prerequisite job
         #this only works for SGE, not moab, so commenting this now
         #if ( $opt_p ) {
         #   my $prev = FREUtil::modifydate($opt_t,"- 1 years");
         #   $prev = FREUtil::graindate($prev,"day");
         #   $cshscripttmpl .= "-w $expt"."_$prev ";
         #}
         $cshscripttmpl .= "$expt\n";
         $cshscripttmpl .= errorstr("$relfrepp had a problem creating next script $expt"."_$hDate");
      }

      if ( $opt_f ) {
            my @hf = ();
            my @hsmf = ();
            opendir(DIR, $opt_d) or die $!;
            @hf = grep { /\.raw\.nc\.tar$/ && -f "$opt_d/$_" } readdir(DIR);
            closedir(DIR);
            my $hsmget_history = hsmget_history_csh($ptmpDir,$tmphistdir,$refinedir,$this_frepp_cmd,join(' ',@hf),join(' ',@hsmf));
            $cshscripttmpl =~ s/#hsmget_history_files/$hsmget_history/;
            my @sorted = sort { $a cmp $b } @hf;
            my $check_history = checkHistComplete($tmphistdir,$sorted[0],$this_frepp_cmd,\@hsmf,\@diagtablecontent);
            $cshscripttmpl =~ s/#check_history_files/$check_history/;
      }

      if ( $opt_D and $opt_p ) {
         $cshscripttmpl .= call_frepp($abs_xml_path, $outscript, $opt_c, "");
         $cshscripttmpl .= errorstr("$relfrepp had a problem creating next script $expt"."_$hDate");
      }

      $cshscripttmpl .= mailerrors($outscript);
      if ( "$platform" eq 'ia64' ) {
         $cshscripttmpl =~ s/#\$ -l h_cpu.*/#\$ -l h_cpu=$maxruntime/;
      } else {
         $cshscripttmpl =~ s/#PBS -l walltime.*/#PBS -l walltime=$maxruntime/;
      }
      $cshscripttmpl =~ s/(-soft -l fre_info=)/$1ppYears\@$maxyrs+/;
      writescript($cshscripttmpl,$outscript,"$batchSubmit$opt_w $opt_m",$statefile);
      $opt_w = '';
      next;
   } else {
      $cshscripttmpl =~ s/set histDir = .*/set histDir = $tmphistdir/;
   }

   $writestate = '';
   unless ( $opt_A ) {
      my $writeIDorINTER = <<EOF;
if ( "\$JOB_ID" != '' ) then
 echo \$PBS_JOBID > \$statefile
else
 echo INTERACTIVE > \$statefile
 set PBS_JOBID = INTERACTIVE
endif
EOF
      $cshscripttmpl =~ s/#write_to_statefile/$writeIDorINTER/;

      $writestate = <<EOF;
  if ( "\$prevjobstate" == "ERROR" ) then
     echo FATAL > \$statefile
  else
     echo ERROR > \$statefile
  endif
EOF
   }

   $checktransfer = <<EOF;
if ( \$status ) then
         echo ERROR: data transfer attempt failed twice, exiting.
         Mail -s "\$name year \$historyyear cannot be postprocessed" \$USER <<END
Your FRE post-processing job ( \$JOB_ID ) has exited because of a data transfer failure.

This job can be resubmitted via:

$this_frepp_cmd

Job details:
\$name running on \$HOST
Batch job stdout:
\$FRE_STDOUT_PATH
END

$writestate

         sleep 30
         exit 7
endif
EOF

   #assemble a command to create archive directories
   if ($opt_v) { print "Creating archive directories...\n"; }
   $ppRootDir = $postprocessdir;
   if ( "$opt_u" ne '' ) { $ppRootDir .= "_$opt_u"; }
   if ( $opt_A and ! -d "$ppRootDir")  { print "ERROR: directory $ppRootDir not found. Exiting.\n"; exit 1; }
   $mkdircommand = "";
   $mkdircommand .= "mkdir -p $ppRootDir/.dec $ppRootDir/.checkpoint " unless $opt_A;
   my $nocommentver = $version_info;
   $nocommentver =~ s/#//g;
   $cshscripttmpl .= <<EOF;
   touch $statedir/frepp.log
   echo '#$versionId' >> $statedir/frepp.log
   cat >> $statedir/frepp.log <<END
$nocommentver

END
EOF
   $cshscripttmpl .= <<EOF;
#hsmget_history_files

#check_history_files
EOF

#if ( \$?checkpt ) then
#   #goto \$checkpt
#else
#   if ( -e $ppRootDir/.checkpoint/\$checkptfile ) then
#      set checkpt = `cat $ppRootDir/.checkpoint/\$checkptfile`
#      if ( "\$checkpt" != "" ) then
#         #goto \$checkpt
#      endif
#   endif
#endif
#EOF

      $getgridspec = "cd \$work; dmget $gridspec\n";
      if ( $gridspec =~ /cpio$/ ) {
         $getgridspec .= <<EOF;
if ( ! -e mosaic.nc && ! -e grid_spec.nc && ! -e atmos_mosaic.nc ) then
   $time_uncpio cpio -iv < $gridspec
endif

EOF
      } elsif ( $gridspec =~ /tar$/ ) {
         $getgridspec .= <<EOF;
if ( ! -e mosaic.nc && ! -e grid_spec.nc && ! -e atmos_mosaic.nc ) then
   $time_untar tar -xvf $gridspec
endif
EOF
      } else {
         $getgridspec .= <<EOF;
if ( ! -e mosaic.nc && ! -e grid_spec.nc && ! -e atmos_mosaic.nc ) then
   $time_cp $cp $gridspec .
endif
EOF
      }

      $call_tile_fregrid = $getgridspec . <<EOF;
set remap_dir = \$fregrid_remap_file:h
set remap_file = \$fregrid_remap_file:t
if ( -e \$fregrid_remap_file ) then
   $time_cp $cp \$fregrid_remap_file \$remap_file
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_cp $cp \$fregrid_remap_file \$remap_file
      $checktransfer
   endif
endif
EOF
      $call_tile_fregrid .= <<'EOF';
if ( -e mosaic.nc ) then
   set input_mosaic = `ncks -H -v $mosaic_type mosaic.nc | sed 's/.*="//;s/"//'`
else if ( -e grid_spec.nc ) then
   set input_mosaic = `ncks -H -v $mosaic_type grid_spec.nc | sed 's/.*="//;s/"//'`
else
   echo ERROR: Cannot locate atm_mosaic_file
   exit 1
endif

ls -l $input_mosaic
if ( $?variables && "$variables" != '' ) then
   set interpvars = "$variables"
   unset variables
else
   set interpvars = ( `$NCVARS $ncvars_arg $fregrid_in.tile1.nc` )
   set interpvars = `echo $interpvars |sed 's/ /,/g'`
endif
set order1 = ( precip prec_ls snow_ls prec_conv snow_conv uw_precip prec_uwc snow_uwc prc_deep_donner snow_deep_donner prc1_deep_donner prc_mca_donner snow_mca_donner ice_mask land_mask zsurf cld_amt_2d conv_freq IWP_all_clouds WP_all_clouds WVP tot_cloud_area tot_ice_amt tot_liq_amt swdn_sfc_clr swdn_sfc swdn_toa_clr swdn_toa swdn_tot_dif swup_sfc_clr swup_sfc swup_toa_clr swup_toa wind_ref wind_ref_max wind_ref_min )
set attCmds = ()
unset echo
EOF
      $call_tile_fregrid .= <<EOF;
if ( -e $ppRootDir/.non_default_interp_method ) then
  source $ppRootDir/.non_default_interp_method
endif
EOF
      $call_tile_fregrid .= <<'EOF';
foreach order1var ( $order1 )
  foreach modelvar ( `echo $interpvars | sed -e "s/,/ /g"` )
    if ( $modelvar == $order1var ) then
      if ( `ncexists -f $fregrid_in.tile1.nc -v $order1var` ) then
        if ( ! `ncexists -f $fregrid_in.tile1.nc -v $order1var -a interp_method` ) then
          set attCmds = ( $attCmds -a interp_method,$order1var,a,c,"conserve_order1" )
        endif
      endif
    endif
  end
end
set echo
EOF

      $call_fregrid = $call_tile_fregrid;
      $call_fregrid =~ s/tile1.//g;

      $call_fregrid .= <<EOF;
if (\$#attCmds > 0) then
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.nc
   #check_ncatted
endif

if ( "\$fregrid_wt" != '' ) then
   set fregrid_yr = `echo \$fregrid_in_date | sed 's/[0-9][0-9][0-9][0-9]\$//'`
   foreach fregridwtfile ( `ls $opt_d/\${fregrid_yr}????.nc.*` )
      set fregridwtfile = \$fregridwtfile:t:r
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$fregridwtfile/\\*land_static\\*
      if ( \$status ) then
         echo "WARNING: hsmget reported failure, retrying..."
         $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$fregridwtfile/\\*land_static\\*
         $checktransfer
      endif
   end
   ln -s \$histDir/\${fregrid_yr}????.nc/*land_static* .
      foreach fregrid_mo ( 02 03 04 05 06 07 08 09 10 11 12 )
        if ( ! -e \${fregrid_yr}\${fregrid_mo}01.land_static.nc ) then
           ln -s \${fregrid_yr}0101.land_static.nc \${fregrid_yr}\${fregrid_mo}01.land_static.nc
        endif
      end
endif
EOF
      $call_tile_fregrid .= <<EOF;
if (\$#attCmds > 0) then
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile1.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile2.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile3.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile4.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile5.nc
   $time_ncatted ncatted -h -O \$attCmds \$fregrid_in.tile6.nc
   #check_ncatted
endif

if ( "\$fregrid_wt" != '' ) then
   set fregrid_yr = `echo \$fregrid_in_date | sed 's/[0-9][0-9][0-9][0-9]\$//'`
   foreach fregridwtfile ( `ls $opt_d/\${fregrid_yr}????.nc.*` )
      set fregridwtfile = \$fregridwtfile:t:r
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$fregridwtfile/\\*land_static\\*
      if ( \$status ) then
         echo "WARNING: hsmget reported failure, retrying..."
         $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$fregridwtfile/\\*land_static\\*
         $checktransfer
      endif
   end
   ln -s \$histDir/\${fregrid_yr}????.nc/*land_static* .
   foreach i ( 1 2 3 4 5 6 )
      foreach fregrid_mo ( 02 03 04 05 06 07 08 09 10 11 12 )
        if ( ! -e \${fregrid_yr}\${fregrid_mo}01.land_static.tile\$i.nc ) then
           ln -s \${fregrid_yr}0101.land_static.tile\$i.nc \${fregrid_yr}\${fregrid_mo}01.land_static.tile\$i.nc
        endif
      end
   end
endif

# Correct associated_file year (for static files) and get files
foreach f ( \$fregrid_in*.nc )
   set fregrid_yr = `echo \$fregrid_in_date | cut -c 1-4`
   set oldassoc = `ncdump -h \$f | grep ':associated_files' | cut -d'"' -f2`
   if ("\$oldassoc" != '' ) then
      set newassoc = `ncdump -h \$f | grep ':associated_files' | cut -d'"' -f2 | sed "s/: [0-9]\\{4\\}/: \$fregrid_yr/g"`
      if ("\$oldassoc" != "\$newassoc") then
         # If file is a link, then copy and make sure it is writable
         if ( -l \$f ) then
            $time_cp cp \$f copy
            $time_rm rm -f \$f
            $time_mv $mv copy \$f
            chmod 644 \$f
         endif
         $time_ncatted ncatted -h -O -a associated_files,global,m,c,"\$newassoc" \$f
#check_ncatted
      endif

      # For now, remove the '.tile[1-6]' from all associated files.  fregrid will add it back in
      #TODO - When fregrid is updated, remove this
      set newassoc = `ncdump -h \$f | grep ':associated_files' | cut -d'"' -f2 | sed "s/\.tile[0-6]//g"`
      if ( -l \$f ) then
         $time_cp cp \$f copy
         $time_rm rm -f \$f
         $time_mv $mv copy \$f
         chmod 644 \$f
      endif
      $time_ncatted ncatted -h -O -a associated_files,global,m,c,"\$newassoc" \$f
#check_ncatted

      # Get the associated_files
      foreach af ( `echo \$newassoc | sed "s/\\w*://g"` )
         foreach aff ( \$histDir/\$fregrid_yr*/*\${af:r}* )
            if ( ! -e `basename \$aff` ) ln -s \$aff .
            end
         end
      endif
   end
EOF
      if ( $basenpes == 1 ) {
         my $exec_fregrid .= <<EOF;
$time_fregrid fregrid --standard_dimension --input_mosaic \$input_mosaic --input_file \$fregrid_in --interp_method \$interp_method --remap_file \$remap_file --nlon \$nlon --nlat \$nlat --scalar_field \$interpvars \$fregrid_wt --output_file out.nc
mv out.nc \$fregrid_in.nc
EOF
         $call_tile_fregrid .= $exec_fregrid;
         $call_fregrid .= $exec_fregrid;
      } else {
         my $exec_fregrid .= <<EOF;
$time_fregrid mpirun -np $basenpes fregrid_parallel --standard_dimension --input_mosaic \$input_mosaic --input_file \$fregrid_in --interp_method \$interp_method --remap_file \$remap_file --nlon \$nlon --nlat \$nlat --scalar_field \$interpvars \$fregrid_wt --output_file out.nc
mv out.nc \$fregrid_in.nc
EOF
         $call_tile_fregrid .= $exec_fregrid;
         $call_fregrid .= $exec_fregrid;
      }

   my $rename_regridded = <<EOF;
#check_fregrid

if ( ! -e \$fregrid_remap_file ) then
   ls -l \$remap_file*
   $time_hsmput hsmput -v -t -p \$remap_dir -w . \$remap_file
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_hsmput hsmput -v -t -p \$remap_dir -w . \$remap_file
      $checktransfer
   endif
endif

EOF
      $call_tile_fregrid .= $rename_regridded;
      $call_fregrid .= $rename_regridded;

      $call_tile_fregrid .= <<EOF;
$time_rm rm \$fregrid_in.tile?.nc
$time_rm rm *.grid_spec.tile*.nc
EOF

   if ( $opt_A) {print STDERR "\n ANALYSIS ONLY mode, pp/ files will not be generated\n";}

   my $cshscript = $cshscripttmpl;
   my @ppComponentNodes = $ppNode->findnodes("component");
   if ( $opt_c and "$opt_c" ne "split") {
      @ppComponentNodes = $ppNode->findnodes("component[\@type='$opt_c']");
   }

   if ( "@ppComponentNodes" eq '' ) {
      if ( $opt_c and "$opt_c" ne "split") {
         print STDERR "ERROR: No such component: $opt_c\n";
      } else {
         print STDERR "ERROR: No available components\n";
      }
   }

   #process each component
   foreach my $ppcNode ( @ppComponentNodes ) {
      $cpiomonTS = "";
      $component = $ppcNode->findvalue('@type');
      print STDERR "\nCreating script for postprocessing component '$component'\n" if $opt_v;
      my $this_component_cmd = $this_frepp_cmd;
      $this_component_cmd =~ s/ -c split / -c $component /;
      $checktransfer = <<EOF;
if ( \$status ) then
         echo ERROR: data transfer attempt failed twice, exiting.
         Mail -s "\$name year \$historyyear component $component cannot be postprocessed" \$USER <<END
Your FRE post-processing job ( \$JOB_ID ) has exited because of a data transfer failure.

This job can be resubmitted via:

$this_component_cmd

Job details:
  \$name running on \$HOST
Batch job stdout:
  \$FRE_STDOUT_PATH
END

         $writestate
         sleep 30
         exit 7
endif
EOF


      if ( $opt_c ) {   #append component name to job and file name
         $cshscript = $cshscripttmpl;
         my $origoutscript = $outscript;
         my $orig_pbs_job_name = $pbs_job_name;
         $outscript = "$outscriptdir/$expt"."_$component"."_$hDate";
         $pbs_job_name = "$expt";
	 if ( "$opt_u" ne '' ) {
	   $pbs_job_name .= "_$opt_u";
	 }
	 $pbs_job_name .= "_$component"."_$hDate";
         $cshscript =~ s/set scriptName = .*/set scriptName = $outscript/;
         $cshscript =~ s/#PBS -N .*/#PBS -N $pbs_job_name/;
         $cshscript =~ s/setenv FRE_STDOUT_PATH.*/setenv FRE_STDOUT_PATH $stdoutdir\/postProcess\/$pbs_job_name.o\$JOB_ID/;
         $cshscript =~ s/(-w $expt)/$1_$component/;
         $cshscript =~ s/(-soft -l fre_info=)/$1ppComponent\@$component+/;
         $opt_w =~ s/( -hold_jid $expt)(.*)(_\d\d\d\d\d\d\d\d)/$1_$component$3/;
         $statefile = "$statedir/$component.".$userstartyear;

         #check status of this frepp year
         unless ( $opt_A ) {
            if ( -e $statefile ) {
               open( STATEFILE, "<$statefile") or die $!;
               $state = FREUtil::cleanstr( <STATEFILE> );
               close STATEFILE;
               print "This year ($hDate) has a state file with state '$state' for $component.\n";
               if ("$state" eq "OK") {
                  if ( $opt_o ) {
                     print "Redoing anyway because 'overwrite state files' was specified...\n";
                  } else {
                     print "This year ($hDate) has already been completed for $component.\n";
                     #should we continue here in case of opt_p?
                     next;
                  }
               } elsif ("$state" eq "FATAL") {
                  print "This year ($hDate) got an error in multiple attempts, skipping this component.  To retry $component processing, delete the state file $statefile\n";
                  #what if this is the -c split job? continue to other components
                  next;
               } elsif ("$state" eq "INTERACTIVE") {
                  print "This year ($hDate) was partially run interactively but not completed, resubmitting $component...\n";
               } elsif ("$state" eq "ERROR") {
                  print "This year ($hDate) got an error in the last frepp attempt, resubmitting $component...\n";
               } elsif ("$state" eq "HISTORYDATAERROR") {
                  print "This year ($hDate) got an error in the last frepp attempt due to missing history data, resubmitting $component...\n";
               } elsif ( "$state" eq '' ) {
                  print "ERROR: statefile $statefile exists but is empty, exiting.\n";
                  #what if this is the -c split job? continue to other components
                  next;
               } else {
                  #check that jobid is still running
                  my $jobrunning = isjobrunning( $state );
                  print "Checking state in $statefile: $state: jobrunning: $jobrunning\n";
                  if ( $jobrunning ) {
                     print "Previous frepp job ($state) for $hDate still running for $component, exiting.\n";
                     next;
                  } else {
                     print "Previous frepp job for $hDate was lost, resubmitting $component...\n";
                  }
               }
            }
            $cshscript =~ s/set prevjobstate.*/set prevjobstate = '$state'/;
            $cshscript =~ s/set statefile.*/set statefile = '$statefile'/;
         }

      }
      #initialize per component
      $cubic = 0;
      $sourceGrid = '';
      $xyInterp = '';
      $interpMethod = '';
      #xyInterp
      my $sourceGridAtt = $ppcNode->findvalue('@sourceGrid');

      #backwards reproducibility
      my $c2l = $ppcNode->findvalue('@cubicToLatLon');

      if ( "$c2l" eq 'none' ) { #leave data on cubed sphere grid
         $sourceGrid = 'cubedsphere';
         $xyInterp = '';
         $mosaic_type = "atm_mosaic_file";
      } elsif ( "$c2l" ne '' ) { #convert to lat lon grid
         $sourceGrid = 'cubedsphere';
         $xyInterp = $c2l;
         $mosaic_type = "atm_mosaic_file";
      } else { #latlon grid
         if ( "$sourceGridAtt" eq '' ) {
            $sourceGrid = 'latlon';
            $xyInterp = '';
            $mosaic_type = "atm_mosaic_file";
         }
      }

      #check if need to convert cube sphere grid to lat lon
      my @gridstrings = split(/-/, $sourceGridAtt);
      if ( "$gridstrings[0]" eq "atmos" ) {
         $mosaic_type = "atm_mosaic_file";
      } elsif ( "$gridstrings[0]" eq "ocean" ) {
         $mosaic_type = "ocn_mosaic_file";
      } elsif ( "$gridstrings[0]" eq "land" ) {
         $mosaic_type = "lnd_mosaic_file";
      } elsif ( "$gridstrings[0]" eq "none" ) {
         $mosaic_type = "none";
      } else {
         die "sourceGrid mosaic type '$gridstrings[0]' not supported. sourceGrid string must be 'none' or of the form: {atmos,ocean,land}-{latlon,cubedsphere,tripolar}\n" if "$mosaic_type" eq '';
      }
      $cshscript .= "set mosaic_type = $mosaic_type\n"; #this will be wrong for ocean, but not used.
      if ( "$sourceGridAtt" eq 'none' ) {
         $sourceGrid = 'none' if "$sourceGrid" eq '';
      } else {
         $sourceGrid = $gridstrings[1] if "$sourceGrid" eq '';
      }
      $xyInterp = $ppcNode->findvalue('@xyInterp') if "$xyInterp" eq '';
      if ( "$sourceGrid" eq '' ) {
         die "ERROR: Must specify postprocessing component 'sourceGrid' attribute of the form: '{atmos,ocean,land}-{latlon,cubedsphere,tripolar}' or 'none'\n";
      } elsif ( "$sourceGrid" !~ /(cubedsphere|latlon|tripolar|none)/ ) {
         die "ERROR: sourceGrid must be 'none' or '{atmos,ocean,land}-{cubedsphere,latlon,tripolar}'\n";
      }
      $nlat = 0;
      $nlon = 0;
      if ( "$xyInterp" eq '' ) {
         print STDERR "Data will be left on $sourceGrid grid\n" if $opt_v;
         $cshscript .= "#Grid type: $sourceGrid\n";
      } elsif ( "$xyInterp" =~ /\d+,\d+/ ) {
         ($nlat,$nlon) = split(',',$xyInterp);
         print STDERR "$sourceGrid data will be converted to (nlat,nlon)=($nlat,$nlon)\n" if $opt_v;
         $cshscript .= "#Grid type: $sourceGrid will be converted to latlon (nlat,nlon)=($nlat,$nlon)\n";
         # Check for a xyInterpRegridFile defined in the XML
         my @xyInterpRegridFiles = $fre->dataFiles($ppcNode,'xyInterpRegridFile');
         # dataFiles returns a file/target type array, we only care about the file
         if (scalar(@xyInterpRegridFiles)>0) {
           $xyInterpRegridFile = $xyInterpRegridFiles[0];
           if (!-e $xyInterpRegridFile && !-w dirname($xyInterpRegridFile)) {
             die "ERROR: xyInterpRegridFile '$xyInterpRegridFile' is specified for '$component', but doesn't exist and user will be unable to write to it's final location";
           }
         } else {
           $xyInterpRegridFile = "$ppRootDir/$component/.fregrid_remap_file_\${nlon}_by_\${nlat}.nc";
         }
      } else {
         die "ERROR: xyInterp must specify a 'lat,lon' for regridding\n";
      }
      $interpMethod = 'conserve_order1';
      $interpMethod = 'conserve_order2' if "$sourceGrid" eq "cubedsphere";

      #check if non-default interpMethod specified
      my $componentIM = $ppcNode->findvalue('@interpMethod');
      if ( "$componentIM" ne "" ) { $interpMethod = $componentIM; }

      #get list of all diagnostic output files from source attributes, remove duplicates
      my @sourceatts = $ppcNode->findnodes('*/@source');
      push @sourceatts, $ppcNode->findnodes('@source');
      my @dts = map { $_->findvalue('.') } @sourceatts;
      push @dts, "$component"."_month";
      my @dtsources = ();
      my %seen = ();
      foreach (@dts) {
         push(@dtsources, $_) unless ($_=~/monthly/ or $_=~/annual/ or $_=~/seasonal/ or $seen{$_}++);
      }
      push(@dtsources,'land_static') unless $seen{$_}++;
      if ($opt_v) {print STDERR "diag_table source files are '@dtsources'\n";}

      #get list of variables for each file from diag table information.
      foreach my $srcfile (@dtsources) {
         my @dtv = ();
         my @dtvall = ();

         foreach (@diagtablecontent) {
            if ( /.*,.*,\s*"(\w*)"\s*,\s*"$srcfile"\s*,.*,.*,.*,.*/ and not /^#/ ) {
               push @dtvall,$1;
            }
            #omit static/instantaneous variables
            if ( /.*,.*,\s*"(\w*)"\s*,\s*"$srcfile"\s*,.*,\s*\.true\.\s*,.*,.*/ and not /^#/ ) {
               push @dtv,$1;
            }
         }
         my $varstr = join(',',@dtv);
         my $varstrall = join(',',@dtvall);
         my $srcfileall = "all_$srcfile";
         if ( "$varstrall" ne "" ) {
            $dtvars{$srcfile} = $varstr;
            $dtvars{$srcfileall} = $varstrall;
            if ($opt_V) {print "$srcfile vars, static/instant omitted: $dtvars{$srcfile}\n\n";}
            if ($opt_v) {print "All $srcfile diag_table variables: $dtvars{$srcfileall}\n\n"};
         }
      }


      my $startdate = $ppcNode->findvalue('@start');
      if ( "$startdate" eq "" ) { $startdate = $ppNode->findvalue('@start'); }
      $sim0 = "";
      my $run0 = &FREUtil::parseFortranDate($basedate);
      if ( "$startdate" ne "" ) {
         $startdate = FREUtil::padzeros($startdate);
         $sim0 = FREUtil::parseDate($startdate);
         if ($sim0 == undef) {
           print STDERR "ERROR: The start date specified in the XML postProcess/component tag is not a valid date.\n";
           exit 1;
         }
         if ( "$sim0" ne "" and FREUtil::dateCmp($run0,$sim0) == 1 ) {
            mailuser("the $component postprocessing start attribute ($sim0) must be equal to or later than the start of the run ($run0). The default value of the start attribute is the start of the run.  Setting the start attribute to a later date provides the ability to skip years of data at the beginning of a run.  Please check the start attribute of all postprocessing components.");
            print STDERR "WARNING: the $component postprocessing start attribute ($sim0) must be equal to or later than the start of the run ($run0).  The default value of the start attribute is the start of the run.  Setting the start attribute to a later date provides the ability to skip years of data at the beginning of a run.  Please check the start attribute of all postprocessing components.";
         } else {
            print "NOTE: sim0 from start attribute: $sim0\n" if $opt_v;
         }
      } else {
         $sim0 = &FREUtil::parseFortranDate($basedate);
         print "NOTE: sim0 from basedate: $sim0\n" if $opt_v;
      }
      if ( "$sim0" eq "" ) {
         mailuser("$relfrepp had a problem calculating sim0.  Please contact Amy.");
         sysmailuser();
         die "ERROR: $relfrepp had a problem calculating sim0.  Please contact Amy.\n";
      }
      my $startflag = FREUtil::dateCmp($t0,$sim0);
      my $startofrun = 0;
      if ( $startflag eq 0 ) {
         print "NOTE: This is the first postprocessing of the simulation for $component\n" if $opt_v;
         $startofrun = 1;
      } elsif( $startflag eq -1 and ! $opt_A ) {
         print "NOTE: t0 < sim0, skipping $t0-$tEND for $component\n" if $opt_v;
         next;
      } elsif( $startflag eq 1 ) {
         print "NOTE: t0 > sim0 for $component\n" if $opt_v;
      } else {
         print "WARNING: having trouble comparing t0 to sim0 ($t0,$sim0) for $component\n" if $opt_v;
      }
      print "      sim0 is $sim0 (from basedate or start attribute)\n" if $opt_v;
      #get simulation end date from production xml -> simEND
      my $simTime = FREUtil::getxpathval('runtime/production/@simTime'); #not currently used
      my $simUnits = FREUtil::getxpathval('runtime/production/@units');  #not currently used
      if($opt_S) {
         $segTime = $opt_S; $segUnits = "months"
      } else {
         $segTime = FREUtil::getxpathval('runtime/production/segment/@simTime'); #global
         $segUnits = FREUtil::getxpathval('runtime/production/segment/@units');  #global
         if ( "$segUnits" eq "month" ) { $segUnits="months"; }
         if ( "$segUnits" eq "year" ) { $segUnits="years"; }
      }

      my $simEND = FREUtil::modifydate($run0,"+ $simTime $simUnits - 1 sec");

      if ( $simEND < $tEND and ! $opt_A) {
         if ( $simEND < $t0 ) {
            print "WARNING: The simulation time calculated from the basedate in your diag_table ($basedate) and the simulation length from the xml ($simTime $simUnits) ends before this year of postprocessing ($hDate).\n";
            $simEND = $tEND; #simEND not currently used for anything else
         } else {
            $tEND = $simEND;
            print "      adjusting tEND to simulation end: $tEND\n";
         }
      }
      #print "      simEND is $simEND (from basedate + xml simTime)\n";

      my $scriptcopy = $cshscript;
      my @depyears = ();
      (my $standardTarget,my $targeterr)  = FRETargets::standardize($opt_T);

      #STATIC
      my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
      my $diag_source = "";
      if ( scalar @monthnodes ) {
       my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
       $diag_source = $monthnode->getAttribute('@source');
      }
      if ( "$diag_source" eq "" ) { $diag_source = $ppcNode->findvalue('@source'); }
      if ( "$diag_source" eq "") { $diag_source = $component."_month"; }
      if ( ! $opt_l ) { $diag_source =~ s/_.*//; }
      my $staticfile = "$ppRootDir/$component/$component.static.nc";
      print STDERR "      static vars from '$diag_source'\n" if $opt_v;
      if ( ! $opt_A ) { $cshscript .= staticvars ( $diag_source, $ptmpDir, $tmphistdir, $refinedir ); }

      #TIMEAVERAGES - MONTHLY
      my @taNodes = sort by_interval $ppcNode->findnodes('timeAverage[@source="monthly"]');
      my @intervals = map { $_->findvalue('@interval') } @taNodes;
      my $diag_source  = " ";
      foreach my $taNode ( @taNodes ) {
         $hsmfiles = $hsmfiles . jpkSrcFiles($taNode) . ",";
         (my $int,my $subint,my @dep) = get_subint($taNode,@intervals);
         push ( @depyears, @dep );
         if ( $opt_v ) {
            print STDERR "      monthly av int=$int subint=$subint";
            if ( "$subint" eq "" ) { print STDERR "history\n"; } else { print STDERR "\n"; }
         }

         if (! $opt_A) {
            if ($subint) {
               $cshscript .= monthlyAVfromav( $taNode, $sim0, $subint );
            } else {
               #does monthly 1year and monthly xyear, order is unimportant
               $cshscript .= monthlyAVfromhist( $taNode, $sim0 );
            }
         }
         $cshscript .= analysis({ node => $taNode,
                                  experiment => $expt,
                                  gridSpec => $gridspec,
                                  staticFile => $staticfile,
                                  type => "timeAverage",
                                  diagSrc => $diag_source,
                                  ppRootDir => $ppRootDir,
                                  comp => $component,
                                  dtvarsRef => " ",
                                  analysisDir => $analysisdir,
                                  scriptDir => $aoutscriptdir,
                                  workDir => $workdir,
                                  archDir => $archivedir,
                                  opt_t => $hDate,
                                  opt_O => $opt_O,
                                  opt_Y => $opt_Y,
                                  opt_Z => $opt_Z,
                                  opt_V => $opt_V,
                                  opt_u => $opt_u,
                                  sim0 => $sim0,
                                  opt_R => $opt_R,
                                  histDir => $histDir,
                                  nLat => $nlat,
                                  nLon => $nlon,
                                  absXmlPath => $abs_xml_path,
                                  stdoutDir => $stdoutdir,
                                  opt_P => $opt_P,
                                  stdTarget => $standardTarget,
                                  opt_s => $opt_s});
      }


      #TIMEAVERAGES - ANNUAL
      my @taNodes = sort by_interval $ppcNode->findnodes('timeAverage[@source="annual" and @interval!="1yr"]');
      my @intervals = map { $_->findvalue('@interval') } @taNodes;
      my @annavnodes = $ppcNode->findnodes('timeAverage[@source="annual" and @interval="1yr"]');
      my $annCalcInterval = '';
      if ( scalar @annavnodes ) {
         my $taNode = $ppcNode->findnodes('timeAverage[@source="annual" and @interval="1yr"]')->get_node(1);
         $annCalcInterval = $taNode->findvalue('@calcInterval');
         if ( not scalar @taNodes or "$annCalcInterval" eq "1yr" ) {
            push ( @intervals, $annCalcInterval );
            $hsmfiles = $hsmfiles . jpkSrcFiles($taNode) . ",";
            if (! $opt_A ) {
               print STDERR "      annual av int=1yr subint=history\n" if $opt_v;
               $cshscript .= annualAV1yrfromhist( $taNode, $sim0, 1 );
            }
            $cshscript .= analysis({ node => $taNode,
                                     experiment => $expt,
                                     gridSpec => $gridspec,
                                     staticFile => $staticfile,
                                     type => "timeAverage",
                                     diagSrc => $diag_source,
                                     ppRootDir => $ppRootDir,
                                     comp => $component,
                                     dtvarsRef => \%dtvars,
                                     analysisDir => $analysisdir,
                                     scriptDir => $aoutscriptdir,
                                     workDir => $workdir,
                                     archDir => $archivedir,
                                     opt_t => $hDate,
                                     opt_O => $opt_O,
                                     opt_Y => $opt_Y,
                                     opt_Z => $opt_Z,
                                     opt_V => $opt_V,
                                     opt_u => $opt_u,
                                     sim0 => $sim0,
                                     opt_R => $opt_R,
                                     histDir => $histDir,
                                     nLat => $nlat,
                                     nLon => $nlon,
                                     absXmlPath => $abs_xml_path,
                                     stdoutDir => $stdoutdir,
                                     opt_P => $opt_P,
                                     stdTarget => $standardTarget,
                                     opt_s => $opt_s});
         }
      }
      foreach my $taNode ( @taNodes ) {
         $hsmfiles = $hsmfiles . jpkSrcFiles($taNode) . ",";
         (my $int,my $subint,my @dep) = get_subint($taNode,@intervals);
         push ( @depyears, @dep );
         if ( $opt_v ) {
            print STDERR "      annual av int=$int subint=$subint";
            if ( "$subint" eq "" ) { print STDERR "1\n"; } else { print STDERR "\n"; }
         }
         if (! $opt_A ) {
            if ($subint>1) {
               $cshscript .= annualAVfromav( $taNode, $sim0, $subint );
            } else {
               $cshscript .= annualAVxyrfromann( $taNode, $sim0, $ppcNode, scalar @annavnodes, $annCalcInterval );
            }
         }
         $cshscript .= analysis({ node => $taNode,
                                  experiment => $expt,
                                  gridSpec => $gridspec,
                                  staticFile => $staticfile,
                                  type => "timeAverage",
                                  diagSrc => $diag_source,
                                  ppRootDir => $ppRootDir,
                                  comp => $component,
                                  dtvarsRef => \%dtvars,
                                  analysisDir => $analysisdir,
                                  scriptDir => $aoutscriptdir,
                                  workDir => $workdir,
                                  archDir => $archivedir,
                                  opt_t => $hDate,
                                  opt_O => $opt_O,
                                  opt_Y => $opt_Y,
                                  opt_Z => $opt_Z,
                                  opt_V => $opt_V,
                                  opt_u => $opt_u,
                                  sim0 => $sim0,
                                  opt_R => $opt_R,
                                  histDir => $histDir,
                                  nLat => $nlat,
                                  nLon => $nlon,
                                  absXmlPath => $abs_xml_path,
                                  stdoutDir => $stdoutdir,
                                  opt_P => $opt_P,
                                  stdTarget => $standardTarget,
                                  opt_s => $opt_s});
      }

      #TIMEAVERAGES - SEASONAL
      my @taNodes = sort by_interval $ppcNode->findnodes('timeAverage[@source="seasonal"]');
      my @intervals = map { $_->findvalue('@interval') } @taNodes;
      foreach my $taNode ( @taNodes ) {
         $hsmfiles = $hsmfiles . jpkSrcFiles($taNode) . ",";
         (my $int,my $subint,my @dep) = get_subint($taNode,@intervals);
         push ( @depyears, @dep );

         if (! $opt_A ) {
            if ($subint) {
               print STDERR "      seasonal av int=$int subint=$subint\n" if $opt_v;
               $cshscript .= seasonalAVfromav( $taNode, $sim0, $subint );
            } else {
               print STDERR "      seasonal av int=$int subint=history\n" if $opt_v;
               $cshscript .= seasonalAVfromhist( $taNode, $sim0 );
            }
         }
         $cshscript .= analysis({ node => $taNode,
                                  experiment => $expt,
                                  gridSpec => $gridspec,
                                  staticFile => $staticfile,
                                  type => "timeAverage",
                                  diagSrc => $diag_source,
                                  ppRootDir => $ppRootDir,
                                  comp => $component,
                                  dtvarsRef => \%dtvars,
                                  analysisDir => $analysisdir,
                                  scriptDir => $aoutscriptdir,
                                  workDir => $workdir,
                                  archDir => $archivedir,
                                  opt_t => $hDate,
                                  opt_O => $opt_O,
                                  opt_Y => $opt_Y,
                                  opt_Z => $opt_Z,
                                  opt_V => $opt_V,
                                  opt_u => $opt_u,
                                  sim0 => $sim0,
                                  opt_R => $opt_R,
                                  histDir => $histDir,
                                  nLat => $nlat,
                                  nLon => $nlon,
                                  absXmlPath => $abs_xml_path,
                                  stdoutDir => $stdoutdir,
                                  opt_P => $opt_P,
                                  stdTarget => $standardTarget,
                                  opt_s => $opt_s});
      }


      #TIMESERIES - HOURLY
      my @hrfreqs = ('hourly','2hr','3hr','4hr','6hr','8hr','12hr','120hr');
      foreach my $hrfreq ( @hrfreqs ) {
         my @tsNodes = sort by_chunk $ppcNode->findnodes("timeSeries[\@freq='$hrfreq']");
         my @chunks = map { $_->findvalue('@chunkLength') } @tsNodes;
         my $diag_source = diagfile($ppcNode,"$hrfreq");
         foreach my $tsNode ( @tsNodes ) {
            $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
            (my $cl,my $subchunk,my @dep) = get_subint($tsNode,@chunks);
            push ( @depyears, @dep );
            if ( $opt_v ) {
               print STDERR "      $hrfreq ts chunklength=$cl subchunk=$subchunk";
               if ( "$subchunk" eq "" ) { print STDERR "history\n"; } else { print STDERR "\n"; }
            }

            if (! $opt_A ) {
               if ($subchunk) {
                  $cshscript .= TSfromts( $tsNode, $sim0, $subchunk );
               } else {
                  $cshscript .= directTS( $tsNode, $sim0, $startofrun );
               }
            }
            $cshscript .= analysis({ node => $tsNode,
                                     experiment => $expt,
                                     gridSpec => $gridspec,
                                     staticFile => $staticfile,
                                     type => "timeSeries",
                                     diagSrc => $diag_source,
                                     ppRootDir => $ppRootDir,
                                     comp => $component,
                                     dtvarsRef => \%dtvars,
                                     analysisDir => $analysisdir,
                                     scriptDir => $aoutscriptdir,
                                     workDir => $workdir,
                                     archDir => $archivedir,
                                     opt_t => $hDate,
                                     opt_O => $opt_O,
                                     opt_Y => $opt_Y,
                                     opt_Z => $opt_Z,
                                     opt_V => $opt_V,
                                     opt_u => $opt_u,
                                     sim0 => $sim0,
                                     opt_R => $opt_R,
                                     histDir => $histDir,
                                     nLat => $nlat,
                                     nLon => $nlon,
                                     absXmlPath => $abs_xml_path,
                                     stdoutDir => $stdoutdir,
                                     opt_P => $opt_P,
                                     stdTarget => $standardTarget,
                                     opt_s => $opt_s});
         }
      }

      #TIMESERIES - DAILY
      my @tsNodes = sort by_chunk $ppcNode->findnodes('timeSeries[@freq="daily" or @freq="day"]');
      my @chunks = map { $_->findvalue('@chunkLength') } @tsNodes;
      my $diag_source = diagfile($ppcNode,"daily");
      foreach my $tsNode ( @tsNodes ) {
         $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
         (my $cl,my $subchunk,my @dep) = get_subint($tsNode,@chunks);
         push ( @depyears, @dep );
         if ( $opt_v ) {
            print STDERR "      daily ts chunklength=$cl subchunk=$subchunk";
            if ( "$subchunk" eq "" ) { print STDERR "history\n"; } else { print STDERR "\n"; }
         }

         if (! $opt_A ) {
            if ($subchunk) {
               $cshscript .= TSfromts( $tsNode, $sim0, $subchunk );
            } else {
               $cshscript .= directTS( $tsNode, $sim0, $startofrun );
            }
         }
         $cshscript .= analysis({ node => $tsNode,
                                  experiment => $expt,
                                  gridSpec => $gridspec,
                                  staticFile => $staticfile,
                                  type => "timeSeries",
                                  diagSrc => $diag_source,
                                  ppRootDir => $ppRootDir,
                                  comp => $component,
                                  dtvarsRef => \%dtvars,
                                  analysisDir => $analysisdir,
                                  scriptDir => $aoutscriptdir,
                                  workDir => $workdir,
                                  archDir => $archivedir,
                                  opt_t => $hDate,
                                  opt_O => $opt_O,
                                  opt_Y => $opt_Y,
                                  opt_Z => $opt_Z,
                                  opt_V => $opt_V,
                                  opt_u => $opt_u,
                                  sim0 => $sim0,
                                  opt_R => $opt_R,
                                  histDir => $histDir,
                                  nLat => $nlat,
                                  nLon => $nlon,
                                  absXmlPath => $abs_xml_path,
                                  stdoutDir => $stdoutdir,
                                  opt_P => $opt_P,
                                  stdTarget => $standardTarget,
                                  opt_s => $opt_s});
      }

      #TIMESERIES - MONTHLY
      my @tsNodes = sort by_chunk $ppcNode->findnodes('timeSeries[@freq="monthly" or @freq="month"]');
      my @chunks = map { $_->findvalue('@chunkLength') } @tsNodes;
      my $diag_source = diagfile($ppcNode,"monthly");
      foreach my $tsNode ( @tsNodes ) {
         $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
         (my $cl,my $subchunk,my @dep) = get_subint($tsNode,@chunks);
         push ( @depyears, @dep );
         if ( $opt_v ) {
            print STDERR "      monthly ts chunklength=$cl subchunk=$subchunk";
            if ( "$subchunk" eq "" ) { print STDERR "history\n"; } else { print STDERR "\n"; }
         }

         if (! $opt_A) {
            if ($subchunk) {
               $cshscript .= TSfromts( $tsNode, $sim0, $subchunk );
            } else {
               $cshscript .= directTS( $tsNode, $sim0, $startofrun );
            }
         }
         $cshscript .= analysis({ node => $tsNode,
                                  experiment => $expt,
                                  gridSpec => $gridspec,
                                  staticFile => $staticfile,
                                  type => "timeSeries",
                                  diagSrc => $diag_source,
                                  ppRootDir => $ppRootDir,
                                  comp => $component,
                                  dtvarsRef => \%dtvars,
                                  analysisDir => $analysisdir,
                                  scriptDir => $aoutscriptdir,
                                  workDir => $workdir,
                                  archDir => $archivedir,
                                  opt_t => $hDate,
                                  opt_O => $opt_O,
                                  opt_Y => $opt_Y,
                                  opt_Z => $opt_Z,
                                  opt_V => $opt_V,
                                  opt_u => $opt_u,
                                  sim0 => $sim0,
                                  opt_R => $opt_R,
                                  histDir => $histDir,
                                  nLat => $nlat,
                                  nLon => $nlon,
                                  absXmlPath => $abs_xml_path,
                                  stdoutDir => $stdoutdir,
                                  opt_P => $opt_P,
                                  stdTarget => $standardTarget,
                                  opt_s => $opt_s});
      }

      #TIMESERIES - ANNUAL
      my @tsNodes = sort by_chunk $ppcNode->findnodes('timeSeries[@freq="annual"]');
      my @chunks = map { $_->findvalue('@chunkLength') } @tsNodes;
      my $diag_source = diagfile($ppcNode,"annual","annual");
      foreach my $tsNode ( @tsNodes ) {
         $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
         (my $cl,my $subchunk,my @dep) = get_subint($tsNode,@chunks);
         push ( @depyears, @dep );
         if ( $opt_v ) {
            print STDERR "      annual ts chunklength=$cl subchunk=$subchunk";
            if ( "$subchunk" eq "" ) { print STDERR "..."; } else { print STDERR "\n"; }
         }

         if (! $opt_A ) {
            if ($subchunk) {
               $cshscript .= TSfromts( $tsNode, $sim0, $subchunk );
            } else {
               $cshscript .= annualTS( $tsNode, $sim0, $startofrun, join("\n",@diagtablecontent) );
            }
         }
         $cshscript .= analysis({ node => $tsNode,
                                  experiment => $expt,
                                  gridSpec => $gridspec,
                                  staticFile => $staticfile,
                                  type => "timeSeries",
                                  diagSrc => $diag_source,
                                  ppRootDir => $ppRootDir,
                                  comp => $component,
                                  dtvarsRef => \%dtvars,
                                  analysisDir => $analysisdir,
                                  scriptDir => $aoutscriptdir,
                                  workDir => $workdir,
                                  archDir => $archivedir,
                                  opt_t => $hDate,
                                  opt_O => $opt_O,
                                  opt_Y => $opt_Y,
                                  opt_Z => $opt_Z,
                                  opt_V => $opt_V,
                                  opt_u => $opt_u,
                                  sim0 => $sim0,
                                  opt_R => $opt_R,
                                  histDir => $histDir,
                                  nLat => $nlat,
                                  nLon => $nlon,
                                  absXmlPath => $abs_xml_path,
                                  stdoutDir => $stdoutdir,
                                  opt_P => $opt_P,
                                  stdTarget => $standardTarget,
                                  opt_s => $opt_s});
      }

      #TIMESERIES - SEASONAL
      my @tsNodes = sort by_chunk $ppcNode->findnodes('timeSeries[@freq="seasonal"]');
      my @chunks = map { $_->findvalue('@chunkLength') } @tsNodes;
      my $diag_source = diagfile($ppcNode,"seasonal","seasonal");
      foreach my $tsNode ( @tsNodes ) {
         $hsmfiles = $hsmfiles . jpkSrcFiles($tsNode) . ",";
         (my $cl,my $subchunk,my @dep) = get_subint($tsNode,@chunks);
         push ( @depyears, @dep );
         if ( $opt_v ) {
            print STDERR "      seasonal ts chunklength=$cl subchunk=$subchunk";
            if ( "$subchunk" eq "" ) { print STDERR "..."; } else { print STDERR "\n"; }
         }

         if (! $opt_A ) {
            if ($subchunk) {
               $cshscript .= seaTSfromts( $tsNode, $sim0, $subchunk );
            } else {
               $cshscript .= seasonalTS( $tsNode, $sim0 );
            }
         }
         $cshscript .= analysis({ node => $tsNode,
                                  experiment => $expt,
                                  gridSpec => $gridspec,
                                  staticFile => $staticfile,
                                  type => "timeSeries",
                                  diagSrc => $diag_source,
                                  ppRootDir => $ppRootDir,
                                  comp => $component,
                                  dtvarsRef => \%dtvars,
                                  analysisDir => $analysisdir,
                                  scriptDir => $aoutscriptdir,
                                  workDir => $workdir,
                                  archDir => $archivedir,
                                  opt_t => $hDate,
                                  opt_O => $opt_O,
                                  opt_Y => $opt_Y,
                                  opt_Z => $opt_Z,
                                  opt_V => $opt_V,
                                  opt_u => $opt_u,
                                  sim0 => $sim0,
                                  opt_R => $opt_R,
                                  histDir => $histDir,
                                  nLat => $nlat,
                                  nLon => $nlon,
                                  absXmlPath => $abs_xml_path,
                                  stdoutDir => $stdoutdir,
                                  opt_P => $opt_P,
                                  stdTarget => $standardTarget,
                                  opt_s => $opt_s});
      }

      if ( $didsomething ) {
         $didsomething = 0;
      } else {
         print STDERR "NOTE: No calculations necessary for year $hDate for $component.\n\n";
         next;
      }

      #PROCESS DEPENDENCIES
      my $depholds = "";
      my $redothisyear = 0;
      unless ( $opt_A ) {

      #sort, unique dependencies
      my %seen = (); my @u = grep { ! $seen{$_} ++ } @depyears;
      @depyears=sort {$a <=> $b} @u;
      print "\nThis frepp year depends on: @depyears\n" if $opt_v;

      foreach my $depyear ( @depyears ) {
         my $depfile = "$statedir/$component.$depyear";
         my $redo = 0;
         my $depstate = '';
         if ( -e $depfile ) {
            open( DEPFILE, "<$depfile") or die $!;
            $depstate = FREUtil::cleanstr( <DEPFILE> );
            close DEPFILE;
            print "Required year $depyear has a state file with state '$depstate' for $component.\n";
            if ("$depstate" eq "OK") {
               #ok, keep going
               if ( $opt_o ) {
                  if ( $opt_s ) {
                     print "Redoing anyway because 'overwrite state files' was specified...\n";
                     $redo = 1;
                     $redothisyear = 1;
                  }
               } else {
                  #print "Required year ($hDate) has already been completed for $component.\n";
               }
            } elsif ("$depstate" eq "FATAL") {
               print "Required year $depyear got an error in multiple attempts, exiting.  To retry, delete the state file $depfile\n";
               #what if this is the -c split job? continue to other components
               next;
            } elsif ("$depstate" eq "INTERACTIVE") {
               if ( $opt_s ) {
                  print "Required year $depyear has been partially run interactively but not completed, resubmitting $component...\n";
                  $redo = 1;
                  $redothisyear = 1;
               } else {
                  print "WARNING: Required year $depyear has been run interactively but not completed, and should be rerun.\n";
               }
            } elsif ("$depstate" eq "ERROR") {
               if ( $opt_s ) {
                  print "Required year $depyear got an error in the last frepp attempt, resubmitting $component...\n";
                  $redo = 1;
                  $redothisyear = 1;
               } else {
                  print "WARNING: Required year $depyear got an error in the last frepp attempt and should be rerun.\n";
               }
            } elsif ("$depstate" eq "HISTORYDATAERROR") {
               if ( $opt_s ) {
                  print "Required year $depyear got a history data error in the last frepp attempt, resubmitting $component...\n";
                  $redo = 1;
                  $redothisyear = 1;
               } else {
                  print "WARNING: Required year $depyear got a history data error in the last frepp attempt and should be rerun.\n";
               }
            } elsif ( "$depstate" eq '' ) {
               print "ERROR: statefile $depfile exists but is empty, exiting.\n";
               #what if this is the -c split job? continue to other components
               next;
            } else {
               #check that jobid is still running
               my $jobrunning = isjobrunning( $depstate );
               print "Checking state of job $depstate: jobrunning=$jobrunning\n";
               if ( $jobrunning ) {
                  print "Required year $depyear still working, placing a hold for $component.\n";
                  $depholds .= "$depstate:";
               } else {
                  if ( $opt_s ) {
                     print "Required year $depyear job was lost, resubmitting $component...\n";
                     $redo = 1;
                     $redothisyear = 1;
                  } else {
                     print "WARNING: Required year $depyear job was lost and should be rerun.\n";
                  }
               }
            }
         } else {
            if ( $opt_s ) {
               print "Required year $depyear missing, resubmitting $component...\n";
               $redo = 1;
               $redothisyear = 1;
            } else {
               print "WARNING: Required year $depyear missing. Use 'frepp -s' to submit with dependencies.\n";
            }
         }
         if ( $redo ) {
            my $cmd = call_frepp($abs_xml_path, $outscript, $component, "$depyear");
            print "$cmd\n";
            my $depjobid=`$cmd`;
            print "$depjobid\n";
            $depjobid =~ s/^$//mg;
            my @njobid = split '\n',$depjobid;
            $depjobid = $njobid[-1];
            $depjobid =~ s/New jobid='(.*)'/$1/ if $depjobid =~ /New jobid/;
            $depjobid =~ s/Previous frepp job \((.*)\).*/$1/ if $depjobid =~ /still running for /;
            unless ( $depjobid =~ /has already been completed/ ) {
               print "Dependent job for $depyear='$depjobid'\n";
               my $depstatefile = "$statedir/$component.$depyear";
               if ( "$depjobid" eq '' ) {
                  print "No jobid resulted from the Moab job submission of $depyear.\n";
                  #if ( "$depstate" eq "ERROR" ) {
                  #   print DEPSTATEFILE "FATAL\n";
                  #} else {
                  #   print DEPSTATEFILE "ERROR\n";
                  #}
                  print "ERROR: Unable to submit dependent jobs, exiting.\n";
                  exit 1;
               } elsif ( "$depjobid" !~ /gfdl.\d+/ ) {
                  print "ERROR: the jobid returned has the wrong format: a frepp/moab issue occurred.\n";
                  exit 1;
               } else {
                  $depholds .= "$depjobid:";
                  open( DEPSTATEFILE, ">$depstatefile") or die $!;
                  print DEPSTATEFILE "$depjobid\n";
                  close DEPSTATEFILE;
               }
            }
         }

      }
      }
      #I'm not sure whether "redothisyear" means that old dependencies in the current list could be wrong? -arl
      if ( $redothisyear and ! $opt_A ) {
         print "This year ($hDate) has unmet dependencies for $component, submitting with holds.\n";
      } else {
         print "All dependencies met or known for $hDate for $component.\n" if $opt_v;
      }

      if ( "$depholds" ne "" ) {
         chop $depholds;
         $opt_w = " -l depend=afterok:$depholds";
         print "Setting holds for $hDate: $opt_w\n";
      }


      $cshscript .= mailcomponent();
      #CPIO
      if ( "$cpiomonTS" ne "" and $aggregateTS ) { $cshscript .= $cpiomonTS; }

      #END OF THIS COMPONENT; REMOVE CHECKPOINT FILE
      $cshscript .= "rm -f $ppRootDir/.checkpoint/\$checkptfile\n";

      if ( $opt_c ) {
         #set up dmget, set up to postprocess the following year if necessary, write script
         $mkdircommand = createdirs( $mkdircommand );
         my @hf = dmget_files();
         my @hsmf = jpk_hsmget_files();
         if ( scalar @hf ) {
            my $hsmget_history = hsmget_history_csh($ptmpDir,$tmphistdir,$refinedir,$this_frepp_cmd,join(' ',@hf),join(' ',@hsmf));
            $cshscript =~ s/#hsmget_history_files/$hsmget_history/;
            my @sorted = sort { $a cmp $b } @hf;
            my $check_history = checkHistComplete($tmphistdir,$sorted[0],$this_frepp_cmd,\@hsmf,\@diagtablecontent);
            $cshscript =~ s/#check_history_files/$check_history/;
         }
         $cshscript .= call_frepp($abs_xml_path, $outscript, $component, "");
         if ( "$platform" eq 'ia64' ) { $cshscript .= "qstat -j \$PBS_JOBID | grep ^usage\n"; }
         $cshscript .= "echo END-OF-SCRIPT for postprocessing job $t0-$tEND for $expt\n";
         if ( $maxyrs < 2 ) {
            if ( "$platform" eq 'ia64' ) {
               $cshscript =~ s/#\$ -l h_cpu.*/#\$ -l h_cpu=20:00:00/;
            } else {
               $cshscript =~ s/#PBS -l walltime.*/#PBS -l walltime=20:00:00/;
            }
         }
         if ( $maxyrs >= 20 ) {
            if ( "$platform" eq 'ia64' ) {
               $cshscript =~ s/#\$ -l h_cpu.*/#\$ -l h_cpu=$maxruntime/;
            } else {
               $cshscript =~ s/#PBS -l walltime.*/#PBS -l walltime=$maxruntime/;
            }
            my $npes = $basenpes;
            $cshscript =~ s/pe ic.postp (.+)/pe ic.postp $npes/;
         }
         $cshscript=~ s/(-soft -l fre_info=)/$1ppYears\@$maxyrs+/;
         my $writefinalstate = <<EOF;

if ( \$errors_found == 0 ) then
  echo OK > $statefile
else if ( "\$prevjobstate" == "ERROR" ) then
  echo FATAL > $statefile
else
  echo ERROR > $statefile
endif
EOF
         unless ($opt_A) {
            writescript("$cshscript"."$writefinalstate",$outscript,"$batchSubmit$opt_w $opt_m",$statefile);
            $opt_w = '';
         }
      }
   }

   if ( ! $opt_c ) {
      die "Calling frepp without -c is no longer supported.\n";
   }

   sysmailuser();
   print "\n";
}

##############################################
# SUBROUTINES
##############################################

sub jpkSrcFiles {
   my $jpkElem    = $_[0]->getName;
   if ($jpkElem eq "timeAverage") {
     my $jpkSrc = $_[0]->findvalue('../@source');
     if ($jpkSrc eq "") {
       print STDERR "WARNING: no diagnostic source file specified for ".$_[0]->toString()."\n";
     }
     return $jpkSrc;
   } else {
     my $jpkSrc     = $_[0]->findvalue('@source');
     if ($jpkSrc eq "") { $jpkSrc = $_[0]->findvalue('../@source'); }
     if ($jpkSrc eq "") {
       print STDERR "WARNING: no diagnostic source file specified for ".$_[0]->toString()."\n";
     }
     return $jpkSrc;
   }
}

sub jpk_hsmget_files {
   my @hsmf = ();
   my %seen = ();
   my @hsmfilesa = split ',',$hsmfiles;
   foreach (@hsmfilesa) {
      push(@hsmf, $_) unless ($seen{$_}++); #uniq
   }
   if ($opt_v) {print "diagnostic files to be extracted: @hsmf\n\n";}
   $hsmfiles = '';
   return @hsmf;
}


#sort, uniq list of history files to dmget
sub dmget_files {
   my @hf = ();
   my %seen = ();
   my @historyfilesa = split ' ',$historyfiles;
   foreach (@historyfilesa) {
      push(@hf, $_) unless ($seen{$_}++); #uniq
   }
   @hf = sort(@hf);
   if ($opt_v) {print "historyfiles used: @hf\n\n";}
   $historyfiles = '';
   return @hf;
}

#return the csh to extract history files
sub hsmget_history_csh {
   my $ptmpDir = $_[0];
   my $tmphistdir = $_[1];
   my $refinedir = $_[2];
   my $this_frepp_cmd = $_[3];
   my $hf = $_[4];
   my $hsmf = $_[5];

   #this keeps users to 1,2,3,4,6,12 mo segments, but if <1yr, it should be allowed.
   #my @reqStartMonths = segStartMonths($segTime,$segUnits);
   #my $histPerYear = scalar(@reqStartMonths);
   my $beginCombineTime = `date +\%s`;

   #check for and combine raw history files online

  my @histfiles = split " ",$hf;
  #print "histfiles:".join(", ",@histfiles)."\n";
  #print "hsmf $hsmf\n";

  # Retrieve hidden debug mppnccombine flag if available or use default combiner flags
  my $mppnccombineOptsDefault = '-64 -h 16384 -m';
  my $mppnccombineOptString = $mppnccombineOptsDefault;
  if ( exists $opt{'mppnccombine-opts'} ) {
    $mppnccombineOptString = $opt{'mppnccombine-opts'};
  }

  foreach my $h ( @histfiles ) {
    chdir $opt_d;
    my ($year) = $h =~ /(\d{4,})\d{4}\./;
    #print "\nyear:$year\n";
    my @availraw = split /\n/,`ls -1 | egrep "$year....\.raw\.nc\.cpio\$|$year....\.raw\.nc\.tar\$"`;
    #print "availraw:".join(", ", @availraw)."\n";
    my @availhf = split /\n/,`ls -1 | egrep "$year....\.nc\.cpio\$|$year....\.nc\.tar\$"`;
    #print "availhf:".join(", ", @availhf)."\n";

    #if both raw and combined data exist, and raw is newer, replace. Otherwise exit on error.
    if ( @availraw and @availhf ) {
      my %count = ();
      my @modavailraw = @availraw;
      s/\.raw\.nc/\.nc/ for @modavailraw;
      #print "modavailraw:".join(", ", @modavailraw)."\n";
      foreach my $file (@modavailraw, @availhf) { $count{$file}++ }
      foreach my $file (keys %count) {
         if ( $count{$file} > 1 ) {
            my $combinedate = (stat($file))[9];
            my $rawfile = $file;
            $rawfile =~ s/\.nc\./\.raw\.nc\./;
            my $rawdate = (stat($rawfile))[9];
            #print "combined=$combinedate raw=$rawdate\n";
            if ( $combinedate > $rawdate ) {
               mailuser("Date of uncombined (raw) history file is older than date of combined history file for $file. This may indicate a problem; please remove the incorrect history file and relaunch frepp with the following command, using '-s' to submit:\n\n$this_frepp_cmd");
               sysmailuser();
               die "ERROR: Date of uncombined (raw) history file is older than date of combined history file for $file. This may indicate a problem; please remove the incorrect history file and relaunch frepp.\n";
            }
         }
       }
    } elsif ( ! @availraw and ! @availhf ) {
       mailuser("No history data found for year $year in $opt_d\n\nTo resubmit this frepp job when the data is available, run the following command with '-s' to submit:\n\n$this_frepp_cmd");
       sysmailuser();
       die "ERROR: No history data found for year $year in $opt_d\n";
    }
    #combine raw data
    my $PBS_JOBID = "$ENV{PBS_JOBID}";
    my $wallTime = 0;
    if ("$PBS_JOBID" ne '') {
       #chomp($wallTime = `checkjob -A $PBS_JOBID | tr ';' '\n' | grep WCLIMIT | cut -d'=' -f2`);
       chomp($wallTime = `$ENV{FRE_COMMANDS_HOME}/site/$ENV{FRE_SYSTEM_SITE}/bin/batch.scheduler.time -t $PBS_JOBID`);
       my $shreturn = $? >> 8;
       if ( $shreturn != 0 ) {
         print "ERROR: Could not obtain wallclock time\n";
         exit $shreturn;
       }
       print "NOTE: Requested walltime is $wallTime sec\n";
    }

    foreach my $file ( @availraw ) {
       my $histdate = $file;
       $histdate =~ s/(\d+)\..*/$1/;
       $histdate .= '.nc';
       my $combinedir = File::Temp->newdir( 'combinehistXXXXX', DIR => $ENV{TMPDIR}, CLEANUP => 1);
       #my $combinedir = File::Temp->tempdir( 'combinehistXXXXX', DIR => $ENV{TMPDIR});
       mkdir "$combinedir/$histdate";
       chdir "$combinedir/$histdate";
       print "\nNOTE: Copying to $combinedir, combining, and archiving file $file\n";
       #set initial timing stats
       chomp( my $segmentStart = `date +\%s` );
       my $combine = <<EOF;
$time_cp $cp $opt_d/$file .
MYSTATUS=\$?
if [ \$MYSTATUS -ne 0 ]; then
   echo WARNING: copy filed for raw history file $file, retrying.
   $time_cp $cp $opt_d/$file .
   MYSTATUS=\$?
   if [ \$MYSTATUS -ne 0 ]; then
      echo ERROR: copy failed twice for raw history file $file, exiting.
      exit 7
   fi
fi

$time_untar tar -xf $file
MYSTATUS=\$?
if [ \$MYSTATUS -ne 0 ]; then
   echo ERROR: history tar extraction failed for $file, exiting.
   exit 1
fi
$time_rm rm $file

export mppnccombineOptString='$mppnccombineOptString'

$time_combine $ENV{FRE_COMMANDS_HOME}/site/$ENV{FRE_SYSTEM_SITE}/bin/combinehist
MYSTATUS=\$?
if [ \$MYSTATUS -ne 0 ]; then
   echo ERROR: combining history files failed for $file, exiting.
   exit 1
fi

$time_hsmput hsmput -v -t -s tar -a $opt_d -p $ptmpDir/history -w $combinedir $histdate
MYSTATUS=\$?
if [ \$MYSTATUS -eq 0 ]; then
 if [ -f $opt_d/$file ] && [ -f $opt_d/$histdate.tar ]; then
 $time_rm rm $opt_d/$file
 fi
fi

EOF
       print qx("$combine");
       my $shreturn = $? >> 8;
       if ( $shreturn != 0 ) {
         print "ERROR: Could not combine history data\n";
         exit $shreturn;
       }
       #calculate timings, resubmit if necessary
       chomp( my $segmentEnd = `date +\%s` );
       my $timeSoFar = $segmentEnd - $beginCombineTime;
       print "NOTE: Finished a segment, timeSoFar = $timeSoFar\n";
       my $segmentTime = $segmentEnd - $segmentStart;
       #if not enough time for 2 x segmentTime, resubmit
       $segmentTime *= 2;
       if ( $wallTime > 0 ) {
          my $timeRemaining = $wallTime - $timeSoFar;
          if ( $segmentTime > $timeRemaining ) {
             print "NOTE: Only $timeRemaining seconds left, resubmitting.\n";
             sleep 2;
             exit 99;
          }
       }
    }
  }


   #gets all avail hist files
   my $hsmget_history = <<EOF;
cd $opt_d
foreach h ( $hf )
 set historyyear = `echo \$h | sed 's/[0-9][0-9][0-9][0-9].nc.tar//'`
 set availhf = ( `ls \$historyyear????.nc.cpio \$historyyear????.nc.tar` )
 if ( "\$availhf" == "" ) then
   Mail -s "\$name year \$historyyear cannot be postprocessed" \$USER <<END
Your FRE post-processing job ( \$JOB_ID ) has exited because no history files
were found for year \$historyyear in directory:
$opt_d

FRE will attempt to transfer the history files on the remote side by retrying
the failed output stager transfers.  If later postprocessing jobs require
this postprocessing interval, this year of postprocessing will be rerun.

To recover manually, please transfer the history data with gcp or send_file,
and then resubmit this postprocessing job via:

$this_frepp_cmd

Job details:
  \$name running on \$HOST
Batch job stdout:
  \$FRE_STDOUT_PATH
END

    echo HISTORYDATAERROR > \$statefile
    sleep 30
    exit 6
 endif

 foreach historyfile ( \$availhf )
 foreach hsmsrc ( $hsmf )
  set hsmdate = \$historyfile:r
  $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$hsmdate/\\*.\$hsmsrc.\\*
  if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$hsmdate/\\*.\$hsmsrc.\\*
$checktransfer
  endif
         # Get files listed as associated_files
         foreach hsmsrcfile ( $tmphistdir/\$hsmdate/*.\$hsmsrc.* )
            # Get a list of all associated files
            set assocFiles = `ncdump -h \$hsmsrcfile | $grepAssocFiles`
            foreach assocFile ( \$assocFiles )
               $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir \$hsmdate/\\*\${assocFile:r}.\\*
 end
 end
      end
   end
#end loop over history year
end

if ( -d $refinedir ) then
  cd $refinedir
  foreach h ( $hf )
  foreach hsmsrc ( $hsmf )
   set historyyear = `echo \$h | sed 's/[0-9][0-9][0-9][0-9].nc.tar//'`
   foreach historyfile ( `ls \$historyyear????.nc.cpio \$historyyear????.nc.tar`)
    set hsmdate = \$historyfile:r
    $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir \$hsmdate/\\*.\$hsmsrc.\\*
    if ( \$status ) then
        echo "WARNING: hsmget reported failure, retrying..."
        $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir \$hsmdate/\\*.\$hsmsrc.\\*
$checktransfer
    endif
            # Get files listed as associated_files
            foreach hsmsrcfile ( $tmphistdir/\$hsmdate/*.\$hsmsrc.* )
               # Get a list of all associated files
               set assocFiles = `ncdump -h \$hsmsrcfile | $grepAssocFiles`
               foreach assocFile ( \$assocFiles )
                  $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir \$hsmdate/\\*\${assocFile:r}.\\*
               end
   end
  end
  end
   end
endif
EOF

   return $hsmget_history;
}

#check for complete history data
sub checkHistComplete {
   my ($dir, $hf, $frepp_cmd, $usedfiles, $diagtablecontent) = @_;
   my $script = "cd $dir\n";

   my ($firsthisty) = $hf =~ /(\d{4,})\d{4}\./;
   my $firsthistm = substr($userstartmo,0,2);
   my $firsthistd = substr($userstartmo,2,2);
   my ($tENDy, $tENDm, $tENDd) = $tEND =~ /^(\d{4,})(\d{2})(\d{2})(?:\d{2}:\d{2}:\d{2})?$/;

   my $days_firsthist = FREUtil::daysSince1BC($firsthistm,$firsthistd,$firsthisty);
   my $days_tEND = FREUtil::daysSince1BC($tENDm,$tENDd,$tENDy);

   my $firsthist = FREUtil::parseDate( $firsthisty.$userstartmo );
   my $delta = FREUtil::dateCalc($firsthist,FREUtil::modifydate($tEND,"+1 sec"));

   foreach (@$diagtablecontent) {
      if ( /"(\w*)"\s*,\s*(\d*)\s*,\s*"(\w*)"\s*,.*,.*,.*,?/ and not /^#/ ) {
         my ($diagfile,$freq,$units) = ($1,$2,$3);

         next unless (grep { "$_" eq "$diagfile" } @$usedfiles);

         #get tEND-firsthist in hours, months, (years, days)
         my $efields = 0;
         my $efields2 = 0;
         if ("$units" eq "months") {
            $efields = &Delta_Format( $delta ,0,"%Mt");
            $efields /= $freq;
            $efields2 = $efields;
         } elsif ("$units" eq "years") {
            $efields = &Delta_Format( $delta ,0,"%yt");
            $efields /= $freq;
            $efields2 = $efields;
         } elsif ("$units" eq "days") {
            if ( "$caltype" eq "julian" ) {
               $efields = $days_tEND - $days_firsthist + 1;
               $efields2 = $days_tEND - $days_firsthist + 2;
               $efields /= $freq;
               $efields2 /= $freq;
            }
         } elsif ("$units" eq "hours") {
            if ( "$caltype" eq "julian" ) {
               $efields = ( $days_tEND - $days_firsthist + 1 ) * 24;
               $efields2 = ( $days_tEND - $days_firsthist + 2 ) * 24;
               $efields /= $freq;
               $efields2 /= $freq;
            }
         }

         next if $efields == 0;
         print "Will check that $diagfile ($freq $units) history data has $efields time levels ($firsthisty$firsthistm$firsthistd-$tENDy$tENDm$tENDd) \n" if $opt_v;

         $script .= <<EOF;

echo NOTE: Check $diagfile time levels: compare expected and actual fields
set afields = 0
foreach file (`ls -1 */*$diagfile\.*nc | egrep -v '\.tile[2-6]\.nc'`)
   set nf = `ncdump -h \$file | grep UNLIMITED | sed 's/.*(//;s/ .*//'`
   @ afields = \$afields + \$nf
end
if ( \$afields == $efields ) then
   echo NOTE: History data has the expected number of time levels for $diagfile
else if ( \$afields == $efields2 ) then
   echo NOTE: History data has the expected number of time levels for $diagfile
else
   echo ERROR: Incomplete history data
   Mail -s "\$name year \$historyyear cannot be postprocessed" \$USER <<END
Your FRE post-processing job ( \$JOB_ID ) has exited because of incomplete
history data.  FRE expected $efields time levels in $diagfile data, but
found \$afields time levels for the interval $firsthisty$firsthistm$firsthistd-$tENDy$tENDm$tENDd.

FRE will attempt to transfer the history files on the remote side by retrying
the failed output stager transfers.  If later postprocessing jobs require
this postprocessing interval, this year of postprocessing will be rerun.

To recover manually, please transfer the history data with gcp or send_file,
and then resubmit this postprocessing job via:

$frepp_cmd

Job details:
\$name running on \$HOST
Batch job stdout:
\$FRE_STDOUT_PATH
END
    echo HISTORYDATAERROR > \$statefile
    sleep 30
    exit 7

endif
EOF
      }
   }

   return $script;
}

#make directories
sub createdirs {
   my $mkdircommand = $_[0];

   if ( "$mkdircommand" ne "" and "$mkdircommand" ne "mkdir -p " ) {
      #if ( $opt_v ) { print "length of mkdircommand: ".length("$mkdircommand")."\n"; }
      if ( length("$mkdircommand") > 5000 ) {
         $mkdircommand =~ s/^mkdir -p //;
         my $i = index($mkdircommand,' ',5000);
         my $f = substr($mkdircommand,0,$i);
         my $s = substr($mkdircommand,$i,length($mkdircommand));
         #if($opt_v){print "executing mkdircommand:\nfirst half:\n'$f'\n\nsecond half:\n'$s'\n";}
         execute('ac-arch',"mkdir -p $f");
         execute('ac-arch',"mkdir -p $s");
      } else {
         #if ( $opt_v ) { print "executing mkdircommand: $mkdircommand\n"; }
         execute('ac-arch',$mkdircommand);
      }
      $mkdircommand = "mkdir -p ";
   }

   return $mkdircommand;
}

# ------ execute a command on the workstation that can write to archive. arguments: $host $command
sub execute {
  my ($h, $c) = @_;
  $/ = "";
  chomp(my $platform = qx(/home/gfdl/bin/gfdl_platform));
  if ($platform eq 'desktop') {
    # ----------------------------- gfdl workstation
    my $qloginHome = '/home/gfdl/qlogin';
    return system("$qloginHome/bin/hpcs_ssh_init; $qloginHome/bin/hpcs_ssh '$h' '$c'");
  } else {
    # ----------------------------- other hosts
    return system("$c");
  }
}


#set up to postprocess the following year if necessary
sub call_frepp {
   my $abs_xml_path = $_[0];
   my $outscript = $_[1];
   my $component = $_[2];
   my $year = $_[3];
   my $depjobs = $_[4];
   my $csh = "";

   my $nextyear = FREUtil::modifydate($tEND,"+ 1 sec");
   my $nextyearf = FREUtil::graindate($nextyear,"day");


   if ( "$depjobs" ne "" ) {
      chop $depjobs;
      $depjobs = "-w $depjobs ";
   }

   if ( "$year" ne "" ) {
      $year .= $userstartmo;
      $csh .= "\n/usr/bin/perl $absfrepp -x $abs_xml_path -t $year -s -q $depjobs";
      if ( $opt_P ) { $csh .= "-P $opt_P "; }
      if ( $opt_T ) { $csh .= "-T $opt_T "; }
      if ( $opt_d ) { $csh .= "-d $opt_d "; }
      if ( $opt_D ) { $csh .= "-D '$opt_D' "; }
      if ( $opt_u ) { $csh .= "-u $opt_u "; }
      if ( $opt_c ) { $csh .= "-c $component "; }
      if ( $opt_m ) { $csh .= "-m '$opt_m' "; }
      if ( $opt_M ) { $csh .= "-M "; }
      if ( $opt_H ) { $csh .= "-H "; }
      if ( $opt_o ) { $csh .= "-o "; }
      $csh .= "$expt\n";
   } elsif ( $opt_p ) {
      my $togo = $opt_p - 1;
      if ( $togo > 0 ) { $togo = "-p $togo"; } else { $togo = ''; }
      $csh .= "\n/usr/bin/perl $absfrepp -x $abs_xml_path -t $nextyearf $togo -s -v ";
      if ( $opt_P ) { $csh .= "-P $opt_P "; }
      if ( $opt_T ) { $csh .= "-T $opt_T "; }
      if ( $opt_d ) { $csh .= "-d $opt_d "; }
      if ( $opt_D ) { $csh .= "-D '$opt_D' "; }
      if ( $opt_u ) { $csh .= "-u $opt_u "; }
      if ( $opt_c ) { $csh .= "-c $component "; }
      if ( $opt_m ) { $csh .= "-m '$opt_m' "; }
      if ( $opt_M ) { $csh .= "-M "; }
      if ( $opt_H ) { $csh .= "-H "; }
      if ( $opt_o ) { $csh .= "-o "; }
      $csh .= "$expt\n";
      $csh .= errorstr("$relfrepp had a problem creating next script $expt"."_$nextyearf");
      $csh .= mailerrors($outscript);
   } else { #call frepp -A for analysis scripts
      $csh .= "\n/usr/bin/perl $absfrepp -A -x $abs_xml_path -t $nextyearf -s -v ";
      if ( $opt_P ) { $csh .= "-P $opt_P "; }
      if ( $opt_T ) { $csh .= "-T $opt_T "; }
      if ( $opt_d ) { $csh .= "-d $opt_d "; }
      if ( $opt_u ) { $csh .= "-u $opt_u "; }
      if ( $opt_c ) { $csh .= "-c $component "; }
      if ( $opt_m ) { $csh .= "-m '$opt_m' "; }
      if ( $opt_M ) { $csh .= "-M "; }
      if ( $opt_H ) { $csh .= "-H "; }
      $csh .= "$expt\n";
      $csh .= errorstr("$relfrepp had a problem creating final analysis script $expt"."_$nextyearf");
      $csh .= mailerrors($outscript);
   }

   return $csh;
}

#set up checkpointing
sub setcheckpt {
   my $checkpt = "$component"."_$_[0]";
   unless ( "$_[0]" eq "staticvars" ) { $didsomething = 1;
      #print STDERR "DID SOMETHING: $checkpt\n";
   }
   my $csh = <<EOF;

if ( \$errors_found == 0 ) then
   echo $checkpt > $ppRootDir/.checkpoint/\$checkptfile
endif
if ( -f /home/gfdl/flags/fre/checkpoint.\$HOST || -f /home/gfdl/flags/fre/checkpoint.all || -f /home/gfdl/flags/fre/jobs/checkpoint.\$JOB_ID || -f \$HOME/fre.checkpoint.\$JOB_ID || -f /home/gfdl/flags/fre/jobs/checkpoint.\$PBS_JOBID || -f \$HOME/fre.checkpoint.\$PBS_JOBID ) then
   set now = `date +\%s`
   echo "Exiting early by HPCS request at \$now, will resume with $checkpt"
   Mail -s "\$name job \$JOB_ID has been checkpointed by frepp" \$USER <<END
Your FRE post-processing job ( \$JOB_ID ) has been stopped and resubmitted
to the batch queue.  It will be re-run by the operators as soon as possible
and resume calculating $checkpt.

Job details:
\$name running on \$HOST
Batch job stdout:
\$FRE_STDOUT_PATH
END
   sleep 30
   exit 99
endif
$checkpt:
EOF
   return $csh;
}

#call this to set up a check
#had to use a temp file in case strings get too long, want to preserve end-of-lines.
sub errorstr {
   my $msg = $_[0];
   if ( $opt_Q ) { return ""; }
   my $str = <<EOF;

if ( \$status != 0 ) then
 @ errors_found += 1
 echo "ERROR: $msg"
 echo "ERROR: $msg" >> \$work/.errors
endif

EOF
   return $str;
}

sub retryonerrorstart {
   my $cmd = $_[0];
   if ( $opt_Q ) { return "if ( \$status != 0 ) then\n"; }
   my $str = <<EOF;
   set thisstatus = \$status
   if ( \$thisstatus != 0 ) then
      echo ERROR: $cmd returned status \$thisstatus
      sleep 30
EOF
   return $str;
}

sub retryonerrorend {
   my $msg = $_[0];
   if ( $opt_Q ) { return "endif\n"; }
   my $str = <<EOF;
      set thisstatus = \$status
      if ( \$thisstatus != 0 ) then
         echo ERROR ON RETRY: status \$thisstatus
         @ errors_found += 1
         echo "ERROR: $msg"
         echo "ERROR: $msg" >> \$work/.errors
      else
         echo RETRY SUCCESSFUL.
      endif
   endif

EOF
   return $str;

}

#fatal error - exit script immediately, but email the user the error first
sub fatalerrorstr {
   my $msg = $_[0];
   my $outscript = $_[1];
   if ( $opt_Q ) { return ""; }
   my $createmailfile = mailerrors("$archivedir");
   my $sendemail = mailcomponent();

   my $str = <<EOF;

if ( \$status != 0 ) then
 @ errors_found += 1
 echo "FATAL ERROR: $msg"
 echo "FATAL ERROR: $msg" >> \$work/.errors
 $createmailfile
 cat >> \$work/.errorssend <<END

You will need to resubmit the job when the error conditions are resolved:
$batchSubmit $outscript
END
 $sendemail
 exit 1
endif

EOF
   return $str;
}


#appends the current batch of errors to a text file for mailing to the user
#call this at the end of each piece of postprocessing, or you'll have too few/many messages
sub mailerrors {
   my $outdir = $_[0];
   if ( $opt_Q ) { return ""; }
   my $str = <<EOF;

if ( -e \$work/.errors ) then
  set errorlines = `cat \$work/.errors | wc -l`
  if ( \$errorlines ) then
    cat > \$work/.errorshead <<END

Errors are reported by the shell script created by $relfrepp working in
$outdir
Grep for 'ERROR' in
\$FRE_STDOUT_PATH
for details.
END
    if ( -e \$work/.errorssend ) then
      cat \$work/.errorshead \$work/.errors >> \$work/.errorssend
    else
      cat \$work/.errorshead \$work/.errors > \$work/.errorssend
    endif
  endif
  $time_rm rm -rf \$work/.errors \$work/.errorshead
endif

EOF
   return $str;
}

#mail the user the csh errors that may have accumulated in $work/.errorssend
#call this at the end of each component
sub mailcomponent {
   if ( $opt_Q ) { return ""; }
   my $str = <<EOF;

if ( -e \$work/.errorssend ) then
set errorlines = `cat \$work/.errorssend | wc -l`
if ( \$errorlines ) then
Mail -s "$relfrepp CSH ERROR: $expt $component $hDate" $username < \$work/.errorssend
$writestate
sleep 30
endif
$time_rm rm -rf \$work/.errors*
endif

EOF
   return $str;

}

#if a batch job, build an error string of the bad news from perl
sub mailuser {
   my $msg = $_[0];
   $perlerrors = "ERROR: $msg\n\n$perlerrors";
}

#mail user any errors at end of perl script execution
sub sysmailuser {
   if ( "$perlerrors" ne "" ) {
      my $env = $ENV{'PBS_ENVIRONMENT'};
      if ( "$env" eq "PBS_BATCH" ) {
         #my $outpath = "$stdoutdir\/postProcess\/$pbs_job_name.o\$JOB_ID";
         my $outpath = $ENV{'PBS_O_WORKDIR'};
         my $jobname = $ENV{'PBS_JOBNAME'};
         my $jobid = $ENV{'PBS_JOBID'};
         $jobid =~ s/(\d+)\..*/$1/;
         $outpath .= "/$jobname.o$jobid";
         my $str = <<EOF;
Mail -s "$relfrepp PERL ERROR: $expt $hDate" $username <<END
Error message(s) have been reported by $relfrepp while
creating postprocessing scripts for year $hDate of the
experiment $expt, in the stdout file

$outpath

$perlerrors
END
EOF
         system $str;
         sleep 30;
      }
   }
}

#begin system timings
sub begin_systime {
   my $csh = <<EOF;
echo SYSTEM TIME FOR \$outdir
set systime1 = `$systimecmd`

EOF
   return $csh;
}

#end system timings
sub end_systime {
   my $csh = <<EOF;
set systime2 = `$systimecmd`
@ ttlsystime = \$systime2 - \$systime1
echo TOTAL SYSTEM TIME = \$ttlsystime
set diskusage = `du -ksh \$TMPDIR | cut -f1`
echo TOTAL DISK USAGE IN TMPDIR "\$TMPDIR": \$diskusage
echo '================================================'

EOF
   return $csh;
}

#check whether a job is running
sub isjobrunning {
   my $jobid = $_[0];
   my $cmd = "showq -u $ENV{'USER'} -v";
   my $SHOWQ;
   my $line;
   open($SHOWQ, "$cmd 2>&1 |");
   while ($line = <$SHOWQ>) {
     chomp($line);
     if ( $line =~ /$jobid/ ) { close($SHOWQ); return 1; }
   }
   close($SHOWQ);
   return 0;
}

#set up interpolation on z levels
sub zInterpolate {
   my $zInterp = $_[0];
   my $infile = $_[1];
   my $outfile = $_[2];
   my $caltype = $_[3];
   my $variables = $_[4];
   if ($opt_V) {print STDERR "in zInterpolate, $zInterp $infile $outfile $caltype\n"; }

   my $csh = "";

#set up atmospheric pressure levels
   my $ncep_levels = <<EOF;
echo 'Using zInterp ncep'
set levels = (100000 92500 85000 70000 60000 50000 40000 30000 25000 20000 15000 \\
              10000  7000  5000  3000  2000  1000                               )
EOF
   my $am3_levels = <<EOF;
echo 'Using zInterp am3'
set levels = (100000 92500 85000 70000 60000 50000 40000 30000 25000 20000 15000 \\
              10000  7000  5000  3000  2000  1000   500   300   200   100       )
EOF
   my $hs20_levels = <<EOF;
echo 'Using zInterp hs20'
set levels = ( 2500  7500 12500 17500 22500 27500 32500 37500 42500 47500 \\
               52500 57500 62500 67500 72500 77500 82500 87500 92500 97500 )
EOF
   my $era40_levels = <<EOF;
echo 'Using zInterp era40'
set levels = (100000 92500 85000 77500 70000 60000 50000 40000 30000 25000 20000 15000 \\
                10000  7000  5000  3000  2000  1000   700   500   300   200   100       )
EOF

  my $narcaap_levels = <<EOF;
echo 'Using zInterp narcaap'
set levels = ( 2500  5000  7500  10000  12500  15000 17500 20000 22500 25000 27500 30000 \\
              32500 35000 37500  40000  42500  45000 47500 50000 52500 55000 57500 60000 \\
              62500 65000 67500  70000  72500  75000 77500 80000 82500 85000 87500 90000 \\
              92500 95000 97500 100000 102500 105000 )
EOF
   my $ar5daily_levels = <<EOF;
echo 'Using zInterp ar5daily'
set levels = (100000 85000 70000 50000 25000 10000 5000 1000)
EOF
   my $ncepSubset_levels = <<EOF;
echo 'Using zInterp ncep_subset'
set levels = ( 925 850 700 500 250 )
EOF

   my $set_plevels="";
   if ("$zInterp" eq "ncep") { $set_plevels = $ncep_levels; }
   elsif ("$zInterp" eq "am3") { $set_plevels = $am3_levels; }
   elsif ("$zInterp" eq "hs20") { $set_plevels = $hs20_levels; }
   elsif ("$zInterp" eq "era40") { $set_plevels = $era40_levels; }
   elsif ("$zInterp" eq "narcaap") { $set_plevels = $narcaap_levels; }
   elsif ("$zInterp" eq "ar5daily") { $set_plevels = $ar5daily_levels; }
   elsif ("$zInterp" eq "ncep_subset") { $set_plevels = $ncepSubset_levels; }
   elsif ("$zInterp" eq "zgrid") {}
   else {
      if ( "$zInterp" ne "" ) {
         mailuser("zInterp $zInterp not recognized, not interpolating $outfile");
         print STDERR "ERROR: zInterp $zInterp not recognized, not interpolating $outfile\n";
      }
   }

   my $check_plevel = errorstr("PLEVEL ($outfile)");
   my $check_ncdump = errorstr("NCDUMP ($outfile)");
   my $check_ncks = errorstr("NCKS ($outfile)");
   my $check_zgrid = errorstr("ZGRID (Calling Resample_on_Z for $outfile)");
   my $check_ncatted = errorstr("NCATTED ($outfile)");
   my $plev_command = '$PLEVEL -a';
   if( "$variables" ne "") {
      $variables =~ s/,/ /g;
      $variables =~ s/'//g;
      $variables =~ s/^-v//g;
      $plev_command = '$PLEVEL';
      if ($opt_v) {
         my $count = $variables =~ s/((^|\s)\S)/$1/g;
         print STDERR "NOTE: will interpolate $count variables to pressure levels for $infile\n";
      }
   }

   #atmospheric pressure levels
   if("$zInterp" eq "ncep" or "$zInterp" eq "am3" or "$zInterp" eq "narcaap" or
      "$zInterp" eq "hs20" or "$zInterp" eq "era40" or "$zInterp" eq "ar5daily" or "$zInterp" eq "ncep_subset") {

      $csh .= <<EOF;
   $set_plevels

   set reqvars = `\$NCVARS -st12 $infile | grep -e '^ *bk\$' -e '^ *pk\$' -e '^ *ps\$' -c`
   set hgtvars = `\$NCVARS -st23 $infile | grep -e '^ *temp\$' -e '^ *sphum\$' -e '^ *zsurf\$' -c`

   set vars3d  = `\$NCVARS -st3  $infile`

   if ( \$reqvars == 3 && \$#vars3d > 0 ) then
      set vlist = ()
      if ( \$hgtvars == 3 ) then
         set vlist = (divv rvort hght slp)
      endif
      $time_plevel $plev_command -p "\$levels" -i $infile -o plev.nc \$vlist $variables
      $check_plevel
      set string = `ncdump -h plev.nc | grep UNLIMITED`
      $check_ncdump
      set timename   = `echo \$string[1]`
      set string = `ncdump -h plev.nc | grep calendar_type`
      set caltype   = `echo \$string[3] | sed 's/"//g'`
      if ( "\$caltype" == "" ) set caltype = $caltype
      $time_ncatted ncatted -h -O -a calendar,\$timename,c,c,\$caltype plev.nc
      $check_ncatted
      $time_mv $mv plev.nc $outfile
      $time_rm rm -f $infile
   else
      $time_mv $mv $infile $outfile
   endif
EOF

   } elsif( "$zInterp" eq "zgrid" ) {  #ocean
         if( "$variables" eq "") {
            $variables = "temp,salt,age,u,v";
            print STDERR "NOTE: No variables specified, resampling $variables to zgrid\n";
         } else {
            $variables =~ s/ //;
            $variables =~ s/'//g;
            $variables =~ s/^-v//g;
            if ($opt_v) {
               my $count = $variables =~ s/((^|\s)\S)/$1/g;
               print STDERR "NOTE: will interpolate $count variables to zgrid for $infile\n";
            }
         }
         if( "$platform" eq "ia64" ) {
         $csh .= <<EOF;
    set taxis = `ncdump -h $infile | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
    #set hasclimbounds = `ncdump -h $infile | grep 'climatology_bounds' | wc -l`
    if ( `ncdump -h $infile | grep -c " climatology_bounds("` == 1 ) then
      $time_zgrid /home/fms/local/ia64/v11/Resample_on_Z_new -d/home/rwh/data/regrid_MESO/OM3_zgrid.nc -V:$variables -T:average_T1,average_T2,average_DT,climatology_bounds -ee -o$outfile $infile
      $check_zgrid
    else
      $time_zgrid /home/fms/local/ia64/v11/Resample_on_Z_new -d/home/rwh/data/regrid_MESO/OM3_zgrid.nc -V:$variables -T:average_T1,average_T2,average_DT,\${taxis}_bounds -ee -o$outfile $infile
      $check_zgrid
    endif
EOF
         } else {
         $csh .= <<EOF;
    set taxis = `ncdump -h $infile | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
    #set hasclimbounds = `ncdump -h $infile | grep 'climatology_bounds' | wc -l`
    if ( `ncdump -h $infile | grep -c " climatology_bounds("` == 1 ) then
      $time_zgrid /home/rwh/data/regrid_MESO/Resample_on_Z_new -d/home/rwh/data/regrid_MESO/OM3_zgrid.nc -V:$variables -T:average_T1,average_T2,average_DT,climatology_bounds -ee -o$outfile $infile
      $check_zgrid
    else
      $time_zgrid /home/rwh/data/regrid_MESO/Resample_on_Z_new -d/home/rwh/data/regrid_MESO/OM3_zgrid.nc -V:$variables -T:average_T1,average_T2,average_DT,\${taxis}_bounds -ee -o$outfile $infile
      $check_zgrid
    endif
EOF
         }
   } else {
         $csh .= <<EOF;
      $time_mv $mv $infile $outfile
EOF
   }

   return $csh;
}

#
sub segStartMonths {
   my $segTime = $_[0];
   my $segUnits = $_[1];

   if (($segTime==1 and "$segUnits" eq "years") or ($segTime==12 and "$segUnits" eq "months")) {
      return qw(0101);
   } elsif ( $segTime == 6 ) {
      return qw(0101 0701);
   } elsif ( $segTime == 4 ) {
      return qw(0101 0501 0901);
   } elsif ( $segTime == 3 ) {
      return qw(0101 0401 0701 1001);
   } elsif ( $segTime == 2 ) {
      return qw(0101 0301 0501 0701 0901 1101);
   } elsif ( $segTime == 1 and "$segUnits" eq "months") {
      return qw(0101 0201 0301 0401 0501 0601 0701 0801 0901 1001 1101 1201);
   } else {
      #print STDERR "ERROR: segTime $segTime not supported.  Try 1,2,3,4,6 or 12 month segments.\n" if not $opt_f;
      #return ();
      die "ERROR: segTime $segTime not supported for timeAverages.  Try 1,2,3,4,6 or 12 month segments.\n" if not $opt_f;
   }

}

#make csh for splitting history files into monthly files
sub convertSegments {
   my $segTime = $_[0];
   my $segUnits = $_[1];
   my $diag_source = $_[2];
   my $type = $_[3];
   my $convertSeg="";
   my $convertDec="";

   my $cubicLoopStart = "";
   my $cubicLoopEnd = "";
   my $cubicLinkGridSpec = "";
   if ( "$sourceGrid" eq 'cubedsphere' ) {
      $cubicLoopStart = "set i = 1\nwhile ( \$i <= 6 )";
      $cubicLoopEnd = "@ i ++\nend";
      $diag_source = "$diag_source.tile\$i";
   }

   if ( $segTime == 6 ) {
      if ("$sourceGrid" eq 'cubedsphere') {
      $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0301.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0401.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0501.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0901.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1001.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1101.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
      }
      $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0101.$diag_source.nc \${hDate}0301.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0101.$diag_source.nc \${hDate}0401.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,5,5 \${hDate}0101.$diag_source.nc \${hDate}0501.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,6,6 \${hDate}0101.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0701.$diag_source.nc tmp07.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0701.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0701.$diag_source.nc \${hDate}0901.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0701.$diag_source.nc \${hDate}1001.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,5,5 \${hDate}0701.$diag_source.nc \${hDate}1101.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,6,6 \${hDate}0701.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp07.nc \${hDate}0701.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
      $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,6,6 \${prevyear}0701.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
   } elsif ( $segTime == 2 ) {
      if ("$sourceGrid" eq 'cubedsphere') {
      $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0401.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1001.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
      }
      $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0301.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0301.$diag_source.nc \${hDate}0401.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0301.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0501.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0501.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0501.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0701.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0701.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0701.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0901.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0901.$diag_source.nc \${hDate}1001.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0901.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}1101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}1101.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}1101.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
      $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${prevyear}1101.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
   } elsif ( $segTime == 3 ) {
      if ("$sourceGrid" eq 'cubedsphere') {
      $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0301.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0501.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0901.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1101.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
      }
      $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0101.$diag_source.nc \${hDate}0301.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0401.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0401.$diag_source.nc \${hDate}0501.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0401.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0401.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0701.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0701.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0701.$diag_source.nc \${hDate}0901.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0701.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}1001.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}1001.$diag_source.nc \${hDate}1101.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}1001.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}1001.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
      $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${prevyear}1001.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
   } elsif ( $segTime == 4 ) {
      if ("$sourceGrid" eq 'cubedsphere') {
      $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0301.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0401.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0701.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1001.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1101.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
      }
      $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0101.$diag_source.nc \${hDate}0301.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0101.$diag_source.nc \${hDate}0401.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0501.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0501.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0501.$diag_source.nc \${hDate}0701.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0501.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0501.$diag_source.nc

   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0901.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0901.$diag_source.nc \${hDate}1001.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0901.$diag_source.nc \${hDate}1101.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0901.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0901.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
      $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${prevyear}0901.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
   } elsif (($segTime == 1 and "$segUnits" eq "years") or ($segTime==12 and "$segUnits" eq "months")) {
      if ("$sourceGrid" eq 'cubedsphere') {
      $cubicLinkGridSpec = <<EOF;
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0201.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0301.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0401.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0501.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0601.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0701.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0801.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}0901.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1001.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1101.grid_spec.tile\$i.nc
   ln -s \${hDate}0101.grid_spec.tile\$i.nc \${hDate}1201.grid_spec.tile\$i.nc
EOF
      }
      $convertSeg .= <<EOF;
   $cubicLoopStart
   set string = `ncdump -h \${hDate}0101.$diag_source.nc | grep UNLIMITED`
   set timename   = `echo \$string[1]`
   $time_ncks ncks \$ncksopt -d \$timename,1,1 \${hDate}0101.$diag_source.nc tmp01.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,2,2 \${hDate}0101.$diag_source.nc \${hDate}0201.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,3,3 \${hDate}0101.$diag_source.nc \${hDate}0301.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,4,4 \${hDate}0101.$diag_source.nc \${hDate}0401.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,5,5 \${hDate}0101.$diag_source.nc \${hDate}0501.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,6,6 \${hDate}0101.$diag_source.nc \${hDate}0601.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,7,7 \${hDate}0101.$diag_source.nc \${hDate}0701.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,8,8 \${hDate}0101.$diag_source.nc \${hDate}0801.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,9,9 \${hDate}0101.$diag_source.nc \${hDate}0901.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,10,10 \${hDate}0101.$diag_source.nc \${hDate}1001.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,11,11 \${hDate}0101.$diag_source.nc \${hDate}1101.$diag_source.nc > ncks.out
   $time_ncks ncks \$ncksopt -d \$timename,12,12 \${hDate}0101.$diag_source.nc \${hDate}1201.$diag_source.nc > ncks.out
   $time_mv $mv -f tmp01.nc \${hDate}0101.$diag_source.nc
   $cubicLinkGridSpec
   $cubicLoopEnd
EOF
      $convertDec .= <<EOF;
   $time_ncks ncks \$ncksopt -d \$timename,12,12 \${prevyear}0101.$diag_source.nc \${prevyear}1201.$diag_source.nc > ncks.out
EOF
   } elsif ($segTime != 1 ) {
      print STDERR "ERROR: $diag_source: segTime $segTime not supported for seasonal calculations.  Try 1,2,3,4,6 or 12 month segments.\n";
   }

   if ( "$type" eq "dec" ) { return $convertDec; }
   return $convertSeg;
}

#sort array by interval attribute
sub by_interval {
   my $int1 = $a->findvalue('@interval');
   my $int2 = $b->findvalue('@interval');
   return $int1 <=> $int2;
}

#sort array by chunkLength attribute
sub by_chunk {
   my $int1 = $a->findvalue('@chunkLength');
   my $int2 = $b->findvalue('@chunkLength');
   return $int1 <=> $int2;
}

#return appropriate subinterval
sub get_subint {
   #my $node = $_[0];
   my $interval = "";
   my $name = $_[0]->getName();
   if( "$name" eq "timeSeries" ) {
      $interval = $_[0]->findvalue('@chunkLength');
   } elsif( "$name" eq "timeAverage" ) {
      $interval = $_[0]->findvalue('@interval');
   } else {
      print STDERR "ERROR: nodes of type $name are not supported, only timeSeries and timeAverage\n";
   }
   $interval =~ s/yr$//;
   my $from = $_[0]->findvalue('@from');
   if( "$from" ne "" ) {
      $from =~ s/yr$//;
      return ($interval,$from);
   }
   shift(@_);

   my @ints = map { (my $x = $_) =~ s/yr$//; $x; } @_;
   #if($opt_v){print "nodename is $name, interval is $interval, ints is @ints, from is $from, rest is @_\n";}
   my $subint = undef;
   foreach (@ints) {
      if ( $interval and $_ and $interval > $_ and ($interval % $_) == 0 ) { $subint = $_; }
   }

   #get dependant years
   my @depyears = ();
   my ($thisyear) = FREUtil::splitDate($t0);
   my ($simstart) = FREUtil::splitDate($sim0);

   #print "in get_subint with thisyear=$thisyear, simstart=$simstart, interval=$interval, subint=$subint\n";

   unless ( "$subint" eq '' ) {
      my $i=1;
      while ( ($thisyear-($subint*$i)) > ($thisyear-$interval) and ($thisyear-($subint*$i)) >= $simstart ) {
         if ( ( ($thisyear-$simstart+1) % $interval) == 0 ) {
            push ( @depyears, FREUtil::padzeros($thisyear-($subint*$i)) );
            #print "in get_subint, adding dep=$thisyear-($subint*$i)  --  @depyears\n";
         }
         $i++;
      }
   }

   return ($interval,$subint,@depyears);
}

#least common multiple
sub lcm {
   use integer;
   my $lcm = shift;
   foreach (@_) { $lcm *= $_ / gcd($_, $lcm) }
   no integer;
   return $lcm;
}

#greatest common denominator
sub gcd {
   use integer;
   my $gcd = shift || 1;
   while (@_) {
      my $next = shift;
      while($next) {
         my $r = $gcd % $next;
         $r += $next if $r < 0;
         $gcd = $next;
         $next = $r;
      }
   }
   no integer;
   return $gcd;
}

#create a cpio and dmput original files.  Also dmput only when a cpio is not created.
sub createcpio {
   my $cache = $_[0];
   my $outdir = $_[1];
   my $prefix = $_[2];
   my $abbrev = $_[3];
   my $dmputOnly = $_[4];
   my $csh = "";

   if ( $dmputOnly ) {
      $csh = <<EOF;
cd $outdir
$time_dmput dmput "$prefix.*.nc" &
cd \$work
EOF

   } else {
      $csh = <<EOF;
cd $cache
set numfilestocpio = `ls $prefix.*.nc | wc -l`
if ( \$numfilestocpio > 0 ) then

if ( ! -e $outdir/$prefix.$abbrev.nc.cpio ) then
   ls -1 $prefix.*.nc | $time_mkcpio $cpio -oKvO \$work/$prefix.$abbrev.nc.cpio
   $time_mv $mvfile \$work/$prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$work/$prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
      $checktransfer
   endif
   $time_rm rm \$work/$prefix.$abbrev.nc.cpio
else
   $time_dmget dmget $outdir/$prefix.$abbrev.nc.cpio
   $time_cp $cp $outdir/$prefix.$abbrev.nc.cpio .
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_cp $cp $outdir/$prefix.$abbrev.nc.cpio .
      $checktransfer
   endif
   set files = ( `ls $prefix.*.nc` )
   set filesincpio = ( `$cpio -itI $prefix.$abbrev.nc.cpio` )
   set exist = ()
   foreach file ( \$files )
     foreach fileincpio ( \$filesincpio )
         if ( "\$file" == "\$fileincpio" ) then
            set exist = ( \$exist \$file )
         endif
     end
   end
   if ( \$#exist == 0 ) then
      ls -1 $prefix.*.nc | $time_mkcpio $cpio -oKvAO $prefix.$abbrev.nc.cpio
      $time_mv $mvfile $prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
         $checktransfer
      endif
      $time_rm rm $prefix.$abbrev.nc.cpio
   else
      mkdir \$work/mkcpio
      cd \$work/mkcpio
      $time_uncpio $cpio -ivI $outdir/$prefix.$abbrev.nc.cpio
      cd $outdir
      #this is a local cp within vftmp
      $time_cp cp \$files \$work/mkcpio
      cd \$work/mkcpio
      ls -1 $prefix.*.nc | $time_mkcpio $cpio -oKvO $prefix.$abbrev.nc.cpio
      $time_mv $mvfile $prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $prefix.$abbrev.nc.cpio $outdir/$prefix.$abbrev.nc.cpio
         $checktransfer
      endif
      cd \$work
      $time_rm rm -rf \$work/mkcpio
   endif
endif

cd $outdir
$time_dmput dmput "$prefix.*.nc" &
$time_dmput dmput  $prefix.$abbrev.nc.cpio &

endif
cd \$work
EOF
   }

   return $csh;
}

#get appropriate number of time levels in a time series file
sub gettimelevels {
   my $freq = $_[0];
   my $cl = $_[1];
   $cl =~ s/yr//;

   if( "$freq" =~ /daily/ or "$freq" =~ /day/) {
      return 365*$cl;
   } elsif( "$freq" =~ /mon/ ) {
      return 12*$cl;
   } elsif( "$freq" =~ /ann/ or "$freq" =~ /yr/ or "$freq" =~ /year/) {
      return $cl;
   } elsif( "$freq" =~ /hour/ or "$freq" =~ /hr/ ) {
      my $n = $freq;
      $n =~ s/hr$//;
      if ( $n =~ /^\d+$/ and $n != 0 ) {
         return 365*24*$cl/$n;
      } else {
         return 365*24*$cl;
      }
   } elsif( "$freq" =~ /season/ ) {
      return 1*$cl;  #only one season per year per file, so this must be 1
   } else{
      print STDERR "WARNING: frequency not recognized in gettimelevels\n";
      return $cl;
   }
}

#get the name of the diagnostic output file from the source attribute
sub diagfile {
   my $ppcNode = $_[0];
   my $freq = $_[1];
   my $src = $_[2];
   my $diag_source = "";
   #STATIC
   #TIMESERIES - ANNUAL or SEASONAL
   if ($src eq "annual" or $src eq "seasonal") {
      my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
      if ( scalar @monthnodes ) {
        my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
        $diag_source = $monthnode->getAttribute('@source');
      }
      if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('@source'); }
      if( "$diag_source" eq "") { $diag_source = $component."_month"; }
   }

   #TIMESERIES - from smaller timeSeries
   if ($src ne "seasonal"  and $src ne "annual" ) {
      my @nodes = $ppcNode->findnodes("timeSeries[\@freq='$freq']");
      if ( scalar @nodes ) {
       my $node = $ppcNode->findnodes("timeSeries[\@freq='$freq']")->get_node(1);
       $diag_source = $node->getAttribute('@source');
      }
      if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('@source'); }
      if( "$diag_source" eq "") { $diag_source = $component."_month"; }
   }
   return $diag_source;
}

#TIMESERIES - ANNUAL
sub annualTS {
   #tsNode = $_[0] ;
   my $sim0 = $_[1];
   my $startofrun = $_[2];
   my $diagtablecontent = $_[3];
   my $ppcNode = $_[0]->parentNode;

   my $freq = 'annual';
   my $source = 'monthly'; #always use monthly, don't need $tsNode->findvalue('@source');
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $outdirpath = "$component/ts/$freq/$chunkLength";
   my $outdir = "$ppRootDir/$outdirpath";
   if("$chunkLength" eq "") {
         mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
         print STDERR "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
         return "";
   }
   #need timeSeries freq=monthly chunkLength=something.  Then split apart into yearly data.
   #prefer identical chunklength if available
   my $TSchunkLength = "";
   my $desiredts = "timeSeries[\@freq='monthly' and \@chunkLength='$chunkLength']\n";
   foreach my $node ( $ppcNode->findnodes("$desiredts") ) {
      $TSchunkLength = $node->findvalue('@chunkLength');
      if( "$TSchunkLength" ne "") {
         print STDERR "will use monthly_ts cl=$TSchunkLength\n" if $opt_v;
         last;
      }
   }

   #otherwise use whatever is available, but we don't support 1yr for now
   if( "$TSchunkLength" eq "" ) {
      my $requiredts = "timeSeries[\@freq='monthly']\n";
      foreach my $node ( $ppcNode->findnodes("$requiredts") ) {
         $TSchunkLength = $node->findvalue('@chunkLength');
         if( "$TSchunkLength" ne "" and "$TSchunkLength" ne "1yr") {
            print STDERR "will use monthly_ts cl=$TSchunkLength\n" if $opt_v;
            last;
         }
      }
   }

   my $reqpath = "\$tempCache/$component/ts/monthly/$TSchunkLength";

   if( "$TSchunkLength" eq "" ) {
      my @existing = <$reqpath/*/*>;
      if ( scalar(@existing) eq 0 ) {
         #if have annual diag data, this TS can be created with directTS
         my $mysource = $_[0]->findvalue('@source');
         if ( "$mysource" eq "" ) { $mysource = $ppcNode->findvalue('@source'); }
         my @dtc = split("\n",$diagtablecontent);
         my @sourcelines = grep( /^\s*['"]$mysource['"]/, @dtc );
         my @fd = split(/,/,$sourcelines[0]);
         if ( ( $fd[1] == "1" and $fd[2] =~ /year/ ) or ( $fd[1] == "12" and $fd[2] =~ /month/ ) ) {
            print STDERR "using history file $mysource\n" if $opt_v;
            return directTS( $_[0], $sim0, $startofrun );
         } else {
            mailuser("Cannot create $component $freq timeSeries unless you generate <timeSeries freq='monthly' chunkLength='Xyr'>");
            print STDERR "\nERROR: Cannot create $component $freq timeSeries unless you generate <timeSeries freq='monthly' chunkLength='Xyr'>\n";
            return "";
         }
      } else {
         my @reqfiles = <$reqpath/*>;
         chomp( $TSchunkLength = `ls -1 $reqpath | sort -g | head -1` );
         $TSchunkLength =~ s/$reqpath//;
         $TSchunkLength =~ s/\///g;
         print STDERR "$component $freq timeSeries calculation found data at ts/monthly/$TSchunkLength\n" if $opt_v;
      }
      $reqpath = "\$tempCache/$component/ts/monthly/$TSchunkLength";
   }

   my $tmp = FREUtil::modifydate($tEND,"+1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $int = $TSchunkLength;
   $int =~ s/yr//;
   my $mod = $yrsSoFar % $int;
   if( $mod != 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   my $cl = $chunkLength;
   $cl =~ s/yr//;
   if( $int > $maxyrs ) { $maxyrs = $int; }
   #this is not exactly right.  You need to make it not do any annualTS till $cl and to leave it in $TMP till everything's done.
   #then change this to $cl

   #check that all files up to current time exist
   my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
   my $diag_source = "";
   if ( scalar @monthnodes ) {
     my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
     $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if( "$diag_source" eq "") { $diag_source = $component."_month"; }

   #get variables
   my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
   $variables =~ s/ /.nc /g;
   if("$variables" ne "") {$variables =~ s/$/.nc/g};

   my $tBEG = FREUtil::modifydate($tEND,"-$int years +1 sec");
   my $tBEGf = FREUtil::graindate($tBEG,'monthly');
   my $tENDf = FREUtil::graindate($tEND,'monthly');
   my $check_ncdump = errorstr("NCDUMP ($component $freq ts from $source)");
   my $check_ncks = errorstr("NCKS ($component $freq ts from $source)");
   my $check_timavg = retryonerrorend("TIMAVG ($component $freq ts from $source)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_ncrcat = errorstr("NCRCAT ($component $freq ts from $source)");
   my $check_ncatted = errorstr("NCATTED ($component $freq ts from $source)");
   my $check_dmget = errorstr("DMGET ($component $freq ts from $source)");
   my $csh = setcheckpt("annualTS_$chunkLength");
   $csh .= <<EOF;

#####################################
echo 'timeSeries ($component $freq ts from $source)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath
EOF
   if ($opt_z) { $csh .= begin_systime(); }
   foreach my $chunkyear (0 .. ($int-1)) {
      my $tYEAR = FREUtil::modifydate($tBEG,"+ $chunkyear years");
      my $tYEARf = FREUtil::graindate($tYEAR,'annual');
      my $startmonth = $chunkyear * 12 + 1;
      my $endmonth = $startmonth + 11;
      #if it is time, chunk the files`
      #if tYEARf-sim0 % chunklength == 0 then cat files to outfile
      my $catfiles = "";
      my $makecpio = "";
      my $getlist = "";
      my $chunkedoutfile = "";
      #print "tYEARf=$tYEARf sim0=$sim0 cl=$cl\n";
      if ( ($tYEARf-FREUtil::graindate($sim0,'annual') + 1) % $cl == 0 ) {
         my $n = $cl-1;
         my $begin = FREUtil::modifydate($tYEAR,"- $n years");
         $begin = FREUtil::graindate($begin,'annual');
         $chunkedoutfile = "$component.$begin-$tYEARf.\$var";
         my $filelist = "";
         foreach my $year ($begin .. $tYEARf) {
            $year=FREUtil::padzeros($year);
            $filelist .= "\$tempCache/$component.$year.\$var ";
            $getlist .= "$component.$year.*.nc ";
         }
         if ( $aggregateTS ) {
            $makecpio = createcpio( "\$tempCache/$outdirpath", $outdir,"$component.$begin-$tYEARf",FREUtil::timeabbrev($freq),1);
         }
         $catfiles = <<EOF;
if ( -e $chunkedoutfile ) rm -f $chunkedoutfile
$time_ncrcat ncrcat \$ncrcatopt $filelist $chunkedoutfile
$check_ncrcat
$time_ncatted ncatted -h -O -a filename,global,m,c,"$chunkedoutfile" $chunkedoutfile
$check_ncatted
$time_mv $mvfile $chunkedoutfile $outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $chunkedoutfile $outdir/
   $checktransfer
endif
$time_mv $mv $chunkedoutfile \$tempCache/$outdirpath/
$time_rm rm -f $filelist
EOF
      }

      #set up loop over variables
      my $forloop = "";
      if ("$variables" eq "") {
         $forloop = <<EOF;
  foreach file ( $reqpath/$component.$tBEGf-$tENDf.*.nc )
    set var = `echo \$file | sed "s#.*/##;s/$component.$tBEGf-$tENDf.//"`
EOF
      } else {
         $forloop .= <<EOF;
  foreach var ( $variables )
    set file = $reqpath/$component.$tBEGf-$tENDf.\$var
EOF
      }

      $csh .= <<EOF;

$forloop
    if ( $chunkyear == 0 ) then
      $time_cp $cp \$file .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp \$file .
         $checktransfer
      endif
    endif
    set file = "./\$file:t"
    set string = `ncdump -h \$file | grep UNLIMITED`
    $check_ncdump
    set timename   = `echo \$string[1]`
    $time_ncks ncks \$ncksopt -d \$timename,$startmonth,$endmonth \$file year.nc > ncks.out
    $check_ncks
    $time_timavg \$TIMAVG -o \$tempCache/$component.$tYEARf.\$var year.nc
    $retry_timavg
       $time_timavg \$TIMAVG -o \$tempCache/$component.$tYEARf.\$var year.nc
    $check_timavg
    $time_rm rm -f year.nc
    $catfiles
  end
  $makecpio
  else
    echo ERROR: Error: input files do not exist
  endif

EOF

   }
   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);
   return $csh;
}

#TIMESERIES - SEASONAL
sub seasonalTS {
   #tsNode = $_[0] ;
   my $sim0 = $_[1];
   my $ppcNode = $_[0]->parentNode;
   my $freq = 'seasonal';
   my $source = 'monthly'; #always use monthly, don't need $tsNode->findvalue('@source');
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $outdirpath = "$component/ts/$freq/$chunkLength";
   my $outdir = "$ppRootDir/$outdirpath";

      #check if need to convert cube sphere grid to lat lon
      if ( "$sourceGrid" eq 'cubedsphere' ) {
         print STDERR "WARNING: Calculating seasonal timeseries from cubed sphere data is not supported in this version of frepp.  Skipping.  To avoid this error message, edit your xml to remove the request for seasonal timeseries for cubed sphere components.\n";
         mailuser("WARNING: Calculating seasonal timeseries from cubed sphere data is not supported in this version of frepp.  Skipping.  To avoid this error message, edit your xml to remove the request for seasonal timeseries for cubed sphere components.");
         return "";
      }

   if("$chunkLength" eq "") {
         mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
         print STDERR "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
         return "";
   }
   #need timeSeries freq=monthly chunkLength=something.  Then split apart into yearly data.
   my $requiredts = "timeSeries[\@freq='monthly']\n";
   my $TSchunkLength = "";
   foreach my $node ( $ppcNode->findnodes("$requiredts") ) {
      $TSchunkLength = $node->findvalue('@chunkLength');
      if( "$TSchunkLength" ne "" ) {
         print STDERR "will use monthly_ts cl=$TSchunkLength\n" if $opt_v;
         last;
      }
   }
   my $reqpath = "$component/ts/monthly/$TSchunkLength";
   if( "$TSchunkLength" eq "" ) {
      my @existing = <$ppRootDir/$reqpath/*/*>;
      if ( scalar(@existing) eq 0 ) {
         mailuser("Cannot create $component $freq timeSeries unless you generate <timeSeries freq='monthly' chunkLength='Xyr'>");
         print STDERR "\nERROR: Cannot create $component $freq timeSeries unless you generate <timeSeries freq='monthly' chunkLength='Xyr'>\n";
         return "";
      } else {
         my @reqfiles = <$ppRootDir/$reqpath/*>;
         chomp( $TSchunkLength = `ls -1 $ppRootDir/$reqpath | sort -g | head -1` );
         $TSchunkLength =~ s/$ppRootDir\/$reqpath//;
         $TSchunkLength =~ s/\///g;
         print STDERR "$component $freq timeSeries calculation found data at ts/monthly/$TSchunkLength\n" if $opt_v;
      }
      $reqpath = "$component/ts/monthly/$TSchunkLength";
   }
   if ($opt_v) {print "      TSchunkLength is $TSchunkLength\n";}
   my $tmp = FREUtil::modifydate($tEND,"+1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $int = $TSchunkLength;
   $int =~ s/yr//;
   my $cl = $chunkLength;
   $cl =~ s/yr//;
   my $lcmchunk = lcm($int,$cl);
   my $mod = $yrsSoFar % $lcmchunk;
   if( $mod != 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $cl > $maxyrs ) { $maxyrs = $cl; }

   #check that all files up to current time exist
   my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
   my $diag_source = "";
   if ( scalar @monthnodes ) {
     my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
     $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if( "$diag_source" eq "") { $diag_source = $component."_month"; }

   #set dates
   my $tENDprev = FREUtil::modifydate($tEND,"- $lcmchunk years");
   my $tBEG = FREUtil::modifydate($tENDprev,"+ 1 sec");
   my $tBEGf = FREUtil::graindate($tBEG,'monthly');
   my $tENDf = FREUtil::graindate($tEND,'monthly');
   my $tENDprevf = FREUtil::graindate($tENDprev,'monthly');
   my $prevyear = FREUtil::graindate($tENDprev,'year');

   #get variables
   my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   my $forloop = "";
   if ("$variables" eq "") {
      $forloop = <<EOF;
  foreach file ( \$tempCache/$reqpath/$component.$tBEGf-$tENDf.*.nc )
    set var = `echo \$file | sed "s#.*/##;s/$component.$tBEGf-$tENDf.//"`
EOF
   } else {
      print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
      $variables =~ s/ /.nc /g;
      if("$variables" ne "") {$variables =~ s/$/.nc/g};
      $forloop .= <<EOF;
  foreach var ( $variables )
    set file = \$tempCache/$reqpath/$component.$tBEGf-$tENDf.\$var
EOF
   }

   my $check_ncks = errorstr("NCKS ($component seasonal ts)");
   my $check_ncdump = errorstr("NCDUMP ($component seasonal ts)");
   my $check_ncrcat = errorstr("NCRCAT ($component seasonal ts)");
   my $check_timavg = retryonerrorend("TIMAVG ($component seasonal ts)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_ncatted = errorstr("NCATTED ($component seasonal ts)");
   my $check_dmget = errorstr("DMGET ($component seasonal ts)");
   my $check_splitncvars = errorstr("SPLITNCVARS ($component seasonal ts)");
   my $check_cpio = errorstr("CPIO/TAR ($component seasonal ts)");
   my $csh = setcheckpt("seasonalTS_$chunkLength");
   $csh .= <<EOF;

#####################################
echo 'timeSeries ($component seasonal from monthly ts )'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath
#$time_dmget dmget -d $reqpath "$component.$tBEGf-$tENDf.*.nc"
EOF
   if ($opt_z) { $csh .= begin_systime(); }
   my $totalseasons = 4 * $lcmchunk;
   my $startseason = 1;
   my $startflag = FREUtil::dateCmp($tBEG,$sim0);

   foreach my $season ($startseason .. $totalseasons) {
      my $nummonths = $season * 3 - 4;
      my $tSEASON = FREUtil::modifydate($tBEG,"+ $nummonths months");
      my $tSEASONf = FREUtil::graindate($tSEASON,'seasonal');
      my ($year) = $tSEASONf =~ /(\d{4,})\./;
      my $catfiles = "";
      my $makecpio = "";
      my $tmp = FREUtil::graindate($sim0,'annual');
      #if it is time, chunk the files.  only put chunked files into archive now.
      if ( ($year-$tmp + 1) % $cl == 0 ) {
         $tmp = $year-$tmp + 1;
         my ($abbrev) = $tSEASONf =~ /\d{4,}\.(\w{3})/;
         my $begin = FREUtil::padzeros($year - $cl + 1);
         my $chunkedoutfile = "$component.$begin-$year.$abbrev.\$var";
         my $filelist = "";
         foreach my $year ($begin .. $year) {
            $year=FREUtil::padzeros($year);
            $filelist .= "$component.$year.$abbrev.\$var ";
         }
         if( $abbrev =~ "SON" and $aggregateTS ) {
            $makecpio = createcpio( "\$tempCache/$outdirpath",$outdir,"$component.$begin-$year",FREUtil::timeabbrev($freq),1 );
         }
         $catfiles = <<EOF;
if ( -e $chunkedoutfile ) rm -f $chunkedoutfile
$time_ncrcat ncrcat \$ncrcatopt $filelist $chunkedoutfile
$check_ncrcat
$time_mv $mvfile $chunkedoutfile \$outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $chunkedoutfile \$outdir/
   $checktransfer
endif
$time_mv $mv $chunkedoutfile \$tempCache/$outdirpath/
$time_rm rm -f $filelist

EOF
      }
      if ( $season == 1 ) {
         if ( $startflag == 0 ) {
########################## FIRST DJF OF RUN ################################
            $csh .= <<EOF;
  #season $season ($tSEASONf) note: december used twice
$forloop
    if ( ! -f \$file ) then
      if ( -f $ppRootDir/$reqpath/\$file:t ) then
         $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
         if ( \$status ) then
            echo "WARNING: data transfer failure, retrying..."
            $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
            $checktransfer
         endif
      else
         echo ERROR: necessary file not found: $ppRootDir/$reqpath/\$file:t
      endif
    endif
    set string = `ncdump -h \$file | grep UNLIMITED`
    set timename   = `echo \$string[1]`
    $time_ncks ncks \$ncksopt -d \$timename,1,2 -d \$timename,12,12 \$file janfeb.nc > ncks.out
    $check_ncks
    $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var janfeb.nc
    $retry_timavg
       $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var janfeb.nc
    $check_timavg
    $time_rm rm -f janfeb.nc
    $catfiles
  end

EOF
         } else {
########################## FIRST DJF OF THIS PP ################################
            my $check_prev = errorstr("Could not acquire previous december");
            my $check_hist = errorstr("Could not acquire previous december from history file");
            $csh .= <<EOF;
  #season $season ($tSEASONf)
#$time_dmget dmget -d $reqpath "$component.*-$tENDprevf.*.nc"
$forloop
    if ( ! -f \$file ) then
      if ( -f $ppRootDir/$reqpath/\$file:t ) then
         $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
         if ( \$status ) then
            echo "WARNING: data transfer failure, retrying..."
            $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
            $checktransfer
         endif
      else
         echo ERROR: necessary file not found: $ppRootDir/$reqpath/\$file:t
      endif
    endif
    set string = `ncdump -h \$file | grep UNLIMITED`
    set timename   = `echo \$string[1]`
    $time_ncks ncks \$ncksopt -d \$timename,1,2 \$file janfeb.nc > ncks.out
    $check_ncks
    #get december from previous file
    set prev = (`ls ./$component.*-$tENDprevf.\$var`)
    if ( "\$prev" == "" ) then
      set prev = (`ls $ppRootDir/$reqpath/$component.*-$tENDprevf.\$var`)
      $time_cp $cp \$prev .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp \$prev .
         $checktransfer
      endif
      set prev = "./\$prev:t"
    endif
    if ( "\$prev" == "" && -e "$ppRootDir/$reqpath/$component.*-$tENDprevf.mon.nc.cpio") then
      $time_dmget dmget -d $ppRootDir/$reqpath "$component.*-$tENDprevf.mon.nc.cpio"
      $time_cp $cp $ppRootDir/$reqpath/$component.*-$tENDprevf.mon.nc.cpio .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $ppRootDir/$reqpath/$component.*-$tENDprevf.mon.nc.cpio .
         $checktransfer
      endif
      $time_uncpio $uncpio -ivI $component.*-$tENDprevf.mon.nc.cpio '*12.*.nc'
      $time_dmput dmput $reqpath "$component.*-$tENDprevf.mon.nc.cpio" &
      set prev = (`ls ./$component.*-$tENDprevf.\$var`)
    endif
    if ( "\$prev" != "" ) then
       set decstring = `ncdump -h \$prev | grep UNLIMITED`
       $check_ncdump
       @ len = \$#decstring - 1
       set length = `echo \$decstring[\$len] | cut -c2-`
       $time_ncks ncks \$ncksopt -d \$timename,\$length,\$length \$prev dec.nc > ncks.out
       $check_ncks
EOF

   #might need to get the data from the history file if previous pp is not done
   my $convertDec=convertSegments($segTime,$segUnits,$diag_source,'dec');
   #check for zInterp
   my $zInterp = $ppcNode->findvalue('@zInterp');
   my $zInterp_csh = "";
   if ( "$zInterp" ne "" ) {
      $zInterp_csh = zInterpolate($zInterp,"\${prevyear}1201.$diag_source.nc",'tmp.nc',$caltype,$variables);
      $zInterp_csh .= "\nmv -f tmp.nc \${prevyear}1201.$diag_source.nc";
   }

   my $prevhistcpio = "$prevyear"."0101.nc.cpio";
   my $prevhisttar = "$prevyear"."0101.nc.tar";
   $csh .= <<EOF;
    else
       if ( ! -e \$var ) then
            set prevyear = $prevyear
            if ( ! -e \${prevyear}1201.$diag_source.nc ) then
               if ( -e $opt_d/$prevhistcpio ) then
                  $time_dmget dmget "$opt_d/$prevhistcpio"
                  $time_uncpio $uncpio -ivI $opt_d/$prevhistcpio '*.$diag_source.nc'
                  $check_cpio
                  $time_dmput dmput "$opt_d/$prevhistcpio" &
               else if ( -e $opt_d/$prevhisttar ) then
                  $time_dmget dmget "$opt_d/$prevhisttar"
                  $time_untar tar -xvf $opt_d/$prevhisttar --wildcards '*.$diag_source.nc'
                  $check_cpio
                  $time_dmput dmput "$opt_d/$prevhisttar" &
               else
                  echo ERROR: Previous December (\${prevyear}1201.$diag_source.nc) is not available for seasonal calculations
                  exit 1
               endif
               set string = `ncdump -h \${prevyear}0101.$diag_source.nc | grep UNLIMITED`
               set timename   = `echo \$string[1]`
               $convertDec
               $zInterp_csh
            endif
            $time_splitncvars \$SPLITNCVARS -v \$var:r \${prevyear}1201.$diag_source.nc
            $check_splitncvars
       endif
       test -e \$var
       $check_hist
       $time_mv $mv \$var dec.nc
    endif
    test -e dec.nc
    $check_prev

    if ( -e decjanfeb.nc ) rm -f decjanfeb.nc
    $time_ncrcat ncrcat \$ncrcatopt dec.nc janfeb.nc decjanfeb.nc
    $check_ncrcat
    $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var decjanfeb.nc
    $retry_timavg
       $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var decjanfeb.nc
    $check_timavg
    $time_rm rm -f janfeb.nc dec.nc decjanfeb.nc
    $catfiles
  end

EOF
         }
       } else {
########################## REMAINING SEASONS ################################
         my $startmonth = $season * 3 - 3;
         my $endmonth   = $season * 3 - 1;
         $csh .= <<EOF;
  #season $season ($tSEASONf)
$forloop
    if ( ! -f \$file ) then
      if ( -f $ppRootDir/$reqpath/\$file:t ) then
         $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
         if ( \$status ) then
            echo "WARNING: data transfer failure, retrying..."
            $time_cp $cp $ppRootDir/$reqpath/\$file:t \$file
            $checktransfer
         endif
      else
         echo ERROR: necessary file not found: $ppRootDir/$reqpath/\$file:t
      endif
    endif
    set string = `ncdump -h \$file | grep UNLIMITED`
    set timename   = `echo \$string[1]`
    $time_ncks ncks \$ncksopt -d \$timename,$startmonth,$endmonth \$file season.nc > ncks.out
    $check_ncks
    $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var season.nc
    $retry_timavg
       $time_timavg \$TIMAVG -o $component.$tSEASONf.\$var season.nc
    $check_timavg
    $time_rm rm -f season.nc
    $catfiles
  end
  $makecpio

EOF
       }
   }
   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);
   return $csh;
}

#TIMEAVERAGES - MONTHLY
sub monthlyAVfromhist {
   #taNode = $_[0] ;
   my $sim0 = $_[1];
   my $ppcNode = $_[0]->parentNode;
   #check for appropriate segment lengths
   my @reqStartMonths = segStartMonths($segTime,$segUnits);

   my $src = 'monthly';
   my $interval = $_[0]->findvalue('@interval');
   my $outdir = "$ppRootDir/$component/av/$src"."_$interval";
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $tmp = FREUtil::modifydate($tEND,"+ 1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $int = $interval;
   $int =~ s/yr//;
   my $mod = $yrsSoFar % $int;
   unless( $mod == 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $int > $maxyrs ) { $maxyrs = $int; }

   my $hDateyr = $userstartyear;
   my @hDates = ( FREUtil::padzeros($hDateyr-$int+1) .. "$hDateyr" );

   my $sim0f = FREUtil::graindate($sim0,$src);
   my $t0f = FREUtil::graindate($t0,$src);
   my $tENDf = FREUtil::graindate($tEND,$src);
   my $range = FREUtil::graindate($tEND,'year');
   if (scalar @hDates > 1) { $range = FREUtil::padzeros($range-$int+1)."-$range"; }
   foreach my $d (@hDates) { $historyfiles .= "$d"."0101.nc.tar "; }

   my $diag_source =  $_[0]->findvalue('@diag_source');
   my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
   if ( scalar @monthnodes and "$diag_source" eq "" ) {
    my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
    $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if ( "$diag_source" eq "") { $diag_source = $component."_month"; }

   #get variables
   my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   $variables =~ s/ /,/g;

   my $zInterp = $ppcNode->findvalue('@zInterp');
   my $do_zInterp = 0;
   if ("$zInterp" ne "") {  $do_zInterp = 1; }
   my $convertSeg=convertSegments($segTime,$segUnits,$diag_source);
   my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
   #my $check_cpio = errorstr("CPIO ($component $src $interval averages)");
   my $check_cpio_msg = "CPIO ($component $src $interval averages)";
   my $check_ncrcat = errorstr("NCRCAT ($component $src $interval averages)");
   my $check_timavg = retryonerrorend("TIMAVG ($component $src $interval averages)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_plevel = errorstr("PLEVEL ($component $src $interval averages)");
   my $check_ncdump = errorstr("NCDUMP ($component $src $interval averages)");
   my $check_fregrid = errorstr("FREGRID ($component $src $interval averages)");
   my $check_ncrename = errorstr("NCRENAME ($component $src $interval averages)");


   my $csh = setcheckpt("monthlyAVfromhist_$interval");
   $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
EOF
   if ($opt_z) { $csh .= begin_systime(); }
   if ( "$sourceGrid" eq 'cubedsphere' ) { #IF CUBIC
      my $tile = '.tile$i';

      $csh .= <<EOF;
   foreach hDate ( @hDates )
      foreach file ( `ls \$histDir/\$hDate*/*.$diag_source.tile*nc`)
        ln -s \$file .
      end
      foreach file ( `ls \$histDir/\$hDate*/*.grid_spec.tile*.nc`)
        ln -s \$file .
      end
   end
   foreach hDate ( @hDates )
   $convertSeg
   end

set month = 1
while (\$month <= 12)
set i = 1
while ( \$i <= 6 )

   set monthf = `echo \$month | sed 's/.*/0&/;s/.\\(..\\)/\\1/'`
   set histmonth = "\$monthf"

   $time_ncrcat ncrcat \$ncrcatopt *\${histmonth}01.$diag_source$tile.nc month.nc
   $check_ncrcat
   $time_rm rm -f *\${histmonth}01.$diag_source$tile.nc
EOF

   if ( $do_zInterp ) {
      $csh .= <<EOF;
      $time_timavg \$TIMAVG -o modellevels.nc month.nc
      $retry_timavg
         $time_timavg \$TIMAVG -o modellevels.nc month.nc
      $check_timavg
      $time_rm rm -f month.nc
EOF
      $csh .= zInterpolate($zInterp,'modellevels.nc',"$hDates[0]\${histmonth}01.$diag_source$tile.nc",$caltype,$variables);

   } else { #no zinterp
      $csh .= <<EOF;
      $time_timavg \$TIMAVG -o $hDates[0]\${histmonth}01.$diag_source$tile.nc month.nc
      $retry_timavg
         $time_timavg \$TIMAVG -o $hDates[0]\${histmonth}01.$diag_source$tile.nc month.nc
      $check_timavg
      $time_rm rm -f month.nc
EOF
   }

   if ( "$xyInterp" ne '' ) { #CUBIC to LATLON

   my $fregrid_wt = '';
   if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
      print "       land_frac found, weighting exchange grid cell with $hDates[0]\${histmonth}01.land_static\n" if $opt_v;
      $fregrid_wt = "--weight_file $hDates[0]\${histmonth}01.land_static --weight_field land_frac";
   }
   my $call_and_check_fregrid = $call_tile_fregrid;
   $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
   $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
   $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
   $csh .= <<EOF;
@ i ++
end

   set fregrid_wt = "$fregrid_wt"
   set fregrid_in_date = $hDates[0]\${histmonth}01
   set fregrid_in = $hDates[0]\${histmonth}01.$diag_source
   set nlat = $nlat ; set nlon = $nlon
   set interp_method = $interpMethod
   set ncvars_arg = -st23
   set variables = ( $variables )
   set fregrid_remap_file = $xyInterpRegridFile
   $call_and_check_fregrid

   mv \$fregrid_in.nc $component.$range.\$monthf.nc
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$range.\$monthf.nc" $component.$range.\$monthf.nc
   $check_ncatted

   $time_mv $mvfile $component.$range.\$monthf.nc \$outdir/$component.$range.\$monthf.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile $component.$range.\$monthf.nc \$outdir/$component.$range.\$monthf.nc
      $checktransfer
   endif
   $time_rm rm $component.$range.\$monthf.nc
   $time_dmput dmput \$outdir/$component.$range.\$monthf.nc &

EOF

} else { #CUBIC - no conversion
   $csh .= <<EOF;
   mv $hDates[0]\${histmonth}01.$diag_source$tile.nc $component.$range.\$monthf$tile.nc
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$range.\$monthf$tile.nc" $component.$range.\$monthf$tile.nc
   $check_ncatted
   $time_mv $mvfile $component.$range.\$monthf$tile.nc \$outdir/$component.$range.\$monthf$tile.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile $component.$range.\$monthf$tile.nc \$outdir/$component.$range.\$monthf$tile.nc
      $checktransfer
   endif
   $time_rm rm $component.$range.\$monthf$tile.nc
   $time_dmput dmput \$outdir/$component.$range.\$monthf$tile.nc &
   @ i++
end
EOF
}

   $csh .= <<EOF;
   @ month++
end

EOF

   } else { #IF NOT CUBIC

      $csh .= <<EOF;
foreach hDate ( @hDates )
   foreach file ( `ls \$histDir/\$hDate*/*.$diag_source.nc`)
     ln -s \$file .
   end
   $convertSeg
end
set month = 1
while (\$month <= 12)
   set monthf = `echo \$month | sed 's/.*/0&/;s/.\\(..\\)/\\1/'`
   set histmonth = "\$monthf"

   if ( -e month.nc ) rm -f month.nc
   $time_ncrcat ncrcat \$ncrcatopt *\${histmonth}01.$diag_source.nc month.nc
   $check_ncrcat
   $time_rm rm -f *\${histmonth}01.$diag_source.nc
EOF

      if ( $do_zInterp ) {
         $csh .= <<EOF;
   $time_timavg \$TIMAVG -o modellevels.nc month.nc
   $retry_timavg
      $time_timavg \$TIMAVG -o modellevels.nc month.nc
   $check_timavg
EOF
         $csh .= zInterpolate($zInterp,'modellevels.nc',"$component.$range.\$monthf.nc",$caltype,$variables);
      } else {
         $csh .= <<EOF;
   $time_timavg \$TIMAVG -o $component.$range.\$monthf.nc month.nc
   $retry_timavg
      $time_timavg \$TIMAVG -o $component.$range.\$monthf.nc month.nc
   $check_timavg
EOF
      }

      # convert latlon/tripolar to latlon
      if ( "$xyInterp" ne '' ) {
            my $fregrid_wt = '';
            if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
               print "       land_frac found, weighting exchange grid cell with $hDates[0]\${histmonth}01.land_static\n" if $opt_v;
               $fregrid_wt = "--weight_file $hDates[0]\${histmonth}01.land_static --weight_field land_frac";
            }
            my $call_and_check_fregrid = $call_fregrid;
            $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
            $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
            $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
            $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDates[0]\${histmonth}01
    set fregrid_in = "$component.$range.\$monthf"
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

EOF
      }

      $csh .= <<EOF;
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$range.\$monthf.nc" $component.$range.\$monthf.nc
   $check_ncatted
   $time_mv $mvfile $component.$range.\$monthf.nc \$outdir/$component.$range.\$monthf.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile $component.$range.\$monthf.nc \$outdir/$component.$range.\$monthf.nc
      $checktransfer
   endif
   $time_rm rm $component.$range.\$monthf.nc
   $time_dmput dmput \$outdir/$component.$range.\$monthf.nc &

   $time_rm rm -f month.nc
   @ month++
end

EOF
   }

   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);

   return $csh;
}


#TIMEAVERAGES - ANNUAL 1YR
sub annualAV1yrfromhist {
   #taNode = $_[0] ;
   my $sim0 = $_[1];
   my $write2arch = $_[2];
   my $yr2do = $_[3];
   #check for appropriate segment lengths
   my @reqStartMonths = segStartMonths($segTime,$segUnits);

   my $ppcNode = $_[0]->parentNode;
   my $src = 'annual';
   my $interval = $_[0]->findvalue('@interval');
   my $chunkLength = $_[0]->findvalue('@chunkLength');

   if ( "$yr2do" eq '' ) { $yr2do = $hDate; }
   my $yr2do0 = FREUtil::parseDate($yr2do);
   my $sim0f = FREUtil::graindate($sim0,$src);
   my $t0f = FREUtil::graindate($yr2do0,$src);
   my $yr2doEND = FREUtil::modifydate($yr2do0,'+1 year -1 sec');
   my $tENDf = FREUtil::graindate($yr2doEND,$src);
   if ( "$yr2do" eq "00010101" ) { $tENDf = "0001" }
#print "annualAV1yrfromhist yr2do $yr2do yr2do0 $yr2do0 yr2doEND $yr2doEND tENDf $tENDf\n";
   my ($hDateyr) = FREUtil::splitDate($yr2do);

   my $diag_source = $_[0]->findvalue('@diagSource');
   my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
   if ( scalar @monthnodes and "$diag_source" eq "" ) {
    my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
    $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if ( "$diag_source" eq "") { $diag_source = $component."_month"; }

   $historyfiles .= "$yr2do".".nc.tar ";
   my $interval = "1yr";
   my $outdirpath = "$component/av/$src"."_$interval";
   my $outdir = "$ppRootDir/$outdirpath";

   #get variables
   my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   $variables =~ s/ /,/g;

   if( 1 > $maxyrs ) { $maxyrs = 1; }
   my $zInterp = $ppcNode->findvalue('@zInterp');
   my $do_zInterp = 0;
   if ("$zInterp" ne "") {  $do_zInterp = 1; }
   my $check_cpio = errorstr("CPIO ($component $src averages)");
   my $check_ncrcat = errorstr("NCRCAT ($component $src averages)");
   my $check_timavg = retryonerrorend("TIMAVG ($component $src averages)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_ncatted = errorstr("NCATTED ($component $src averages)");
   my $check_plevel = errorstr("PLEVEL ($component $src averages)");
   my $check_ncdump = errorstr("NCDUMP ($component $src averages)");
   my $check_fregrid = errorstr("FREGRID ($component $src averages)");
   my $check_ncrename = errorstr("NCRENAME ($component $src averages)");
   my $csh = setcheckpt('annualAV1yrfromhist');
   if ( "$write2arch" eq "1" ) {
      $csh .= "set write2arch = 1\n";
      $mkdircommand .= "$outdir ";
   } else {
      $csh .= "set write2arch = 0\n";
   }
   $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src averages)'
set outdir = $outdir
if ( ! -e \$outdir && \$write2arch ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
EOF
   if ($opt_z) { $csh .= begin_systime(); }

   if ( "$sourceGrid" eq "cubedsphere" ) { #IF CUBIC
   my $tile = '.tile$i';
   $csh .= <<EOF;
foreach file ( `ls \$histDir/$hDateyr*/*.$diag_source.tile*nc`)
  ln -s \$file .
end
foreach file ( `ls \$histDir/$hDateyr*/*.grid_spec.tile*.nc`)
  ln -s \$file .
end
set i = 1
while ( \$i <= 6 )
$time_ncrcat ncrcat \$ncrcatopt *.$diag_source$tile.nc annual$tile.nc
$check_ncrcat
$time_rm rm -f *.$diag_source$tile.nc
EOF

   if ( $do_zInterp ) {
      $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels$tile.nc annual$tile.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels$tile.nc annual$tile.nc
$check_timavg

EOF
      $csh .= zInterpolate($zInterp,"modellevels$tile.nc","$yr2do.$diag_source$tile.nc",$caltype,$variables);

   } else {
      $csh .= <<EOF;
$time_timavg \$TIMAVG -o $yr2do.$diag_source$tile.nc annual$tile.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $yr2do.$diag_source$tile.nc annual$tile.nc
$check_timavg
$time_rm rm -f annual$tile.nc

EOF
   }

if ( "$xyInterp" ne '' ) { #CUBIC to LATLON

   my $fregrid_wt = '';
   if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
      print "       land_frac found, weighting exchange grid cell with $yr2do.land_static\n" if $opt_v;
      $fregrid_wt = "--weight_file $yr2do.land_static --weight_field land_frac";
   }
   my $call_and_check_fregrid = $call_tile_fregrid;
   $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
   $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
   $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
   $csh .= <<EOF;
@ i ++
end

    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $yr2do
    set fregrid_in = $yr2do.$diag_source
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

mv \$fregrid_in.nc $component.$tENDf.ann.nc
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$tENDf.ann.nc" $component.$tENDf.ann.nc
$check_ncatted

$time_mv $mv $component.$tENDf.ann.nc \$tempCache/$outdirpath/$component.$tENDf.ann.nc
if ( \$write2arch ) then
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann.nc \$outdir/$component.$tENDf.ann.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann.nc \$outdir/$component.$tENDf.ann.nc
      $checktransfer
   endif
endif

EOF

   } else { #CUBIC - no conversion
   $csh .= <<EOF;
mv $yr2do.$diag_source$tile.nc $component.$tENDf.ann$tile.nc
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$tENDf.ann$tile.nc" $component.$tENDf.ann$tile.nc
$check_ncatted

$time_mv $mv $component.$tENDf.ann$tile.nc \$tempCache/$outdirpath/$component.$tENDf.ann$tile.nc
if ( \$write2arch ) then
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann$tile.nc \$outdir/$component.$tENDf.ann$tile.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann$tile.nc \$outdir/$component.$tENDf.ann$tile.nc
      $checktransfer
   endif
endif

@ i ++
end
EOF

}

   } else { #NOT CUBIC

   $csh .= <<EOF;
foreach file ( `ls \$histDir/$hDateyr*/*.$diag_source.nc`)
  ln -s \$file .
end
if ( -e annual.nc ) rm -f annual.nc
$time_ncrcat ncrcat \$ncrcatopt *.$diag_source.nc annual.nc
$check_ncrcat
$time_rm rm -f *.$diag_source.nc
EOF

   if ( $do_zInterp ) {
      $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels.nc annual.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels.nc annual.nc
$check_timavg

EOF
      $csh .= zInterpolate($zInterp,'modellevels.nc',"$component.$tENDf.ann.nc",$caltype,$variables);

   } else {
      $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$tENDf.ann.nc annual.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$tENDf.ann.nc annual.nc
$check_timavg

EOF
   }

      # convert latlon/tripolar to latlon
      if ( "$xyInterp" ne '' ) {
            my $fregrid_wt = '';
            if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
               print "       land_frac found, weighting exchange grid cell with $yr2do.land_static\n" if $opt_v;
               $fregrid_wt = "--weight_file $yr2do.land_static --weight_field land_frac";
            }
            my $call_and_check_fregrid = $call_fregrid;
            $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
            $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
            $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
            $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $yr2do
    set fregrid_in = annual
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

EOF
      }

   $csh .= <<EOF;
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$tENDf.ann.nc" $component.$tENDf.ann.nc
$check_ncatted
$time_mv $mv $component.$tENDf.ann.nc \$tempCache/$outdirpath/$component.$tENDf.ann.nc
if ( \$write2arch ) then
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann.nc \$outdir/$component.$tENDf.ann.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$tempCache/$outdirpath/$component.$tENDf.ann.nc \$outdir/$component.$tENDf.ann.nc
      $checktransfer
   endif
endif
$time_rm rm -f annual.nc

EOF

   }
   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);
   return $csh;
}

#TIMEAVERAGES - ANNUAL XYR
sub annualAVxyrfromann {
   #taNode = $_[0] ;
   my $sim0 = $_[1];
   my $ppcNode = $_[2];
   my $annavnodes = $_[3];
   my $annCalcInterval = $_[4];

   my $src = 'annual';
   my $interval = $_[0]->findvalue('@interval');
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $sim0f = FREUtil::graindate($sim0,$src);
   my $t0f = FREUtil::graindate($t0,$src);
   my $tENDf = FREUtil::graindate($tEND,$src);
   my $outdirpath = "$component/av/$src"."_$interval";
   my $outdir = "$ppRootDir/$outdirpath";
   my $tmp = FREUtil::modifydate($tEND,"+ 1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $int = $interval;
   $int =~ s/yr//;
   my $mod = $yrsSoFar % $int;
   unless( $mod == 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $int > $maxyrs ) { $maxyrs = $int; }
   my $first = FREUtil::padzeros($t0f-$int+1);

   #check for missing files
   my $diag_source = $_[0]->findvalue('@diagSource');
   my @monthnodes = $_[0]->parentNode->findnodes('timeSeries[@freq="monthly"]');
   if ( scalar @monthnodes and "$diag_source" eq "" ) {
    my $monthnode = $_[0]->parentNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
    $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if ( "$diag_source" eq "") { $diag_source = $component."_month"; }

   my $csh = '';

   #always do 1yr ann av calculation, but only archive if annCalcInterval not 1yr
   if ( "$annCalcInterval" ne "1yr" and not $annavnodes ) { $annavnodes = 0; }
   my $newnode = XML::LibXML::Element->new( 'timeAverage' );
   $newnode->setAttribute( 'source','annual' );
   $newnode->setAttribute( 'interval','1yr' );
   $ppcNode->appendChild($newnode);
   my $annNode = $ppcNode->findnodes('timeAverage[@source="annual" and @interval="1yr"]')->get_node(1);
   foreach my $i ( 0 .. ($int-1) ) {
      my $annyr = $userstartyear;
      $annyr -= $i;
      $annyr = FREUtil::padzeros($annyr)."0101";
      #print "\nNOTE: Calling annualAV1yrfromhist( $annNode, $sim0, $annavnodes, $annyr )\n\n";
      $csh .= annualAV1yrfromhist( $annNode, $sim0, $annavnodes, $annyr );
      last if "$annCalcInterval" eq "1yr";
   }

   $csh .= setcheckpt("annualAVxyrfromann_$interval");
   $csh .= <<EOF;

#####################################
echo 'timeAverage ($component $src $interval averages)'
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$component/av/annual_1yr ) mkdir -p \$tempCache/$component/av/annual_1yr
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath
set anndir = $ppRootDir/$component/av/annual_1yr
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
cd \$tempCache/$component/av/annual_1yr
EOF
   if ($opt_z) { $csh .= begin_systime(); }

   my $endinterval = FREUtil::padzeros($first + $int - 1 );
   until ( $endinterval > $tENDf ) {
      #print "in tA, endinterval($endinterval) tENDf($tENDf)\n";
      my $filelist = "";
      my $getlist = "";
      foreach my $year ($first .. $endinterval) {
         $year=FREUtil::padzeros($year);
         if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) { # CUBIC
            foreach my $i (1 .. 6) {
               $filelist .= "\$anndir/$component.$year.ann.tile$i.nc ";
               $getlist .= "$component.$year.ann.tile$i.nc ";
            }
         } else { # LATLON
            $filelist .= "\$anndir/$component.$year.ann.nc ";
            $getlist .= "$component.$year.ann.nc ";
         }
      }
      my $check_ncrcat = errorstr("NCRCAT ($component $src $interval averages)");
      my $check_timavg = retryonerrorend("TIMAVG ($component $src $interval averages)");
      my $retry_timavg = retryonerrorstart("TIMAVG");
      my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
      my $check_dmget = errorstr("DMGET ($component $src $interval averages)");

   if ("$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '') { # CUBIC
      my $tile = '.tile$i';
      $csh .= <<EOF;
foreach file ($filelist)
   set f = \$file:t
   if ( ! -f \$f ) then
      $time_cp $cp \$file .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp \$file .
         $checktransfer
      endif
   endif
end
set i = 1
while ( \$i <= 6 )
   if ( -e xyears.nc ) rm -f xyears.nc
   set filelist = ""
   foreach file ($getlist)
      if (\$file =~ \*$tile\*) set filelist = ( \$filelist \$file )
   end
   $time_ncrcat ncrcat \$ncrcatopt \$filelist \$work/xyears.nc
   $check_ncrcat
   $time_timavg \$TIMAVG -o \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc \$work/xyears.nc
   $retry_timavg
     $time_timavg \$TIMAVG -o \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc \$work/xyears.nc
   $check_timavg
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$first-$endinterval.ann$tile.nc" \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc
   $check_ncatted
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc \$outdir/$component.$first-$endinterval.ann$tile.nc
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$tempCache/$outdirpath/$component.$first-$endinterval.ann$tile.nc \$outdir/$component.$first-$endinterval.ann$tile.nc
      $checktransfer
   endif
   $time_rm rm -f xyears.nc
   @ i++
end
EOF

   } else { # LATLON
      $csh .= <<EOF;
foreach file ($filelist)
   set f = \$file:t
   if ( ! -f \$f ) then
      $time_cp $cp \$file .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp \$file .
         $checktransfer
      endif
   endif
end
if ( -e xyears.nc ) rm -f xyears.nc
$time_ncrcat ncrcat \$ncrcatopt $getlist \$work/xyears.nc
$check_ncrcat
$time_timavg \$TIMAVG -o \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc \$work/xyears.nc
$retry_timavg
   $time_timavg \$TIMAVG -o \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc \$work/xyears.nc
$check_timavg
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$first-$endinterval.ann.nc" \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc
$check_ncatted
$time_mv $mvfile \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc \$outdir/$component.$first-$endinterval.ann.nc
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile \$tempCache/$outdirpath/$component.$first-$endinterval.ann.nc \$outdir/$component.$first-$endinterval.ann.nc
   $checktransfer
endif
$time_rm rm -f \$work/xyears.nc
EOF
   }

      $first = FREUtil::padzeros($endinterval+1);
      $endinterval = FREUtil::padzeros($first + $int - 1 );
   }
   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);
   return $csh;
}

#TIMESERIES - monthly from daily ts
sub monthlyTSfromdailyTS {
   #tsNode = $_[0] ;
   my $sim0 = $_[1];
   my $startofrun = $_[2];
   my $ppcNode = $_[0]->parentNode;
   my $avgatt = $_[0]->findvalue('@averageOf');
   my $freq = $_[0]->findvalue('@freq');
   my $t0f = FREUtil::graindate($t0,$freq);
   my $tENDf = FREUtil::graindate($tEND,$freq);
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   if("$chunkLength" eq "") {
      print STDERR "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
      mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
      return "";
   }
   my $outdir = "$ppRootDir/$component/ts/$freq/$chunkLength";
   $chunkLength =~ s/yr//;
   my $yrsSoFar=&Delta_Format( FREUtil::dateCalc($sim0,$t0) ,0,"%yd");
   my $mod = ($yrsSoFar+1) % $chunkLength;
   if( $mod != 0 ) { return ""; } #don't do any calculations until a chunk is ready to go.
   $mkdircommand .= "$outdir ";
   if( $chunkLength > $maxyrs ) { $maxyrs = $chunkLength; }
   my $indir = "$ppRootDir/$component/ts/$avgatt/$chunkLength"."yr";
   my $hDateyr = $userstartyear;
   my @hDates = ( FREUtil::padzeros($hDateyr-$chunkLength+1) .. "$hDateyr" );
   my $in_start = FREUtil::graindate(FREUtil::modifydate($tEND,"-$chunkLength yr +1 sec"),$avgatt);
   my $in_end = FREUtil::graindate($tEND,$avgatt);
   my $out_start = FREUtil::graindate(FREUtil::modifydate($tEND,"-$chunkLength yr +1 sec"),$freq);
   my $out_end = FREUtil::graindate($tEND,$freq);
   #
   my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   if ("$variables" eq "") {
      $variables = $dtvars{$component};
      $variables =~ s/,/ /g;
   }
   my $dmgetvars = $variables;
   if ("$variables" ne "") {
      print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
      $dmgetvars =~ s/ /.nc \$in./g;
      $dmgetvars =~ s/^/$time_dmget dmget -d $indir \$in./;
      $dmgetvars =~ s/$/.nc/;
   }

   my $numtimelevels = gettimelevels($freq,$chunkLength);
   my $check_ncrcat = errorstr("NCRCAT ($component $freq ts calculated from $avgatt ts)");
   my $check_cpio = errorstr("CPIO ($component $freq ts calculated from $avgatt ts)");
   my $check_dmget = errorstr("DMGET ($component $freq ts calculated from $avgatt ts)");
   my $check_ncatted = errorstr("NCATTED ($component $freq ts calculated from $avgatt ts)");
   my $check_ncdump = errorstr("NCDUMP ($component $freq ts calculated from $avgatt ts)");
   my $check_timavg = retryonerrorend("TIMAVG ($component $freq ts calculated from $avgatt ts)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_ncks = errorstr("NCKS ($component $freq ts calculated from $avgatt ts)");
   my $check_ncap = errorstr("NCAP ($component $freq ts calculated from $avgatt ts)");
   my $check_levels = '';
   if ("$caltype" eq "NOLEAP" or "$caltype" eq "noleap") {
      $check_levels = errorstr("WRONG NUMBER OF TIME LEVELS (contains \$length, should be $numtimelevels) IN \$outdir/\$out.\$var.nc");
   }
   my $csh = setcheckpt('monthlyTSfromdailyTS');
   $csh .= <<EOF;
#####################################
echo 'timeSeries ($component $freq calculated from $avgatt TS)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir

EOF
   if ($opt_z) { $csh .= begin_systime(); }
   $csh .= <<EOF;
set in = '$component.$in_start-$in_end'
set out = '$component.$out_start-$out_end'

$dmgetvars
foreach var ( $variables )
   if ( ! -e $indir/\$in.\$var.nc ) then
      $time_dmget dmget $indir/\$in.day.nc.cpio
      $time_cp $cp $indir/\$in.day.nc.cpio .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $indir/\$in.day.nc.cpio .
         $checktransfer
      endif
      $time_uncpio $uncpio -ivI \$in.day.nc.cpio \$in.\$var.nc
      $check_cpio
      $time_dmput dmput "$indir/\$in.day.nc.cpio" &
   else
      $time_cp $cp $indir/\$in.\$var.nc .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $indir/\$in.\$var.nc .
         $checktransfer
      endif
   endif

   set d1 = 0
   set d2 = 0

   foreach y1 ( @hDates )
      set monthi = 0

      foreach days ( 31 28 31 30 31 30 31 31 30 31 30 31 )
        @ d1 = \$d2 + 1
        @ d2 = \$d2 + \$days

        @ monthi ++
        set m1 = `printf '%02i' \$monthi`

        if ( \$m1 == 12 ) then
          set m2 = 01
          @ tmp = \$y1 + 1
          set y2 = `printf '%04i' \$tmp`
        else
          @ tmp = \$monthi + 1
          set m2 = `printf '%02i' \$tmp`
          set y2 = \$y1
        endif

        set t = `ncdump -h \$in.\$var.nc | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
        $time_ncks ncks \$ncksopt -d \$t,\$d1,\$d2 -ahF \$in.\$var.nc \$y1\$m1.\$var.daily.nc
        $check_ncks
        $time_timavg \$TIMAVG -o \$y1\$m1.\$var.nc \$y1\$m1.\$var.daily.nc
        $retry_timavg
           $time_timavg \$TIMAVG -o \$y1\$m1.\$var.nc \$y1\$m1.\$var.daily.nc
        $check_timavg
        $time_rm rm -f \$y1\$m1.\$var.daily.nc
      end
   end

   if ( -e \$out.\$var.nc ) rm -f \$out.\$var.nc
   $time_ncrcat ncrcat \$ncrcatopt *??.\$var.nc \$out.\$var.nc
   $check_ncrcat
   $time_ncatted ncatted -h -O -a filename,global,m,c,"\$out.\$var.nc" \$out.\$var.nc
   $check_ncatted
   set tmpstring = `ncdump -h \$out.\$var.nc | grep UNLIMITED`
   $time_mv $mvfile \$out.\$var.nc $outdir/
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile \$out.\$var.nc $outdir/
      $checktransfer
   endif
   $time_rm rm \$out.\$var.nc
   $time_rm rm -f *??.\$var.nc
   @ len = \$#tmpstring - 1
   set length = `echo \$tmpstring[\$len] | cut -c2-`
   test \$length = $numtimelevels
   $check_levels
end

EOF

   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);

   return $csh;
}

#TIMESERIES - HOURLY, DAILY, MONTHLY, ANNUAL
sub directTS{
   #tsNode = $_[0] ;
   my $sim0 = $_[1];
   my $startofrun = $_[2];
   my $ppcNode = $_[0]->parentNode;
   my $avgatt = $_[0]->findvalue('@averageOf');
   my $freq = $_[0]->findvalue('@freq');
   my $source = $_[0]->findvalue('@source');
   if ( "$source" eq "" ) { $source = $ppcNode->findvalue('@source'); }
   if( "$avgatt" ne "" ) {
      if( "$avgatt" eq "daily" ) { return monthlyTSfromdailyTS( $_[0], $sim0, $startofrun ); }
      else { print STDERR "WARNING: $freq TS calculated from $avgatt TS is not supported. Skipping.\n"; return "";}
   }
   my $sim0f = FREUtil::graindate($sim0,$freq);
   my $t0f = FREUtil::graindate($t0,$freq);
   my $tENDf = FREUtil::graindate($tEND,$freq);
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $chunkstr = $chunkLength;
   if("$chunkLength" eq "") {
      print STDERR "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
      mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
      return "";
   }
   my $outdirpath = "$component/ts/$freq/$chunkLength";
   my $outdir = "$ppRootDir/$outdirpath";

   my $iunit = "months";
   if($chunkLength =~ /yr/) {
      $chunkLength =~ s/yr//;
      $iunit = "years";
   }
   $chunkLength =~ s/mo//;

   my $yrsSoFar=&Delta_Format( FREUtil::dateCalc($sim0,$t0) ,0,"%yd");
   my $mod = ($yrsSoFar+1) % $chunkLength;
   if( $mod != 0 and "$iunit" eq "years") { return ""; } #don't do any calculations until a chunk is ready to go.
   $mkdircommand .= "$outdir ";
   if( $chunkLength > $maxyrs ) { $maxyrs = $chunkLength; }

   my $hDateyr = $userstartyear;
   my $hDatemo = substr($userstartmo,2,2);
   my @hDates = ();
   my $start = '';
   if ( "$iunit" eq "years" ) {
      @hDates = ( FREUtil::padzeros($hDateyr-$chunkLength+1) .. "$hDateyr" );
      $start = FREUtil::graindate(FREUtil::modifydate($tEND,"-$chunkLength $iunit +1 sec"),$freq);
   } else {
      @hDates = ( "$hDateyr" );
   #the following gives wrong results, bug in Date:Manip
   #$start = FREUtil::graindate(FREUtil::modifydate($tEND,"-$chunkLength months +1 sec"),$freq);
   #the following is a cheap trick to fix the problem
      $start = FREUtil::modifydate($tEND, "-$chunkLength months + 5 days");
      $start = FREUtil::graindate($start,"mon");
      $start .= "01";
      $start = FREUtil::graindate($start,$freq);
   }
#print "start $start, tENDf $tENDf, chunkLength $chunkLength, iunit $iunit\n";

   foreach my $d (@hDates) { $historyfiles .= "$d$hDatemo"."01.nc.tar "; }
   #determine whether to interpolate z levels
   my $zInterp = $ppcNode->findvalue('@zInterp');
   my $do_zInterp = 0;
   if ("$zInterp" ne "") {  $do_zInterp = 1; }

   #get variables
   my $uservariables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   $uservariables =~ s/ /,/g;
   my $availablevars = $dtvars{"all_$source"};
   $availablevars =~ s/^/,/g;
   $availablevars =~ s/$/,/g;
   $availablevars .= 'hght,slp,' if $do_zInterp;
   my $variables = '';
   foreach my $v ( split(',',$uservariables) ) {
      if ( $availablevars =~ /,$v,/ ) {
         $variables = "$variables $v";
      } else {
         $variables = "$variables $v";
         print STDERR "WARNING: $freq $component post-processing requested for variable $v but it does not exist in the $source diag table.\n"; #Don't actually skip the variable until refineDiag supported as available variables.
      }
   }
   $variables =~ s/^ //g;
   $variables =~ s/ /,/g;
   if ("$variables" ne "") {
      print STDERR "        from xml, vars are '$variables'\n" if $opt_v;
   }

   my $numtimelevels = gettimelevels($freq,$chunkLength);
   #my $check_cpio = errorstr("CPIO ($component $freq ts from $source)");
   my $check_cpio_msg = "CPIO ($component $freq ts from $source)";
   my $check_plevel = errorstr("PLEVEL ($component $freq ts from $source)");
   my $check_splitncvars = errorstr("SPLITNCVARS ($component $freq ts from $source)");
   my $check_ncrcat = errorstr("NCRCAT ($component $freq ts from $source)");
   my $check_ncatted = errorstr("NCATTED ($component $freq ts from $source)");
   my $check_ncdump = errorstr("NCDUMP ($component $freq ts from $source)");
   my $check_timavg = retryonerrorend("TIMAVG ($component $freq ts from $source)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_ncks = errorstr("NCKS ($component $freq ts from $source)");
   my $check_filesexist = errorstr("NO USABLE VARIABLES EXIST ($component $freq ts from $source)");
   my $check_fregrid = errorstr("FREGRID ($component $freq ts from $source)");
   my $check_ncrename = errorstr("NCRENAME ($component $freq ts from $source)");
   my $check_levels = '';
   if ("$caltype" eq "NOLEAP" or "$caltype" eq "noleap" ) {
      $check_levels = errorstr("WRONG NUMBER OF TIME LEVELS (contains \$length, should be $numtimelevels) IN \$outdir/$component.$start-$tENDf.\$file");
   }
   my $csh = setcheckpt("directTS_$freq"."_$chunkstr");
   $csh .= <<EOF;

#####################################
echo 'timeSeries ($component $freq from $source)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath

EOF
   if ($opt_z) { $csh .= begin_systime(); }

   my $tmp_month = '01';
   my $tmpsrcstr = "$source.nc";
   if ( "$sourceGrid" eq 'cubedsphere' ) { $tmpsrcstr = "$source.tile*.nc"; }

   $csh .= <<EOF;
   foreach hDate ( @hDates )
      set nhistfiles = 0
      foreach file ( `ls \$histDir/\$hDate*/*.$tmpsrcstr`)
        ln -s \$file .
        @ nhistfiles ++
      end
      foreach file ( `ls \$histDir/\$hDate*/*.grid_spec.tile*.nc`)
        ln -s \$file .
      end
      if ( \$nhistfiles == 0 ) then
         echo 'ERROR: No history files matching \$hDate*/*.$tmpsrcstr'
      endif
   end
   mkdir -p byVar
EOF

   if ( $do_zInterp ) {
      if ( "$sourceGrid" eq 'cubedsphere' ) {
         # cat, call plevel, on tiles
         $csh .= <<EOF;
if ( -e modellevels.nc ) rm -f modellevels*.nc
set i = 1
while ( \$i <= 6 )
$time_ncrcat ncrcat \$ncrcatopt *.$source.tile\$i.nc $hDate.modellevels.tile\$i.nc
$check_ncrcat
@ i ++
end
EOF
         foreach my $i ( 1..6 ) {
            $csh .= zInterpolate($zInterp,"$hDate.modellevels.tile$i.nc","$hDate.$source.tile$i.nc",$caltype,$variables);
         }
         # convert tiles to latlon
         if ( "$xyInterp" ne '' ) {

            my $fregrid_wt = '';
            if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
               print "       land_frac found, weighting exchange grid cell with $hDate.land_static\n" if $opt_v;
               $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
            }
            my $call_and_check_fregrid = $call_tile_fregrid;
            $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
            $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
            $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
            $csh .= <<EOF;

    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = $hDate.$source
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

mv \$fregrid_in.nc all.nc

EOF
         }
      } else { # not cubic
         $csh .= <<EOF;
if ( -e modellevels.nc ) rm -f modellevels.nc
$time_ncrcat ncrcat \$ncrcatopt *.$source.nc modellevels.nc
$check_ncrcat
$time_rm rm -f *.$source.nc
EOF
      $csh .= zInterpolate($zInterp,'modellevels.nc','all.nc',$caltype,$variables);

      # convert latlon/tripolar to latlon
      if ( "$xyInterp" ne '' ) {
            my $fregrid_wt = '';
            if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
               print "       land_frac found, weighting exchange grid cell with $hDate.land_static\n" if $opt_v;
               $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
            }
            my $call_and_check_fregrid = $call_fregrid;
            $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
            $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
            $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
            $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = 'all'
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

EOF
         }
      }
   } else { # no zInterpolation
      if ( "$sourceGrid" eq 'cubedsphere' ) {
         $csh .= <<EOF;
#if ( -e all.nc ) rm -f all.nc
set i = 1
while ( \$i <= 6 )
$time_ncrcat ncrcat \$ncrcatopt *.$source.tile\$i.nc $hDate.$source.tile\$i.nc
$check_ncrcat
@ i ++
end
EOF
         # convert tiles to latlon
         if ( "$xyInterp" ne '' ) {

            my $fregrid_wt = '';
            if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
               print "       land_frac found, weighting exchange grid cell with $hDate.land_static\n" if $opt_v;
               $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
            }
            my $call_and_check_fregrid = $call_tile_fregrid;
            $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
            $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
            $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
            $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = $hDate.$source
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

mv \$fregrid_in.nc all.nc

EOF
         }
      } else { #not cubic, just ncrcat
      $csh .= <<EOF;
if ( -e all.nc ) rm -f all.nc
$time_ncrcat ncrcat \$ncrcatopt *.$source.nc all.nc
$check_ncrcat
$time_rm rm -f *.$source.nc

EOF
         # convert latlon/tripolar to latlon
         if ( "$xyInterp" ne '' ) {

            my $fregrid_wt = '';
            if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
               print "       land_frac found, weighting exchange grid cell with $hDate.land_static\n" if $opt_v;
               $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
            }
            my $call_and_check_fregrid = $call_fregrid;
            $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
            $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
            $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
            $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = 'all'
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

EOF
         }
      }
   }
   if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {
      $csh .= "set filestosplit = ( `ls -1 | egrep \"$hDate.$source.tile..nc\"` )\n";
   } else {
      $csh .= "set filestosplit = ( all.nc )\n";
   }
   # make sure file has bounds, splitncvars, adjust output, send to archive
   my $variablesopt = '';
   $variablesopt = "-v $variables" if "$variables" ne '';
   $csh .= <<EOF;
foreach filetosplit ( \$filestosplit )

#set hasAVT1 = `ncdump -v average_T1 \$filetosplit | wc -l`
#set hasbounds = `ncdump -h \$filetosplit | grep '_bounds' | wc -l`
#if ( \$hasAVT1 && ! \$hasbounds ) then
if ( `ncdump -h \$filetosplit | grep -c " average_T1("` == 1 && `ncdump -h \$filetosplit | grep -c "_bounds("` == 0) then
   ncdump -v average_T1,average_T2 \$filetosplit | /home/fms/bin/addbounds.pl | ncgen -o tmp.nc
   set taxis = `ncdump -h \$filetosplit | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
   $time_ncks ncks \$ncksopt -C -A -v \${taxis}_bounds tmp.nc \$filetosplit
   $check_ncks
   $time_ncatted ncatted -h -O -a bounds,\$taxis,c,c,"\${taxis}_bounds" \$filetosplit
   $check_ncatted
endif

$time_splitncvars \$SPLITNCVARS -o byVar $variablesopt \$filetosplit
$check_splitncvars

cd byVar
test `ls | wc -l` -gt 0
$check_filesexist
if ( `ls | wc -l` > 0 ) then
set tilenr = `echo \$filetosplit | egrep -o '\\.tile.'`
foreach file ( *.nc )
     set label = "\$file:r\$tilenr.nc"
     $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$start-$tENDf.\$label" \$file
     $check_ncatted
     set tmpstring = `ncdump -h \$file | grep UNLIMITED`
     @ len = \$#tmpstring - 1
     set length = `echo \$tmpstring[\$len] | cut -c2-`
     test \$length = $numtimelevels
     $check_levels
     $time_mv $mvfile \$file \$outdir/$component.$start-$tENDf.\$label
     if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile \$file \$outdir/$component.$start-$tENDf.\$label
         $checktransfer
     endif
     $time_mv $mv \$file \$tempCache/$outdirpath/$component.$start-$tENDf.\$label
end
cd \$work
$time_rm rm -rf byVar

end
EOF

   #cpio the timeseries
   if ( $aggregateTS ) {
      my $abbrev = FREUtil::timeabbrev($freq);
      my $cpioTS = '';
      if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" ne '' ) {
         $cpioTS = createcpio( "\$tempCache/$outdirpath",$outdir,"$component.$start-$tENDf.tile?",$abbrev,1);
      } else {
         $cpioTS = createcpio( "\$tempCache/$outdirpath",$outdir,"$component.$start-$tENDf",$abbrev,1);
      }
      if ("$freq" eq "monthly") { $cpiomonTS .= $cpioTS; }
      else { $csh .= $cpioTS; }
   }

   $csh .= "\nendif\n";

   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);

   return $csh;
}



#TIMEAVERAGES - MONTHLY
sub monthlyAVfromav {
   #taNode = $_[0] ;
   my $sim0 = $_[1];
   my $subint = $_[2];
   my $ppcNode = $_[0]->parentNode;

   my $src = 'monthly';
   my $interval = $_[0]->findvalue('@interval');
   my $outdir = "$ppRootDir/$component/av/$src"."_$interval";
   my $srcdir = "$ppRootDir/$component/av/$src"."_$subint"."yr";
   my $chunkLength = $_[0]->findvalue('@chunkLength');

   my $tmp = FREUtil::modifydate($tEND,"+ 1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $int = $interval;
   $int =~ s/yr//;
   my $mod = $yrsSoFar % $int;
   unless( $mod == 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $int > $maxyrs ) { $maxyrs = $int; }

   #check for missing files
   my $diag_source =  $_[0]->findvalue('@diagSource');
   my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
   if ( scalar @monthnodes and "$diag_source" eq "" ) {
    my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
    $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if ( "$diag_source" eq "") { $diag_source = $component."_month"; }

   my $sim0f = FREUtil::graindate($sim0,$src);
   my $t0f = FREUtil::graindate($t0,$src);
   my $tENDf = FREUtil::graindate($tEND,$src);
   my $end = FREUtil::graindate($tEND,'year');
   if ( $end < $int ) { return ""; } #nothing to do yet
   my $start = FREUtil::padzeros($end-$int+1);

   my $substart = $start;
   my $subend = FREUtil::padzeros($start + $subint - 1);
   my $filelist = "";
   until( $subend > $end ) {
      if($substart == $subend) {$filelist .= "$component.$substart.\$monthf\$tile.nc ";}
      else {$filelist .= "$component.$substart-$subend.\$monthf\$tile.nc ";}
      $substart = FREUtil::padzeros($substart + $subint);
      $subend = FREUtil::padzeros($subend + $subint);
   }
   my $getlist = $filelist;
   $getlist =~ s/\$monthf\$tile/*/g;
#   print "filelist is $filelist\n";
#   print "getlist is $getlist\n";
   my $tilestart = "set tile = ''";
   my $tileend = '';
   if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {
      $tilestart = "set tileN=1\nwhile (\$tileN <= 6)\nset tile = .tile\$tileN";
      $tileend = "@ tileN++\nend";
   }

   my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
   my $check_ncrcat = errorstr("NCRCAT ($component $src $interval averages)");
   my $check_timavg = retryonerrorend("TIMAVG ($component $src $interval averages)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_dmget = errorstr("DMGET ($component $src $interval averages)");
   my $csh = setcheckpt("monthlyAVfromav_$interval");
   $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages from $subint yr averages)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir

EOF
   if ($opt_z) { $csh .= begin_systime(); }
   $csh .= <<EOF;

cd $srcdir
$time_dmget dmget "$getlist"
set files = (`ls $getlist`)
cd \$work
foreach file (\$files)
   $time_cp $cp $srcdir/\$file .
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_cp $cp $srcdir/\$file .
      $checktransfer
   endif
end

$tilestart

set month = 1
while (\$month <= 12)
   set monthf = `echo \$month | sed 's/.*/0&/;s/.\\(..\\)/\\1/'`
   if ( -e month.nc ) rm -f month.nc
   $time_ncrcat ncrcat \$ncrcatopt $filelist month.nc
   $check_ncrcat
   $time_timavg \$TIMAVG -o $component.$start-$end.\$monthf\$tile.nc month.nc
   $retry_timavg
      $time_timavg \$TIMAVG -o $component.$start-$end.\$monthf\$tile.nc month.nc
   $check_timavg
   $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$start-$end.\$monthf\$tile.nc" $component.$start-$end.\$monthf\$tile.nc
   $check_ncatted
   $time_mv $mvfile $component.$start-$end.\$monthf\$tile.nc \$outdir/
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_mv $mvfile $component.$start-$end.\$monthf\$tile.nc \$outdir/
      $checktransfer
   endif
   $time_rm rm $component.$start-$end.\$monthf\$tile.nc
   $time_dmput dmput \$outdir/$component.$start-$end.\$monthf\$tile.nc &
   $time_rm rm -f month.nc
   @ month++
end

$tileend

EOF

   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);

   return $csh;
}

#TIMEAVERAGES - ANNUAL XYR
sub annualAVfromav {
   #taNode = $_[0] ;
   my $sim0 = $_[1];
   my $subint = $_[2];

   my $src = 'annual';
   my $interval = $_[0]->findvalue('@interval');
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $sim0f = FREUtil::graindate($sim0,$src);
   my $t0f = FREUtil::graindate($t0,$src);
   my $tENDf = FREUtil::graindate($tEND,$src);
   my $outdir = "$ppRootDir/$component/av/$src"."_$interval";
   my $srcdir = "$ppRootDir/$component/av/$src"."_$subint"."yr";
   my $tmp = FREUtil::modifydate($tEND,"+ 1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $int = $interval;
   $int =~ s/yr//;
   my $mod = $yrsSoFar % $int;
   unless( $mod == 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $int > $maxyrs ) { $maxyrs = $int; }
   my $first = FREUtil::padzeros($t0f-$int+1);

   #check for missing files
   my $diag_source =  $_[0]->findvalue('@diagSource');
   my @monthnodes = $_[0]->parentNode->findnodes('timeSeries[@freq="monthly"]');
   if ( scalar @monthnodes and "$diag_source" eq "" ) {
    my $monthnode = $_[0]->parentNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
    $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if ( "$diag_source" eq "") { $diag_source = $component."_month"; }

   my $csh = setcheckpt("annualAVfromav_$interval");
   $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages from $subint yr averages)'
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
EOF
   if ($opt_z) { $csh .= begin_systime(); }

   my $endinterval = FREUtil::padzeros($first + $int - 1 );
   until ( $endinterval > $tENDf ) {
      #print "in tA, endinterval($endinterval) tENDf($tENDf)\n";
      my $substart = $first;
      my $subend = FREUtil::padzeros($first + $subint - 1);
      my $filelist = "";
      until( $subend > $tENDf ) {
         $filelist .= "$component.$substart-$subend.ann\$tile.nc ";
         $substart = FREUtil::padzeros($substart + $subint);
         $subend = FREUtil::padzeros($subend + $subint);
      }

      my $tilestart = "set tile = ''";
      my $tileend = '';
      if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {
         $tilestart = "set tileN=1\nwhile (\$tileN <= 6)\nset tile = .tile\$tileN";
         $tileend = "@ tileN++\nend";
      }

      my $check_ncrcat = errorstr("NCRCAT ($component $src $interval averages)");
      my $check_timavg = retryonerrorend("TIMAVG ($component $src $interval averages)");
      my $retry_timavg = retryonerrorstart("TIMAVG");
      my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
      my $check_dmget = errorstr("DMGET ($component $src $interval averages)");
      $csh .= <<EOF;
cd $srcdir
$tilestart

$time_dmget dmget "$filelist"

cd \$work
foreach file ($filelist)
   $time_cp $cp $srcdir/\$file .
   if ( \$status ) then
      echo "WARNING: data transfer failure, retrying..."
      $time_cp $cp $srcdir/\$file .
      $checktransfer
   endif
end

if ( -e xyears.nc ) rm -f xyears.nc
$time_ncrcat ncrcat \$ncrcatopt $filelist xyears.nc
$check_ncrcat
$time_timavg \$TIMAVG -o $component.$first-$endinterval.ann\$tile.nc xyears.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$first-$endinterval.ann\$tile.nc xyears.nc
$check_timavg
$time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$first-$endinterval.ann\$tile.nc" $component.$first-$endinterval.ann\$tile.nc
$check_ncatted
$time_mv $mvfile $component.$first-$endinterval.ann\$tile.nc \$outdir/$component.$first-$endinterval.ann\$tile.nc
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$first-$endinterval.ann\$tile.nc \$outdir/$component.$first-$endinterval.ann\$tile.nc
   $checktransfer
endif
$time_rm rm $component.$first-$endinterval.ann\$tile.nc
$time_rm rm -f xyears.nc

$tileend

EOF
      $first = FREUtil::padzeros($endinterval+1);
      $endinterval = FREUtil::padzeros($first + $int - 1 );
   }
   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);
   return $csh;
}

#create static variables file
sub staticvars {
   my $diag_source = $_[0] ;
   my $ptmpDir = $_[1] ;
   my $tmphistdir = $_[2] ;
   my $refinedir = $_[3] ;

   #note: checking ncks: gives error messages when it shouldn't?
   my $check_ncks = errorstr("NCKS ($component static variables)");
   my $check_cpio = errorstr("CPIO ($component static variables)");
   my $check_ncatted = errorstr("NCATTED ($component static variables)");
   my $check_splitncvars = errorstr("SPLITNCVARS ($component static variables)");
   my $check_fregrid = errorstr("FREGRID ($component static variables)");
   my $check_ncrename = errorstr("NCRENAME ($component static variables)");
   my $check_ncatted = errorstr("NCATTED ($component static variables)");

   $historyfiles .= "$hDate".".nc.tar ";

   my $csh = setcheckpt('staticvars');
   $csh .= <<EOF;
#####################################
if ( ! -e $ppRootDir/$component/$component.static.nc ) then
   echo 'static variables ($component)'
   cd \$work
   find \$work/* -maxdepth 1 -exec rm -rf {} \\;
   mkdir -p $ppRootDir/$component
   $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*$diag_source\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*$diag_source\\*
      $checktransfer
   endif
   # Get files listed as associated_files
   foreach file ( $tmphistdir/$hDate.nc/*$diag_source* )
      # Get a list of all associated_files
      set assocFiles = `ncdump -h \$file | $grepAssocFiles`
      foreach assocFile ( \$assocFiles )
         $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*\${assocFile:r}.\\*
      end
   end

   $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*$diag_source\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*$diag_source\\*
$checktransfer
   endif
   # Get files listed as associated_files
   foreach file ( $tmphistdir/$hDate.nc/*$diag_source* )
      # Get a list of all associated_files
      set assocFiles = `ncdump -h \$file | $grepAssocFiles`
      foreach assocFile ( \$assocFiles )
         $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*\${assocFile:r}.\\*
      end
   end

   foreach file ( `ls \$histDir/*/*nc`)
     ln -s \$file .
   end
   set output_files = ( )
EOF


   if ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" eq '' ) {
      #DATA LEFT ON CUBED SPHERE GRID
      $csh = setcheckpt('staticvars');
      $csh .= <<EOF;
#####################################
if ( ! -e $ppRootDir/$component/$component.static.tile6.nc ) then
   echo 'static variables ($component)'
   cd \$work
   find \$work/* -maxdepth 1 -exec rm -rf {} \\;
   mkdir -p $ppRootDir/$component
   $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*$diag_source\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*$diag_source\\*
$checktransfer
   endif
   # Get files listed as associated_files
   foreach file ( \\*$diag_source\\* )
      # Get a list of all associated_files
      set assocFiles = `ncdump -h \$file | $grepAssocFiles`
      foreach assocFile ( \$assocFiles )
         $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w $tmphistdir $hDate.nc/\\*\${assocFile:r}.\\*
      end
   end

   $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*$diag_source\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*$diag_source\\*
$checktransfer
   endif
   # Get files listed as associated_files
   foreach file ( \\*$diag_source\\* )
      # Get a list of all associated_files
      set assocFiles = `ncdump -h \$file | $grepAssocFiles`
      foreach assocFile ( \$assocFiles )
         $time_hsmget \$hsmget -a $refinedir -p $ptmpDir/history_refineDiag -w $tmphistdir $hDate.nc/\\*\${assocFile:r}.\\*
      end
   end

   foreach file ( `ls \$histDir/*/*nc`)
      if ( ! -e `basename \$file` ) ln -s \$file .
   end
EOF

      foreach my $i ( 1 .. 6 ) {
      $csh .= <<EOF;
   set files = (`ls -1 $hDate.$diag_source*tile$i.nc | grep -v grid_spec`)
   set static = (`\$NCVARS -s012 \$files`) # only support up to 2D static fields
   if ( "\$static" != "" ) then
      foreach file ( \$files )
         set static = (`\$NCVARS -s012 \$file`)
         if ( "\$static" != "" ) then
            set static = `echo \$static | tr ' ' ','`
            $time_splitncvars \$SPLITNCVARS -v \$static -f $ppRootDir/$component/$component.static.tile$i.nc \$file
$check_splitncvars
         endif
      end
   endif
endif
EOF
      }
      return $csh;
   } elsif ( "$sourceGrid" eq 'cubedsphere' and "$xyInterp" ne '' ) {
      #DATA CONVERTED FROM CUBED SPHERE TO LATLON

      my $fregrid_wt = '';
      if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
         print "       land_frac found, weighting exchange grid cell with $hDate.land_static\n" if $opt_v;
         $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
      }
      my $call_and_check_fregrid = $call_tile_fregrid;
      $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
      $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
      $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
      $call_and_check_fregrid =~ s/set order1/if ( "\$interpvars" != "" ) then\n set order1/;
      my $cubiccsh = <<EOF;

   set output_files = ( )
   set tiles = (`ls -1 $hDate.$diag_source*.tile1.nc | grep -v grid_spec`)
   foreach tfile ( \$tiles )
     if ( ! -w \$tfile ) then
      set i = 1
      while ( \$i <= 6 )
        set tf = \$tfile:r:r.tile\$i.nc
        $time_cp cp \$tf copy
        $time_rm rm -f \$tf
        $time_mv $mv copy \$tf
        chmod 644 \$tf
        @ i ++
      end
     endif
     set fregrid_wt = "$fregrid_wt"
     set fregrid_in_date = $hDate
     set fregrid_in = \$tfile:r:r
     set nlat = $nlat ; set nlon = $nlon
     set interp_method = $interpMethod
     set ncvars_arg = -s2
     set variables = ( )
     set fregrid_remap_file = $xyInterpRegridFile

     set onedvars = `\$NCVARS -s01 \$fregrid_in.tile1.nc`
     if ( "\$onedvars" != "" ) then
        set onedvarlist = `echo \$onedvars | tr ' ' ','`
        $time_splitncvars \$SPLITNCVARS -s -v \$onedvarlist -f $ppRootDir/$component/$component.static.nc \$fregrid_in.tile1.nc
     endif

# call and check fregrid start
$call_and_check_fregrid
set output_files = (\$output_files \$fregrid_in.nc)
endif
# call and check fregrid end

     end
EOF
      $csh .= $cubiccsh;
   } else {
      #DATA ALREADY LATLON

      # convert latlon/tripolar to latlon
      if ( "$xyInterp" ne '' ) {

         my $fregrid_wt = '';
         if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
            print "       land_frac found, weighting exchange grid cell with $hDate.land_static\n" if $opt_v;
            $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
         }
         my $call_and_check_fregrid = $call_fregrid;
         $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
         $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
         $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
         $call_and_check_fregrid =~ s/set order1/if ( "\$interpvars" != "" ) then\n set order1/;
         $csh .= <<EOF;
         set output_files = ( )
         set files = (`ls -1 $hDate.$diag_source*.nc | grep -v grid_spec`)
         foreach file ( \$files )
           set fregrid_wt = "$fregrid_wt"
           set fregrid_in_date = $hDate
           set fregrid_in = \$file:r
           set nlat = $nlat ; set nlon = $nlon
           set interp_method = $interpMethod
           set ncvars_arg = -s2
           set variables = ( )
           set fregrid_remap_file = $xyInterpRegridFile

           $call_and_check_fregrid

           set output_files = (\$output_files \$fregrid_in.nc)
         endif
         end

EOF
      } else {

      $csh .= <<EOF;
   set output_files = (`ls -1 $hDate.$diag_source*.nc | grep -v grid_spec`)
EOF
      }
   }
   # process latlon files for static variables
   $csh .= <<EOF;
   if ( \$#output_files > 0 ) then
      set static = (`\$NCVARS -s012 \$output_files`) # only support up to 2D static fields
      if ( "\$static" != "" ) then
         foreach file ( \$output_files )
            set static = (`\$NCVARS -s012 \$file`)
            if ( "\$static" != "" ) then
               set static = `echo \$static | tr ' ' ','`
               $time_splitncvars \$SPLITNCVARS -s -v \$static -f $ppRootDir/$component/$component.static.nc \$file
               $check_splitncvars
            endif
         end
      endif
   endif
endif
EOF
   return $csh;
}


#TIMESERIES - from smaller timeSeries
sub TSfromts {
   #tsNode = $_[0] ;
   my $sim0 = $_[1];
   my $subchunk = $_[2];
   my $ppcNode = $_[0]->parentNode;

   my $freq = $_[0]->findvalue('@freq');
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $outdirpath = "$component/ts/$freq/$chunkLength";
   my $outdir = "$ppRootDir/$outdirpath";
   if("$chunkLength" eq "") {
         mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
         print STDERR "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
         return "";
   }
   my $subchunkyr = "$subchunk"."yr";
   my $reqpath = "$ppRootDir/$component/ts/$freq/$subchunk"."yr";
   my $tmp = FREUtil::modifydate($tEND,"+1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $cl = $chunkLength;
   $cl =~ s/yr//;
   my $mod = $yrsSoFar % $cl;
   unless( $mod == 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $cl > $maxyrs ) { $maxyrs = $cl; }

   #check that all files up to current time exist
   my @nodes = $ppcNode->findnodes("timeSeries[\@freq='$freq']");
   my $diag_source = "";
   if ( scalar @nodes ) {
    my $node = $ppcNode->findnodes("timeSeries[\@freq='$freq']")->get_node(1);
    $diag_source = $node->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if( "$diag_source" eq "") { $diag_source = $component."_month"; }

   my $tENDf = FREUtil::graindate( $tEND, $freq );
   my $start = FREUtil::modifydate($tEND,"-$cl years +1 sec");
   if ( "$start" eq "0001010300:00:00" ) { $start = "0001010100:00:00"; }  #omg, hack, date::manip bugs
   my $end = FREUtil::modifydate($start, "+$subchunk years -1 sec");
   my $startf = FREUtil::graindate( $start, $freq );
   my $endf = FREUtil::graindate( $end, $freq );
#print "TSfromts tEND $tEND cl $cl subchunk $subchunk start $start startf $startf end $end endf $endf\n";

   my $filelist = "";
   my $getlist = "";
   my $cpiolist = "";
   my $periodlist = "";
   until( $endf > $tENDf ) {
      $filelist = "$filelist $component.$startf-$endf.\$var";
      $cpiolist = "$cpiolist $component.$startf-$endf.".FREUtil::timeabbrev($freq).".nc.cpio";
      $getlist = "$getlist $component.$startf-$endf.\*.nc";
      $periodlist = "$periodlist $component.$startf-$endf";
      $start = FREUtil::modifydate($start," + $subchunk years");
      $end = FREUtil::modifydate($end," + $subchunk years");
      $startf = FREUtil::graindate($start,$freq);
      $endf = FREUtil::graindate($end,$freq);
   }
   #print "filelist is $filelist\n";
   #print "getlist is $getlist\n";
   #print "cpiolist is $cpiolist\n";

   my $start = FREUtil::modifydate($tEND,"-$cl years +1 sec");
   my $startf = FREUtil::graindate( $start, $freq );

   #get variables
   my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   if ("$variables" ne "") { print STDERR "           from xml, vars are '$variables'\n" if $opt_v; }
   $variables =~ s/ /.nc /g;
   if("$variables" ne "") {$variables =~ s/$/.nc/g};
   my $varlist_from_xml = "";
   if ( "$variables" ne "" ) {
      $varlist_from_xml = "set varlist = ( $variables )";
   }

   my $numtimelevels = gettimelevels($freq,$chunkLength);
   my $check_ncatted = errorstr("NCATTED ($component $freq $chunkLength ts from $subchunk yr ts)");
   my $check_ncrcat = errorstr("NCRCAT ($component $freq $chunkLength ts from $subchunk yr ts)");
   #my $check_cpio = errorstr("CPIO ($component $freq $chunkLength ts from $subchunk yr ts)");
   my $check_cpio_msg = "CPIO ($component $freq $chunkLength ts from $subchunk yr ts)";
   my $check_dmget = errorstr("DMGET ($component $freq $chunkLength ts from $subchunk yr ts)");
   my $check_levels = '';
   if ("$caltype" eq "NOLEAP" or "$caltype" eq "noleap" ) {
      $check_levels = errorstr("WRONG NUMBER OF TIME LEVELS (contains \$length, should be $numtimelevels) IN \$outdir/$component.$startf-$tENDf.\$var");
   }
   my $check_vars = errorstr("NOT ALL VARIABLES EXIST FOR ($component $freq $chunkLength ts from $subchunk yr ts)");

   my $csh = setcheckpt("TSfromts_$freq"."_$chunkLength");
   $csh .= <<EOF;
#####################################
echo 'timeSeries ($component $freq $chunkLength ts from $subchunk yr ts)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath

EOF
   if ($opt_z) { $csh .= begin_systime(); }
   $csh .= <<EOF;

cd $reqpath
set cpiosexist = 1
foreach f ( $cpiolist )
   if ( ! -e \$f ) set cpiosexist = 0
end
if ( \$cpiosexist ) then
   cd $reqpath
   $time_dmget dmget $cpiolist
   set mylist = (`ls $cpiolist`)
   cd \$work
   foreach cpio ( \$mylist )
      $time_cp $cp $reqpath/\$cpio .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $reqpath/\$cpio .
         $checktransfer
      endif
      $time_uncpio $uncpio -ivI \$cpio || ( echo "$check_cpio_msg"; echo "$check_cpio_msg" > \$work/.errors )
   end
   set varlist = `ls -1 $getlist | cut -f3- -d'.' | sort -u`
   $varlist_from_xml
else
   cd $reqpath
   set varlistprev = start
   foreach f ( $periodlist )
      set varlist = `ls -1 \$f.*.nc | cut -f3- -d'.' | sort -u`
      if ( \$#varlist == 0 ) break
      if ( "\$varlistprev" != "start" && \$#varlist != \$varlistprev ) then
         echo "WARNING: different number of variables found for different time periods: \$#varlist vs \$varlistprev, extracting cpio files to retrieve all variables"
         set varlistprev = 'error'
         break
      else
         set varlistprev = \$#varlist
      endif
   end
   test \$#varlist != 0 -o "\$varlistprev" != "error"
   $check_vars
   $varlist_from_xml
   $time_dmget dmget "$getlist"
   cd \$work
   foreach var (\$varlist)
      foreach file ( $filelist )
         if ( ! -f \$tempCache/$component/ts/$freq/$subchunkyr/\$file ) then
            $time_cp $cp $reqpath/\$file \$tempCache/$component/ts/$freq/$subchunkyr/\$file
            if ( \$status ) then
               echo "WARNING: data transfer failure, retrying..."
               $time_cp $cp $reqpath/\$file \$tempCache/$component/ts/$freq/$subchunkyr/\$file
               $checktransfer
            endif
         endif
         ln -s \$tempCache/$component/ts/$freq/$subchunkyr/\$file .
      end
   end
endif


cd \$work
foreach var (\$varlist)
     if ( -e $component.$startf-$tENDf.\$var ) rm -f $component.$startf-$tENDf.\$var
     $time_ncrcat ncrcat \$ncrcatopt $filelist $component.$startf-$tENDf.\$var
     $check_ncrcat
     $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$startf-$tENDf.\$var" $component.$startf-$tENDf.\$var
     $check_ncatted
     set tmpstring = `ncdump -h $component.$startf-$tENDf.\$var | grep UNLIMITED`
     @ len = \$#tmpstring - 1
     set length = `echo \$tmpstring[\$len] | cut -c2-`
     test \$length = $numtimelevels
     $check_levels
     $time_mv $mvfile $component.$startf-$tENDf.\$var $outdir/
     if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $component.$startf-$tENDf.\$var $outdir/
         $checktransfer
     endif
     $time_mv $mv \$work/$component.$startf-$tENDf.\$var \$tempCache/$outdirpath/
end

EOF

   if ( $aggregateTS ) {
      $csh .= createcpio( "\$tempCache/$outdirpath",$outdir,"$component.$startf-$tENDf",FREUtil::timeabbrev($freq),1);
   }
   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);

   return $csh;
}

#TIMESERIES - from smaller timeSeries
sub seaTSfromts {
   #tsNode = $_[0] ;
   my $sim0 = $_[1];
   my $subchunk = $_[2];
   my $ppcNode = $_[0]->parentNode;

   my $freq = $_[0]->findvalue('@freq');
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $outdirpath = "$component/ts/$freq/$chunkLength";
   my $outdir = "$ppRootDir/$outdirpath";
   if("$chunkLength" eq "") {
         mailuser("Cannot create $component $freq timeSeries unless you set a chunkLength.");
         print STDERR "ERROR: Cannot create $component $freq timeSeries unless you set a chunkLength.\n";
         return "";
   }
   my $subchunkyr = "$subchunk"."yr";
   my $reqpath = "$ppRootDir/$component/ts/$freq/$subchunk"."yr";
   my $req = "$component/ts/$freq/$subchunk"."yr";
   my $tmp = FREUtil::modifydate($tEND,"+1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $cl = $chunkLength;
   $cl =~ s/yr//;
   my $mod = $yrsSoFar % $cl;
   unless( $mod == 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $cl > $maxyrs ) { $maxyrs = $cl; }

   #check that all files up to current time exist
   my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
   my $diag_source = "";
   if ( scalar @monthnodes ) {
     my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
     $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if( "$diag_source" eq "") { $diag_source = $component."_month"; }

   my $tENDf = FREUtil::graindate( $tEND, 'year');
   my $start = FREUtil::modifydate($tEND,"-$cl years +1 sec");
   my $end = FREUtil::modifydate($start, "+$subchunk years -1 sec");
   my $startf = FREUtil::graindate( $start, 'year' );
   my $endf = FREUtil::graindate( $end, 'year' );

   my $filelist = "";
   my $cpiolist = "";
   until( $endf > $tENDf ) {
      $filelist = "$filelist $component.$startf-$endf.\$sea.\$var";
      $cpiolist = "$cpiolist $component.$startf-$endf.".FREUtil::timeabbrev($freq).".nc.cpio";
      $start = FREUtil::modifydate($start," + $subchunk years");
      $end = FREUtil::modifydate($end," + $subchunk years");
      $startf = FREUtil::graindate($start,'year');
      $endf = FREUtil::graindate($end,'year');
   }

   #get variables
   my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   my $setvarlist = "";
   if ("$variables" eq "") {
      $setvarlist = "set varlist = (`ls -1 | grep -v '.nc.cpio' | cut -f4-5 -d'.' | sort -u`)\n";
      $variables = '$varlist';
   } else {
      print STDERR "           from xml, vars are '$variables'\n" if $opt_v;
      $variables =~ s/ /.nc /g;
      if("$variables" ne "") {$variables =~ s/$/.nc/g};
      $setvarlist = "set varlist = ( $variables )\n";
   }

   my $start = FREUtil::modifydate($tEND,"-$cl years +1 sec");
   my $startf = FREUtil::graindate( $start, 'year');
   my $numtimelevels = gettimelevels($freq,$chunkLength);

   my $check_ncatted = errorstr("NCATTED ($component $freq $chunkLength ts from $subchunk yr ts)");
   my $check_ncrcat = errorstr("NCRCAT ($component $freq $chunkLength ts from $subchunk yr ts)");
   my $check_cpio_msg = "CPIO ($component $freq $chunkLength ts from $subchunk yr ts)";
   my $check_dmget = errorstr("DMGET ($component $freq $chunkLength ts from $subchunk yr ts)");
   my $check_levels = '';
   if ("$caltype" eq "NOLEAP" or "$caltype" eq "noleap" ) {
      $check_levels = errorstr("WRONG NUMBER OF TIME LEVELS (contains \$length, should be $numtimelevels) IN \$outdir/$component.$startf-$tENDf.\$sea.\$var");
   }
   my $check_vars = errorstr("MISSING FILE $reqpath/\$file, $component.$startf-$tENDf.\$sea.\$var NOT CREATED ($component $freq $chunkLength ts from $subchunk yr ts)");

   my @pieces = split ' ',$filelist;
   my $dmgetcommand = "";
   foreach my $piece ( @pieces ) {
      $piece =~ s/\$sea.\$var/*.nc/g;
      $dmgetcommand .= "$time_dmget dmget \"$piece\"\n";
   }
   my $csh = setcheckpt("seaTSfromts_$chunkLength");
   $csh .= <<EOF;
#####################################
echo 'timeSeries ($component $freq $chunkLength ts from $subchunk yr ts)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
if ( ! -e \$tempCache/$outdirpath ) mkdir -p \$tempCache/$outdirpath

EOF
   if ($opt_z) { $csh .= begin_systime(); }
   $csh .= <<EOF;

cd $reqpath
set cpiosexist = 1
foreach f ( $cpiolist )
   if ( ! -e \$f ) set cpiosexist = 0
end
if ( \$cpiosexist ) then
   $time_dmget dmget $cpiolist
   set mylist = (`ls $cpiolist`)
   cd \$work
   foreach cpio ( \$mylist )
      $time_cp $cp $reqpath/\$cpio .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $reqpath/\$cpio .
         $checktransfer
      endif
      $time_uncpio $uncpio -ivI \$cpio || ( echo "$check_cpio_msg"; echo "$check_cpio_msg" > \$work/.errors )
   end
   $setvarlist
else
   $setvarlist
   $dmgetcommand
   cd \$work
   foreach sea ( DJF MAM JJA SON )
      foreach var (\$varlist)
         foreach file ( $filelist )
            if ( ! -f \$tempCache/$req/\$file ) then
               $time_cp $cp $reqpath/\$file \$tempCache/$req/\$file
               if ( \$status ) then
                  echo "WARNING: data transfer failure, retrying..."
                  $time_cp $cp $reqpath/\$file \$tempCache/$req/\$file
                  $checktransfer
               endif
            endif
            ln -s \$tempCache/$req/\$file .
         end
      end
   end
endif

cd \$work
foreach sea (DJF MAM JJA SON)
   foreach var (\$varlist)
      set missingfiles = 0
      foreach file ($filelist)
         test -e \$file
         $check_vars
         if ( ! -e \$file ) set missingfiles = 1
      end
      if ( \$missingfiles == 0 ) then

      if ( -e $component.$startf-$tENDf.\$sea.\$var ) rm -f $component.$startf-$tENDf.\$sea.\$var
      $time_ncrcat ncrcat \$ncrcatopt $filelist $component.$startf-$tENDf.\$sea.\$var
      $check_ncrcat
      $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$startf-$tENDf.\$sea.\$var" $component.$startf-$tENDf.\$sea.\$var
      $check_ncatted
      set tmpstring = `ncdump -h $component.$startf-$tENDf.\$sea.\$var | grep UNLIMITED`
      @ len = \$#tmpstring - 1
      set length = `echo \$tmpstring[\$len] | cut -c2-`
      test \$length = $numtimelevels
      $time_mv $mvfile $component.$startf-$tENDf.\$sea.\$var \$outdir/
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $component.$startf-$tENDf.\$sea.\$var \$outdir/
         $checktransfer
      endif
      $time_mv $mv $component.$startf-$tENDf.\$sea.\$var \$tempCache/$outdirpath/
      $check_levels

      endif
   end
end

EOF
   if ( $aggregateTS ) {
      $csh .= createcpio( "\$tempCache/$outdirpath",$outdir,"$component.$startf-$tENDf",FREUtil::timeabbrev($freq),1);
   }
   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);

   return $csh;
}



#TIMEAVERAGES - SEASONAL
sub seasonalAVfromhist {
   #taNode = $_[0] ;
   my $sim0 = $_[1];
   my $ppcNode = $_[0]->parentNode;

   my $src = 'seasonal';
   my $interval = $_[0]->findvalue('@interval');
   my $outdir = "$ppRootDir/$component/av/$src"."_$interval";
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $tmp = FREUtil::modifydate($tEND,"+ 1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $int = $interval;
   $int =~ s/yr//;
   my $mod = $yrsSoFar % $int;
   unless( $mod == 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $int > $maxyrs ) { $maxyrs = $int; }
   my $hDateyr = $userstartyear;
   my @hDates = ( FREUtil::padzeros($hDateyr-$int+1) .. "$hDateyr" );
   my $tBEG = FREUtil::modifydate($tEND,"- $int years + 1 sec");
   my $range = FREUtil::graindate($tEND,'year');
   if (scalar @hDates > 1) { $range = FREUtil::padzeros($range-$int+1)."-$range"; }
   foreach my $d (@hDates) { $historyfiles .= "$d"."0101.nc.tar "; }

   my $diag_source =  $_[0]->findvalue('@diagSource');
   my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
   if ( scalar @monthnodes and "$diag_source" eq "" ) {
    my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
    $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if ( "$diag_source" eq "") { $diag_source = $component."_month"; }

   #get variables
   my $variables = FREUtil::cleanstr( $_[0]->findvalue('variables') );
   $variables =~ s/ /,/g;

   my $zInterp = $ppcNode->findvalue('@zInterp');
   my $do_zInterp = 0;
   if ("$zInterp" ne "") {  $do_zInterp = 1; }
   my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
   my $check_cpio = errorstr("CPIO/TAR ($component $src $interval averages)");
   my $check_cpio_msg = "CPIO ($component $src $interval averages)";
   my $check_ncrcat = errorstr("NCRCAT ($component $src $interval averages)");
   my $check_timavg = retryonerrorend("TIMAVG ($component $src $interval averages)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_plevel = errorstr("PLEVEL ($component $src $interval averages)");
   my $check_ncdump = errorstr("NCDUMP ($component $src $interval averages)");
   my $check_dmget = errorstr("DMGET ($component $src $interval averages)");
   my $check_ncap = errorstr("NCAP ($component $src $interval averages)");
   my $check_numfiles = errorstr("INCORRECT NUMBER OF SEASONS IN SEASONAL FILE ($component $src $interval averages)");
   my $check_fregrid = errorstr("FREGRID ($component $src $interval averages)");
   my $check_ncrename = errorstr("NCRENAME ($component $src $interval averages)");
   my $convertSeg=convertSegments($segTime,$segUnits,$diag_source);
   my $convertDec=convertSegments($segTime,$segUnits,$diag_source,'dec');
   my $decSeg = ( split ' ', $convertDec )[ -4 ];
   $decSeg =~ s/.*(\d\d01).*/$1/;

   my $csh = setcheckpt("seasonalAVfromhist_$interval");
   $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir
mkdir out
EOF
   if ($opt_z) { $csh .= begin_systime(); }

   my $startseason = 1;
   my $totalseasons = $int * 4;



   if ( "$sourceGrid" eq 'cubedsphere' ) { #IF CUBIC

      my $tmpsrcstr = "$diag_source.tile*.nc";
      $csh .= <<EOF;
   foreach hDate ( @hDates )
      set nhistfiles = 0
      foreach file ( `ls \$histDir/\$hDate*/*.$tmpsrcstr`)
        ln -s \$file .
        @ nhistfiles ++
      end
      foreach file ( `ls \$histDir/\$hDate*/*.grid_spec.tile*.nc`)
        ln -s \$file .
      end
      if ( \$nhistfiles == 0 ) then
         echo 'ERROR: No history files matching \$hDate*/*.$tmpsrcstr'
      endif
      $convertSeg
   end
EOF
   foreach my $season ($startseason .. $totalseasons) {
      my $startmo = $season * 3 - 4;
      my $tSEASON = FREUtil::modifydate($tBEG,"+ $startmo months");
      my $seahist = FREUtil::graindate($tSEASON,'day');
      my $tSEASONf = FREUtil::graindate($tSEASON,'seasonal');
      my ($year) = $tSEASONf =~ /(\d{4,})\./;
      my ($prevyear) = $seahist =~ /(\d{4,})\d{4}/;
      my $prevhistcpio = "$prevyear".$decSeg.".nc.cpio";
      my $prevhisttar = "$prevyear".$decSeg.".nc.tar";
      my $nextd = FREUtil::modifydate($tSEASON, "+ 12 months");
      my $nextdec = FREUtil::graindate($nextd,'day').".$diag_source.nc";
      my $tile = '.tile$i';

      my $nextdec = FREUtil::graindate($nextd,'day').".$diag_source";
      my $hfilelist1 = "";
      my $hfilelist2 = "";
      my $hfilelist3 = "";
      my $hfilelist4 = "";
      my $hfilelist5 = "";
      my $hfilelist6 = "";
      foreach my $s ($startmo .. ($startmo+2)) {
         my $t = FREUtil::modifydate($tBEG,"+ $s months");
         my $shist = FREUtil::graindate($t,'day');
         $hfilelist1 = "$hfilelist1 $shist.$diag_source.tile1.nc";
         $hfilelist2 = "$hfilelist2 $shist.$diag_source.tile2.nc";
         $hfilelist3 = "$hfilelist3 $shist.$diag_source.tile3.nc";
         $hfilelist4 = "$hfilelist4 $shist.$diag_source.tile4.nc";
         $hfilelist5 = "$hfilelist5 $shist.$diag_source.tile5.nc";
         $hfilelist6 = "$hfilelist6 $shist.$diag_source.tile6.nc";
      }
      $csh .= <<EOF;
echo season $season ==============================================================
EOF
      if ( $season == 1 ) {
         $csh .= <<EOF;
if ( ! -e $seahist.$diag_source.tile1.nc ) then
   if ( -e $ppRootDir/.dec/$seahist.$diag_source.tile1.nc ) then
      $time_dmget dmget $ppRootDir/.dec/$seahist.$diag_source.tile?.nc
      $time_cp $cp $ppRootDir/.dec/$seahist.$diag_source.tile?.nc .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $ppRootDir/.dec/$seahist.$diag_source.tile?.nc .
         $checktransfer
      endif
      $time_rm rm -f $ppRootDir/.dec/$seahist.$diag_source.tile?.nc
   else if ( -e $opt_d/$prevhistcpio ) then
      $time_dmget dmget $opt_d/$prevhistcpio
      $time_uncpio $uncpio -ivI $opt_d/$prevhistcpio '*.$diag_source.tile*.nc'
      $check_cpio
      $time_dmput dmput $opt_d/$prevhistcpio &
      set prevyear = $prevyear
      set i = 1
      while ( \$i <= 6 )
        $convertDec
        @ i ++
      end
   else if ( -e $opt_d/$prevhisttar ) then
      $time_dmget dmget $opt_d/$prevhisttar
      $time_untar tar -xvf $opt_d/$prevhisttar --wildcards '*.$diag_source.tile*.nc'
      $check_cpio
      $time_dmput dmput $opt_d/$prevhisttar &
      set prevyear = $prevyear
      set i = 1
      while ( \$i <= 6 )
        $convertDec
        @ i ++
      end
   else
      set t = `ncdump -h $nextdec.tile1.nc | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
      set att_copy = (`ncdump -h $nextdec.tile1.nc | sed -ne "s/.*\${t}:\\(.*\\) =.*/\$t@\\1=\$t@\\1;/gp"`)
      #set hasAVT1 = `ncdump -v average_T1 $nextdec.tile1.nc | wc -l`
      if ( `ncdump -h $nextdec.tile1.nc | grep -c " average_T1("` == 1 ) then
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${t}_bounds=\${t}_bounds-365; \$att_copy" $nextdec.tile1.nc $seahist.$diag_source.tile1.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${t}_bounds=\${t}_bounds-365; \$att_copy" $nextdec.tile2.nc $seahist.$diag_source.tile2.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${t}_bounds=\${t}_bounds-365; \$att_copy" $nextdec.tile3.nc $seahist.$diag_source.tile3.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${t}_bounds=\${t}_bounds-365; \$att_copy" $nextdec.tile4.nc $seahist.$diag_source.tile4.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${t}_bounds=\${t}_bounds-365; \$att_copy" $nextdec.tile5.nc $seahist.$diag_source.tile5.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${t}_bounds=\${t}_bounds-365; \$att_copy" $nextdec.tile6.nc $seahist.$diag_source.tile6.nc
         $check_ncap
      else
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile1.nc $seahist.$diag_source.tile1.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile2.nc $seahist.$diag_source.tile2.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile3.nc $seahist.$diag_source.tile3.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile4.nc $seahist.$diag_source.tile4.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile5.nc $seahist.$diag_source.tile5.nc
         $check_ncap
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec.tile6.nc $seahist.$diag_source.tile6.nc
         $check_ncap
      endif
   endif
endif
EOF
      }

      $csh .= <<EOF;
if ( -e sea1.nc ) $time_rm rm -f sea?.nc
$time_ncrcat ncrcat \$ncrcatopt $hfilelist1 sea1.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist2 sea2.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist3 sea3.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist4 sea4.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist5 sea5.nc
$check_ncrcat
$time_ncrcat ncrcat \$ncrcatopt $hfilelist6 sea6.nc
$check_ncrcat
$time_rm rm $hfilelist1 $hfilelist2 $hfilelist3 $hfilelist4 $hfilelist5 $hfilelist6
EOF
#put code here to handle 1yr seasons case
      if ( $int == 1 ) {
         if ( $do_zInterp ) {
            foreach my $t ( 1 .. 6 ) {
               $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels$t.nc sea$t.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels$t.nc sea$t.nc
$check_timavg
EOF
               $csh .= zInterpolate($zInterp,"modellevels$t.nc","$component.$tSEASONf.tile$t.nc",$caltype,$variables);
            }
            $csh .= "$time_rm rm modellevels?.nc\n";

         } else {
            foreach my $t ( 1 .. 6 ) {
               $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$tSEASONf.tile$t.nc sea$t.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$tSEASONf.tile$t.nc sea$t.nc
$check_timavg
EOF
            }
         }

         my $fregrid_wt = '';
         if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
            print "       land_frac found, weighting exchange grid cell with $hDate.land_static\n" if $opt_v;
            $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
         }
         my $call_and_check_fregrid = $call_tile_fregrid;
         $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
         $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
         $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
         $csh .= <<EOF;
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = $component.$tSEASONf
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

    $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$tSEASONf.nc" $component.$tSEASONf.nc
    $check_ncatted

$time_mv $mvfile $component.$tSEASONf.nc \$outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$tSEASONf.nc \$outdir/
   $checktransfer
endif
$time_rm rm $component.$tSEASONf.nc
if ( -e \$outdir/$component.$tSEASONf.nc ) $time_rm rm -f sea1.nc sea2.nc sea3.nc sea4.nc sea5.nc sea6.nc
EOF
      } else { #int > 1
         foreach my $t ( 1 .. 6 ) {
            $csh .= <<EOF;
$time_timavg \$TIMAVG -o out/$component.$tSEASONf.tile$t.nc sea$t.nc
$retry_timavg
   $time_timavg \$TIMAVG -o out/$component.$tSEASONf.tile$t.nc sea$t.nc
$check_timavg
$time_rm rm -f sea$t.nc
EOF
         }
      }
   }

   my $startmo = ($totalseasons+1) * 3 - 4;
   my $tSEASON = FREUtil::modifydate($tBEG,"+ $startmo months");
   my $nextdec = FREUtil::graindate($tSEASON,'day').".$diag_source";
   $csh .= <<EOF;
$time_mv $mvfile $nextdec.tile* $ppRootDir/.dec/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $nextdec.tile* $ppRootDir/.dec/
   $checktransfer
endif
$time_rm rm $nextdec.tile*
EOF

   if ( $int > 1 ) {
      $csh .= <<EOF;
$time_mv $mv out/* .
rmdir out
EOF
   foreach my $season ( 'DJF','MAM','JJA','SON' ) {
      my $dates = "$range".".$season";
      $csh .= <<EOF;
echo season $season =========================================================
test $int = `ls -1 $component.*.$season.tile1.nc | wc -l`
$check_numfiles
set i = 1
while ( \$i <= 6 )
  set list = `ls -1 $component.*.$season.tile\$i.nc`
  if ( -e sea\$i.nc ) $time_rm rm -f sea\$i.nc
  $time_ncrcat ncrcat \$ncrcatopt \$list sea\$i.nc
  $check_ncrcat
  $time_rm rm -f \$list
EOF

      if ( $do_zInterp ) {
         $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels\$i.nc sea\$i.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels\$i.nc sea\$i.nc
$check_timavg
EOF
         $csh .= zInterpolate($zInterp,'modellevels$i.nc',"$component.$dates.tile\$i.nc",$caltype,$variables);
      } else {
         $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$dates.tile\$i.nc sea\$i.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$dates.tile\$i.nc sea\$i.nc
$check_timavg
EOF
      }

      #apparently we are assuming we want to convert to latlon...?
      my $fregrid_wt = '';
      if ( $component =~/land/ and $dtvars{all_land_static} =~/\bland_frac\b/ ) {
         print "       land_frac found, weighting exchange grid cell with $hDate.land_static\n" if $opt_v;
         $fregrid_wt = "--weight_file $hDate.land_static --weight_field land_frac";
      }
      my $call_and_check_fregrid = $call_tile_fregrid;
      $call_and_check_fregrid =~ s/#check_fregrid/$check_fregrid/;
      $call_and_check_fregrid =~ s/#check_ncrename/$check_ncrename/g;
      $call_and_check_fregrid =~ s/#check_ncatted/$check_ncatted/g;
      $csh .= <<EOF;
@ i ++
end
    set fregrid_wt = "$fregrid_wt"
    set fregrid_in_date = $hDate
    set fregrid_in = $component.$dates
    set nlat = $nlat ; set nlon = $nlon
    set interp_method = $interpMethod
    set ncvars_arg = -st23
    set variables = ( $variables )
    set fregrid_remap_file = $xyInterpRegridFile
    $call_and_check_fregrid

    $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$dates.nc" $component.$dates.nc
    $check_ncatted

$time_mv $mvfile $component.$dates.nc \$outdir/$component.$dates.nc
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$dates.nc \$outdir/$component.$dates.nc
   $checktransfer
endif
$time_rm rm $component.$dates.nc
$time_dmput dmput \$outdir/$component.$dates.nc &
$time_rm rm -f sea1.nc sea2.nc sea3.nc sea4.nc sea5.nc sea6.nc
EOF
   }
   }

   } else { #ELSE NOT CUBIC

      my $tmpsrcstr = "$diag_source.nc";
      $csh .= <<EOF;
   foreach hDate ( @hDates )
      set nhistfiles = 0
      foreach file ( `ls \$histDir/\$hDate*/*.$tmpsrcstr`)
        ln -s \$file .
        @ nhistfiles ++
      end
      if ( \$nhistfiles == 0 ) then
         echo 'ERROR: No history files matching \$hDate*/*.$tmpsrcstr'
      endif
      $convertSeg
   end
EOF

   foreach my $season ($startseason .. $totalseasons) {
      my $startmo = $season * 3 - 4;
      my $plus = "+";
      if ( "$startmo" =~ /^-/ ) { $plus = ''; }
      my $tSEASON = FREUtil::modifydate($tBEG,"$plus $startmo months");
      my $seahist = FREUtil::graindate($tSEASON,'day');
      my $tSEASONf = FREUtil::graindate($tSEASON,'seasonal');
      my ($year) = $tSEASONf =~ /(\d{4,})\./;
      my ($prevyear) = $seahist =~ /(\d{4,})\d{4}/;
      my $prevhistcpio = "$prevyear".$decSeg.".nc.cpio";
      my $prevhisttar = "$prevyear".$decSeg.".nc.tar";
      my $nextd = FREUtil::modifydate($tSEASON, "+ 12 months");
      my $nextdec = FREUtil::graindate($nextd,'day').".$diag_source.nc";
      my $hfilelist = "";
      foreach my $s ($startmo .. ($startmo+2)) {
         my $plus = "+";
         if ( "$s" =~ /^-/ ) { $plus = ''; }
         my $t = FREUtil::modifydate($tBEG,"$plus $s months");
         my $shist = FREUtil::graindate($t,'day');
         $hfilelist = "$hfilelist $shist.$diag_source.nc";
      }

      if ( $season == 1 ) {
         $csh .= <<EOF;
echo season $season ==============================================================
if ( ! -e $seahist.$diag_source.nc ) then
   if ( -e $ppRootDir/.dec/$seahist.$diag_source.nc ) then
      $time_dmget dmget $ppRootDir/.dec/$seahist.$diag_source.nc
      $time_cp $cp $ppRootDir/.dec/$seahist.$diag_source.nc .
      if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_cp $cp $ppRootDir/.dec/$seahist.$diag_source.nc .
         $checktransfer
      endif
      $time_rm rm -f $ppRootDir/.dec/$seahist.$diag_source.nc
   else if ( -e $opt_d/$prevhistcpio ) then
      $time_dmget dmget $opt_d/$prevhistcpio
      $time_uncpio $uncpio -ivI $opt_d/$prevhistcpio '*.$diag_source.nc'
      $check_cpio
      $time_dmput dmput $opt_d/$prevhistcpio &
      set prevyear = $prevyear
      $convertDec
   else if ( -e $opt_d/$prevhisttar ) then
      $time_dmget dmget $opt_d/$prevhisttar
      $time_untar tar -xvf $opt_d/$prevhisttar --wildcards '*.$diag_source.nc'
      $check_cpio
      $time_dmput dmput $opt_d/$prevhisttar &
      set prevyear = $prevyear
      $convertDec
   else
      set t = `ncdump -h $nextdec | grep -i '.*=.*unlimited.*currently' | awk '{print \$1}'`
      set att_copy = (`ncdump -h $nextdec | sed -ne "s/.*\${t}:\\(.*\\) =.*/\$t@\\1=\$t@\\1;/gp"`)
      #set hasAVT1 = `ncdump -v average_T1 $nextdec | wc -l`
      if ( `ncdump -h $nextdec | grep -c " average_T1("` == 1 ) then
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; average_T1=average_T1-365; average_T2=average_T2-365; \${t}_bounds=\${t}_bounds-365; \$att_copy" $nextdec $seahist.$diag_source.nc
         $check_ncap
      else
         $time_ncap ncap2 -h -O -s "\${t}[\${t}]=\${t}-365; \$att_copy" $nextdec $seahist.$diag_source.nc
         $check_ncap
      endif
   endif
endif
EOF
      } else {
         $csh .= <<EOF;
echo season $season ==============================================================
EOF
      }

      $csh .= <<EOF;
if ( -e sea.nc ) $time_rm rm -f sea.nc
$time_ncrcat ncrcat \$ncrcatopt $hfilelist sea.nc
$check_ncrcat
$time_rm rm -f $hfilelist
EOF
#put code here to handle 1yr seasons case
      if ( $int == 1 ) {
         if ( $do_zInterp ) {
            $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels.nc sea.nc
$check_timavg

EOF
            $csh .= zInterpolate($zInterp,'modellevels.nc',"$component.$tSEASONf.nc",$caltype,$variables);
            $csh .= <<EOF;
$time_mv $mvfile $component.$tSEASONf.nc \$outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$tSEASONf.nc \$outdir/
   $checktransfer
endif

EOF
         } else {
            $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$tSEASONf.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$tSEASONf.nc sea.nc
$check_timavg
$time_mv $mvfile $component.$tSEASONf.nc \$outdir/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$tSEASONf.nc \$outdir/
   $checktransfer
endif
$time_rm rm $component.$tSEASONf.nc
if ( -e \$outdir/$component.$tSEASONf.nc ) $time_rm rm -f sea.nc
EOF
         }
      } else {
         $csh .= <<EOF;
$time_timavg \$TIMAVG -o out/$component.$tSEASONf.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o out/$component.$tSEASONf.nc sea.nc
$check_timavg
if ( -e out/$component.$tSEASONf.nc ) $time_rm rm -f sea.nc
EOF
      }
   }


   my $startmo = ($totalseasons+1) * 3 - 4;
   my $tSEASON = FREUtil::modifydate($tBEG,"+ $startmo months");
   my $nextdec = FREUtil::graindate($tSEASON,'day').".$diag_source.nc";
   $csh .= <<EOF;
$time_mv $mvfile $nextdec $ppRootDir/.dec/
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $nextdec $ppRootDir/.dec/
   $checktransfer
endif
$time_rm rm $nextdec
cd out
EOF

   if ( $int > 1 ) {
   foreach my $season ( 'DJF','MAM','JJA','SON' ) {
      my $dates = "$range".".$season";
      $csh .= <<EOF;
echo season $season =========================================================
test $int = `ls -1 $component.*.$season.nc | wc -l`
$check_numfiles
set list = `ls -1 $component.*.$season.nc`
if ( -e sea.nc ) $time_rm rm -f sea.nc
$time_ncrcat ncrcat \$ncrcatopt \$list sea.nc
$check_ncrcat
$time_rm rm -f \$list
EOF

      if ( $do_zInterp ) {
         $csh .= <<EOF;
$time_timavg \$TIMAVG -o modellevels.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o modellevels.nc sea.nc
$check_timavg

EOF
         $csh .= zInterpolate($zInterp,'modellevels.nc',"$component.$dates.nc",$caltype,$variables);
      } else {
         $csh .= <<EOF;
$time_timavg \$TIMAVG -o $component.$dates.nc sea.nc
$retry_timavg
   $time_timavg \$TIMAVG -o $component.$dates.nc sea.nc
$check_timavg
EOF
      }

   $csh .= <<EOF;
$time_ncatted ncatted -h -O -a filename,global,m,c,"\$outdir/$component.$dates.nc" $component.$dates.nc
$check_ncatted
$time_mv $mvfile $component.$dates.nc \$outdir/$component.$dates.nc
if ( \$status ) then
   echo "WARNING: data transfer failure, retrying..."
   $time_mv $mvfile $component.$dates.nc \$outdir/$component.$dates.nc
   $checktransfer
endif
$time_rm rm $component.$dates.nc
$time_dmput dmput \$outdir/$component.$dates.nc &
$time_rm rm sea.nc
EOF
   }
   }

  #END NOT CUBIC
  }

   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);

   return $csh;
}


#TIMEAVERAGES - SEASONAL (doesn't support cubedsphere)
sub seasonalAVfromav {
   #taNode = $_[0] ;
   my $sim0 = $_[1];
   my $subint = $_[2];
   my $ppcNode = $_[0]->parentNode;

   my $src = 'seasonal';
   my $interval = $_[0]->findvalue('@interval');
   my $outdir = "$ppRootDir/$component/av/$src"."_$interval";
   my $srcdir = "$ppRootDir/$component/av/$src"."_$subint"."yr";
   my $chunkLength = $_[0]->findvalue('@chunkLength');
   my $tmp = FREUtil::modifydate($tEND,"+ 1 sec");
   my $yrsSoFar = &Delta_Format( FREUtil::dateCalc($sim0,$tmp) ,0,"%yd");
   my $int = $interval;
   $int =~ s/yr//;
   my $mod = $yrsSoFar % $int;
   unless( $mod == 0 ) { return ""; }
   $mkdircommand .= "$outdir ";
   if( $int > $maxyrs ) { $maxyrs = $int; }

   #check for missing files
   my $diag_source =  $_[0]->findvalue('@diagSource');
   my @monthnodes = $ppcNode->findnodes('timeSeries[@freq="monthly"]');
   if ( scalar @monthnodes and "$diag_source" eq "" ) {
    my $monthnode = $ppcNode->findnodes('timeSeries[@freq="monthly"]')->get_node(1);
    $diag_source = $monthnode->getAttribute('@source');
   }
   if ( "$diag_source" eq "" ) { $diag_source = $_[0]->findvalue('../@source'); }
   if ( "$diag_source" eq "") { $diag_source = $component."_month"; }

   my $end = FREUtil::graindate($tEND,'year');
   my $start = FREUtil::padzeros($end-$int+1);

   my $substart = $start;
   my $subend = FREUtil::padzeros($start + $subint - 1);
   my $filelist = "";
   my $getlist = "";
   until( $subend > $end ) {
      if($substart == $subend) {$filelist .= "$component.$substart.\$sea.nc ";}
      else {$filelist .= "$component.$substart-$subend.\$sea.nc ";}
      $substart = FREUtil::padzeros($substart + $subint);
      $subend = FREUtil::padzeros($subend + $subint);
   }
   my $getlist = $filelist;
   $getlist =~ s/\$sea/*/g;
#   print "filelist is $filelist\n";
#   print "getlist is $getlist\n";

   my $check_ncatted = errorstr("NCATTED ($component $src $interval averages)");
   my $check_ncrcat = errorstr("NCRCAT ($component $src $interval averages)");
   my $check_timavg = retryonerrorend("TIMAVG ($component $src $interval averages)");
   my $retry_timavg = retryonerrorstart("TIMAVG");
   my $check_dmget = errorstr("DMGET ($component $src $interval averages)");
   my $csh = setcheckpt("seasonalAVfromav_$interval");
   $csh .= <<EOF;
#####################################
echo 'timeAverage ($component $src $interval averages from $subint yr averages)'
cd \$work
find \$work/* -maxdepth 1 -exec rm -rf {} \\;
set outdir = $outdir
if ( ! -e \$outdir ) mkdir -p \$outdir

EOF
   if ($opt_z) { $csh .= begin_systime(); }
   $csh .= <<EOF;

cd $srcdir
$time_dmget dmget "$getlist"

foreach sea (DJF MAM JJA SON)
     cd \$work
     foreach file ($filelist)
        $time_cp $cp $srcdir/\$file .
        if ( \$status ) then
           echo "WARNING: data transfer failure, retrying..."
           $time_cp $cp $srcdir/\$file .
           $checktransfer
        endif
     end
     if ( -e \$sea.nc ) rm -f \$sea.nc
     $time_ncrcat ncrcat \$ncrcatopt $filelist \$sea.nc
     $check_ncrcat
     $time_timavg \$TIMAVG -o $component.$start-$end.\$sea.nc \$sea.nc
     $retry_timavg
        $time_timavg \$TIMAVG -o $component.$start-$end.\$sea.nc \$sea.nc
     $check_timavg
     $time_ncatted ncatted -h -O -a filename,global,m,c,"$component.$start-$end.\$sea.nc" $component.$start-$end.\$sea.nc
     $check_ncatted
     $time_mv $mvfile $component.$start-$end.\$sea.nc \$outdir/$component.$start-$end.\$sea.nc
     if ( \$status ) then
         echo "WARNING: data transfer failure, retrying..."
         $time_mv $mvfile $component.$start-$end.\$sea.nc \$outdir/$component.$start-$end.\$sea.nc
         $checktransfer
     endif
     $time_rm rm $component.$start-$end.\$sea.nc
     $time_dmput dmput \$outdir/$component.$start-$end.\$sea.nc &
     $time_rm rm -f \$sea.nc
end

EOF

   if ($opt_z) { $csh .= end_systime(); }
   $csh .= mailerrors($outdir);

   return $csh;
}



#hsmget history data into work area
#provide directory for user to put new history files
#run user scripts
#package the new data into new history file
sub refineDiag {
   my $tmphistdir = $_[0];
   my $stdoutdir = $_[1];
   my $ptmpDir = $_[2];
   my $basedate = $_[3];
   my $refinedir = $_[4];
   my $gridspec = $_[5];

   my $newhistorydir = "$opt_d"."_refineDiag";
   my $csh  = <<EOF;

set refineRequestsExit = 0
set refineError = 0
#make additional data available to the refineDiag user scripts
set basedate = '$basedate'
set gridspec = '$gridspec'

set historyyear = `echo $hDate | sed 's/[0-9][0-9][0-9][0-9]\$//'`
cd \$histDir
foreach historyfile ( `ls \$historyyear????.nc.cpio \$historyyear????.nc.tar`)
   set hsmdate = \$historyfile:r

   #set up refineDiag input data and output directory
   set refineDiagDir = "$tmphistdir/history_refineDiag/\$hsmdate"
   mkdir -p \$refineDiagDir

   $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w \$work \$hsmdate/\\*
   if ( \$status ) then
      echo "WARNING: hsmget reported failure, retrying..."
      $time_hsmget \$hsmget -a $opt_d -p $ptmpDir/history -w \$work \$hsmdate/\\*
      $checktransfer
   endif
   cd \$work/\$hsmdate

   #source user refineDiag scripts
EOF

   my @refineScripts = split ',',$opt_D;
   foreach my $s ( @refineScripts ) {
      if ( ! -e "$s" ) { die "ERROR: Your refineDiag script does not exist: $s\n"; }
      $csh .= <<EOF;
   source $s
   set refineStatus = \$status
   if ( \$refineStatus < 0 ) then
      echo "NOTE: RefineDiag script $s requested no further processing after refineDiag scripts complete"
      set refineRequestsExit = 1
   else if ( \$refineStatus ) then
      echo "ERROR: RefineDiag script got an error status \$refineStatus"
      set refineError = 1
   endif

EOF
   }

   $csh .= <<EOF;

   #append the new variables to the refineDiag.log file
   cd \$refineDiagDir
   set refinedCount = `ls -1 *nc | wc -l`
   if ( \$refinedCount ) then

      foreach refinedFile ( `ls *nc` )
         echo "$refinedir/\$hsmdate.tar,\$refinedFile" >> $stdoutdir/postProcess/refineDiag.log
         \$NCVARS -st01234 \$refinedFile >> $stdoutdir/postProcess/refineDiag.log
      end

      #save new or modified refineDiag history file
      if ( -f $newhistorydir/\$hsmdate.tar ) then
         $time_hsmget \$hsmget -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/modify_refineDiag \$hsmdate/\\*
         if ( \$status ) then
            echo "WARNING: hsmget reported failure, retrying..."
            $time_hsmget \$hsmget -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/modify_refineDiag \$hsmdate/\\*
            $checktransfer
         endif
         mv -f * $tmphistdir/modify_refineDiag/\$hsmdate/
         mv -f $tmphistdir/modify_refineDiag/\$hsmdate/* .
         rm -rf $tmphistdir/modify_refineDiag
         $time_hsmput \$hsmput -s tar -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/history_refineDiag \$hsmdate
         if ( \$status ) then
            echo "WARNING: hsmput reported failure, retrying..."
            $time_hsmput \$hsmput -s tar -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/history_refineDiag \$hsmdate
            $checktransfer
         endif
      else
         $time_hsmput \$hsmput -s tar -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/history_refineDiag \$hsmdate
         if ( \$status ) then
            echo "WARNING: hsmput reported failure, retrying..."
            $time_hsmput \$hsmput -s tar -a $newhistorydir -p $ptmpDir/history_refineDiag -w $tmphistdir/history_refineDiag \$hsmdate
            $checktransfer
         endif
      endif
   endif
end

if ( \$refineError ) exit \$refineError
if ( \$refineRequestsExit ) exit 0

EOF

   return $csh;
}


#write c-shell runscript, chmod, and optionally submit
#batchCmd = "qsub -pe $defaultQueue $npes -o $stdoutPath -r y -P $project -l h_cpu=$maxRunTime"
#writescript($cshscript,$outscript,$batchCmd,$defaultQueue,$npes,$stdoutPath,$project,$maxRunTime);
sub writescript {
   #my $script = $_[0];
   my $outscript = $_[1];
   my $batchCmd = $_[2];
   my $statefile = $_[3];
   my $defaultQueue = $_[4];
   my $npes = $_[5];
   my $stdoutPath = $_[6];
   my $project = $_[7];
   my $maxRunTime = $_[8];

   if("$defaultQueue" ne "") { $batchCmd =~ s/\$defaultQueue/$defaultQueue/g; }
      else { $batchCmd =~ s/\$defaultQueue//g; }
   if("$npes" ne "") { $batchCmd =~ s/\$npes/$npes/g; }
      else { $batchCmd =~ s/\$npes//g; }
   if("$stdoutPath" ne "") { $batchCmd =~ s/\$stdoutPath/$stdoutPath/g; }
      else { $batchCmd =~ s/\$stdoutPath//g; }
   if("$project" ne "") { $batchCmd =~ s/\$project/$project/g; }
      else { $batchCmd =~ s/\$project//g; }
   if("$maxRunTime" ne "") { $batchCmd =~ s/\$maxRunTime/$maxRunTime/g; }
      else { $batchCmd =~ s/\$maxRunTime//g; }

   #print "Preparing '$batchCmd'\n";

   (my $volume,my $directory,my $filename) = File::Spec->splitpath( $outscript );
   if( ! -e $directory ) { mkdir $directory || die "Cannot make directory $directory\n"; }

   open(OUT,"> $outscript");
   print OUT $_[0];
   close(OUT);

   my $status = system("chmod 755 $outscript");
   if( $status ) { die "Sorry, I couldn't chmod $outscript"; }

   if( $opt_s ) {
      $batchCmd = "sleep 2;$batchCmd";
      print "\nExecuting '$batchCmd $outscript'\n" if $opt_v;
      my $qsub_msg = `$batchCmd $outscript`;
      print "\n$qsub_msg";

         $qsub_msg =~ s/^$//mg;
         my @njobid = split '\n',$qsub_msg;
         my $newjobid = $njobid[-1];
         $newjobid =~ s/New jobid='(.*)'/$1/ if $newjobid =~ /New jobid/;
         $newjobid =~ s/Previous frepp job \((.*)\).*/$1/ if $newjobid =~ /still running for /;
         #print "New jobid='$newjobid'\n";
         if ( "$newjobid" eq '' ) {
            print "No jobid resulted from the Moab job submission of $hDate.\n";
            print "ERROR: Unable to submit job, exiting.\n";
            exit 1;
         } elsif ( "$newjobid" !~ /gfdl.\d+/ ) {
            print "ERROR: the jobid returned has the wrong format: a frepp/moab issue occurred.\n";
            exit 1;
         }
         if("$statefile" ne "") {
            open( STATEFILE, ">$statefile") or die $!;
            print STATEFILE "$newjobid\n";
            close STATEFILE;
         }

   } else {
      print "\nTO SUBMIT: $batchCmd $outscript\n";
   }
}



sub getTemplate {
   my $platform = $_[0];

   my $cshscripttmpl = '';
   if ( "$platform" eq 'ia64' ) {
      $cshscripttmpl = <<'EOF';
#!/bin/csh -f
#$ -l h_cpu
#$ -pe ic.postp 1
#$ -o
#$ -r y
#$ -soft -l fre_info=
EOF
   } else {
      $cshscripttmpl = <<'EOF';
#!/bin/csh -f
#PBS -N
#PBS -l walltime
#PBS -l nodes=1
#PBS -j oe
#PBS -o
#PBS -r y
#PBS -S /bin/csh
#$ -soft -l fre_info=
EOF
      $cshscripttmpl .= <<EOF;

setenv JOB_ID `echo \$PBS_JOBID |cut -f1 -d.`
setenv FRE_STDOUT_PATH
if ( -d "$workdir" ) then
  rm -rf $workdir
endif
mkdir -p $workdir
EOF
   }

   $cshscripttmpl .= <<'EOF';
#=======================================================================
#version_info
#=======================================================================
unalias *
set echo
#get_site_config
########################################################################
#-------------------- variables set by script --------------------------
########################################################################
set name
set rtsxml
set work
set tempCache
set root
set archive
set scriptName
set oname
set ptmpDir
set histDir
set platform
set target
set prevjobstate
set statefile

#platform_csh_from_xml

#write_to_statefile

limit stacksize unlimited
setenv FMS_FRE_FREPP
set NCVARS = list_ncvars.csh
set TIMAVG = "timavg.csh -mb"
set PLEVEL = plevel.sh
set SPLITNCVARS = split_ncvars.csh
set MPPNCCOMBINE = mppnccombine
set checkptfile = $scriptName:t
set errors_found = 0
if (! -d $work) mkdir -p $work
if (! -d $tempCache) mkdir -p $tempCache
which ncks
which ncrcat

#set up HSM
set hsmget = "hsmget -v -m $FRE_COMMANDS_HOME/site/gfdl/hsmget.mk -t";
set hsmput = "hsmput -v -m $FRE_COMMANDS_HOME/site/gfdl/hsmput.mk -t";
if ( $?HSM_HOME ) then
   if ( -d $HSM_HOME ) then
     set hsmget = 'hsmget -v -t';
     set hsmput = 'hsmput -v -t';
   endif
endif

#checkpointing option to skip to certain point in script
set options = ( )
set argv = (`getopt g: $*`)
while ("$argv[1]" != "--")
    switch ($argv[1])
        case -g:
            set checkpt = $argv[2]; shift argv; breaksw
    endsw
    shift argv
end
shift argv

EOF

   $cshscripttmpl =~ s/-pe ic.postp 1/-pe ic.postp $basenpes/;

return $cshscripttmpl;
}







}
