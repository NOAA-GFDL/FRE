#!/usr/bin/env perl
# -*- cperl -*-
#
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to Create a Script to Compile a Model
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2012, 2015, 2016
# Designed and written by V. Balaji, Amy Langenhorst, Aleksey Yakovlev and
# Seth Underwood
#

use strict;

use File::Basename();
use File::Copy();
use File::Path();
use File::Spec();
use Getopt::Long( ':config', 'no_ignore_case', 'no_auto_abbrev' );

use FRE();
use FREDefaults();
use FREExperiment();
use FREMsg();
use FREPlatforms();
use FRETargets();
use FRETemplate();
use FREUtil();
use FREXML();

use Email::Valid;

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////// Global constants //
# //////////////////////////////////////////////////////////////////////////////

{

    package fremake;

    use constant VERSION => '$Id: fremake,v 18.0.2.27.2.13.2.2 2014/02/21 18:43:11 fms Exp $';

    use constant OPTLIST => (
        'force-checkout|f', 'force-compile|F', 'keep-compiled|K', 'link|L!',
        'make-jobs|j=i',    'execute|E',       'help|h',          'ncores|n=i',
        'platform|p=s',     'submit|s',        'target|t=s',      'version|V',
        'verbose|v+',       'walltime|w=i',    'xmlfile|x=s',     'mail-list=s'
    );

    use constant WALLTIME_DEFAULT => 120;
    use constant NCORES_DEFAULT   => 8;
    use constant TAB              => '<TAB>';

}

# //////////////////////////////////////////////////////////////////////////////
# ///////////////////////////////////////////////////////////////// Utilities //
# //////////////////////////////////////////////////////////////////////////////

{

    package fremake;

    use Cwd();

    my $self = File::Basename::basename($0);

    sub Usage()

        # ------ arguments: none
    {
        my $cwd = Cwd::getcwd();
        my $xml = FREDefaults::XMLFile();
        my $tgt = FREDefaults::Target();
        my $ncs = fremake::NCORES_DEFAULT;
        my $wtm = fremake::WALLTIME_DEFAULT;
        return (
            "\n",
            "  Usage: $self -p|--platform platform [options] experiment [experiment2 ...]\n\n",
            "  Options:\n\n",
            "   -f,        --force-checkout            force checkout in case the source directory exists\n",
            "   -F,        --force-compile             force compile in case the executable directory exists\n",
            "   -K,        --keep-compiled             keep compiled files in the executable directory\n",
            "   -L,        --link                      link the executable (negatable, default is on)\n",
            "   -j NUM,    --make-jobs=NUM             number NUM of concurrent make jobs to use for compilation\n\n",
            "   -E,        --execute                   execute all the created scripts in the current session\n",
            "   -h,        --help                      print help message and exit\n",
            "   -n NUM,    --ncores=NUM                number NUM of processor cores to use (default is $ncs)\n",
            "   -p STRING, --platform=STRING           hardware and software platform STRING (required)\n",
            "   -s,        --submit                    submit all the created scripts as batch jobs\n",
            "   -t STRING, --target=STRING             use compilation directives, targeted by STRING (default is '$tgt')\n",
            "   -V,        --version                   print the tool version and exit\n",
            "   -v,        --verbose                   get verbose messages (repeat the option to increase verbosity level)\n",
            "   -w NUM,    --walltime=NUM              maximum wall time NUM (in minutes) to use (default is $wtm)\n",
            "   -x FILE,   --xmlfile=FILE              experiment suite XML configuration FILE (default is '$cwd/$xml')\n",
            "              --mail-list=STRING          email the comma-separated STRING list of emails rather than \$USER\@noaa.gov\n\n",
            "  All the option names may be abbreviated, a single leading dash is also acceptable.\n",
            "  The platform and at least one experiment from the FILE must be listed as arguments.\n\n"
        );
    } ## end sub Usage

    sub Help()

        # ------ arguments: none
    {
        my @usage = fremake::Usage();
        my $tgts  = join( "', '", FRETargets::all() );
        my $tgst  = join( "', '", FRETargets::starters() );
        return (
            "\n",
            "   Synopsis: $self creates a tcsh script to compile sources for FRE experiment(s).\n",
            "@usage",
            "   Use --force-checkout to get a fresh checkout to the source directory.\n",
            "      An existing source directory is normally reused if possible. However it might be an issue\n",
            "      if current checkout instructions do not follow changes in the experiment suite configuration file.\n",
            "      The option --force-checkout allows to get a fresh checkout according to the current configuration file.\n",
            "      The existing source directory will be saved with the timestamp if a new checkout is forced.\n",
            "   Use --force-compile to compile a fresh executable.\n",
            "      An existing executable directory is normally reused if possible. It's an error if current compile\n",
            "      instructions don't match the experiment suite configuration file UNLESS the option --force-compile is used.\n",
            "      This option allows to recreate the compile script according to the current configuration file.\n",
            "      The existing executable directory is NOT saved if a new compilation is forced.\n",
            "      Rather, we save only scripts with the timestamp and clean that directory (unless the option --keep-compiled is used).\n",
            "   Use --keep-compiled if you want to keep compiled files in the executable directory for the future use.\n",
            "      This option allows you to modify the standard behavior of the --force-compile option.\n",
            "   Use --make-jobs to set a number of concurrent make jobs (it corresponds to the GNU make option --jobs)\n",
            "      The default value of this option depends on the site you are working at.\n",
            "   Use --platform to pick a platform for experiment(s).\n",
            "      The <platform> node in the experiment suite configuration file is used\n",
            "      to set platform-specific data and instructions.\n",
            "   Use --target to define compilation and linkage directives for experiment(s).\n",
            "      Predefined targets refer to groups of directives, existing in the 'mkmf' template file.\n",
            "      Possible predefined targets are: '$tgts'.\n",
            "      Any number of targets from this list can be used here, and you can also add your own target (but not more than one).\n",
            "      Targets '$tgst' are mutually exclusive - not more than one of them is allowed in the target list.\n",
            "      Your own target should refer to a <compile> node with the corresponding value of its 'target' attribute.\n",
            "      Multiple targets are separated by comma or dash. All the directives, referred by multiple targets, are merged.\n",
            "   Use --execute to run the created script right away.\n",
            "      If the target platform is not where $self is being run, do not specify --execute.\n",
            "      Submit as a batch job or run by hand on the right platform.\n",
            "   Use --submit to automatically submit all the created scripts.\n\n"
        );
    } ## end sub Help

    sub checkoutScriptName($)

        # ------ arguments: $exp
    {
        my $z      = shift;
        my $srcDir = $z->srcDir();
        return "$srcDir/checkout.csh";
    }

    sub checkoutVerifyName($)

        # ------ arguments: $exp
    {
        my $z      = shift;
        my $srcDir = $z->srcDir();
        return "$srcDir/.xml";
    }

    sub compileScriptName($)

        # ------ arguments: $exp
    {
        my $z = shift;
        my ( $expName, $execDir ) = ( $z->name(), $z->execDir() );
        return "$execDir/compile_$expName.csh";
    }

    sub compileVerifyName($)

        # ------ arguments: $exp
    {
        my $z       = shift;
        my $execDir = $z->execDir();
        return "$execDir/.xml";
    }

    sub envScriptName($)

        # ------ arguments: $exp
    {
        my $z       = shift;
        my $execDir = $z->execDir();
        return "$execDir/env.cshrc";
    }

    sub checkExecutable($)

        # ------ arguments: $exp
        # ------ return ($flag, $status)
    {
        my $z = shift;
        my ( $fre, $execName, $execNamePredefined )
            = ( $z->fre(), $z->executable(), $z->extractExecutable() );
        if ($execNamePredefined) {
            if ( -f $execNamePredefined ) {
                if ( -x $execNamePredefined ) {
                    $fre->out( FREMsg::WARNING,
                        "The predefined executable '$execNamePredefined' already exists" );
                    return ( 0, FREDefaults::STATUS_FS_PATH_EXISTS );
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "The predefined executable '$execNamePredefined' exists, but you don't have permissions to run it"
                    );
                    return ( 0, FREDefaults::STATUS_FS_PERMISSION_PROBLEM );
                }
            }
            else {
                if ( $execNamePredefined eq $execName ) {
                    $fre->out( FREMsg::NOTE,
                        "The predefined executable '$execNamePredefined' doesn't exist - a script to build it will be created"
                    );
                    return ( 1, FREDefaults::STATUS_OK );
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "The predefined executable '$execNamePredefined' can't be built - its pathname isn't standard"
                    );
                    return ( 0, FREDefaults::STATUS_FRE_PATH_UNEXPECTED );
                }
            }
        } ## end if ($execNamePredefined)
        else {
            if ( -f $execName ) {
                if ( -x $execName ) {
                    $fre->out( FREMsg::NOTE,
                        "The executable '$execName' already exists - a script to rebuild it will be created anyway"
                    );
                    return ( 1, FREDefaults::STATUS_FS_PATH_EXISTS );
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "The executable '$execName' exists, but you don't have permissions to run it"
                    );
                    return ( 0, FREDefaults::STATUS_FS_PERMISSION_PROBLEM );
                }
            }
            else {
                $fre->out( FREMsg::NOTE,
                    "The executable '$execName' doesn't exist - a script to build it will be created"
                );
                return ( 1, FREDefaults::STATUS_OK );
            }
        } ## end else [ if ($execNamePredefined)]
    } ## end sub checkExecutable($)

    sub outNoComponents($)

        # ------ arguments: $exp
    {
        my $z = shift;
        my ( $fre, $expParent ) = ( $z->fre(), $z->parent() );
        my @msg = ("Unable to find any <component> nodes in the XML file!");
        push @msg,
            "Please consider running the fremake on the parent experiment '"
            . $expParent->name() . "'."
            if $expParent;
        $fre->out( FREMsg::FATAL, @msg );
    }

    sub processCheckoutClean($)

        # ------ arguments: $exp
    {
        my $z = shift;
        my ( $fre, $srcDir, $timeStr ) = ( $z->fre(), $z->srcDir(), FREUtil::timeString() );
        my $saveDir = $srcDir . '.' . $timeStr;
        if ( File::Copy::move( $srcDir, $saveDir ) ) {
            $fre->out(
                FREMsg::WARNING,
                "Since you've specified --force-checkout (-f), the existing source directory has been renamed using timestamp '$timeStr'",
                "A new source directory will be created and populated by sources from the SCM repository...",
                "You can remove the old source directory later by typing:",
                "rm -rf $saveDir"
            );
            return 1;
        }
        else {
            $fre->out( FREMsg::FATAL, "Unable to rename '$srcDir' to '$saveDir' ($!)" );
            return 0;
        }
    }

    sub processCheckoutScriptCreate($$)

        # ------ arguments: $exp $refToHash
    {

        my ( $z, $r ) = @_;
        my ( $expName, $srcDir ) = ( $z->name(), $z->srcDir() );

        # --------------------------------------------------------- get and sort component names

        my @names = sort { $r->{$a}{lineNumber} <=> $r->{$b}{lineNumber} } keys %{$r};

# ---------------------------------------------------------------------------- create the checkout script

        my $scoScript = '';

        $scoScript .= "#!/bin/tcsh -f\n";
        $scoScript .= "# Checkout Script for Experiment '$expName'\n";
        $scoScript
            .= "# ------------------------------------------------------------------------------\n";
        $scoScript .= "#FRE version-info\n";
        $scoScript
            .= "# ------------------------------------------------------------------------------\n\n";
        $scoScript .= "source \$MODULESHOME/init/csh\n";
        $scoScript .= "echo Using source directory = $srcDir...\n";
        $scoScript .= "cd $srcDir\n\n";
        $scoScript .= "module avail git >& .git_avail\n";
        $scoScript .= "if (! -z .git_avail) then\n";
        $scoScript .= "    module load git\n";
        $scoScript .= "endif\n\n";
        $scoScript .= "unalias *\n\n";

        foreach my $name (@names) {
            my $ref            = $r->{$name};
            my $versionControl = $ref->{vcBrand};
            my $root           = $ref->{vcRoot};
            my $version        = $ref->{codeTag};
            my $codeBase       = $ref->{codeBase};
            my $csh            = $ref->{sourceCsh};
            $scoScript .= "# ---------------- component '$name'\n";
            if ( $versionControl eq "cvs" ) {
                $scoScript .= "setenv CVSROOT $root\n";
                $scoScript .= "cvs co -r $version $codeBase\n";
                $scoScript .= "$csh\n\n";
            }
            elsif ( $versionControl eq "git" ) {
                my @repo_names = split( ' ', $codeBase );
                foreach my $repo_name (@repo_names) {
                    my $repo_path = $root . "/" . $repo_name;

       # Attempt to clone repository, capturing the output to print later if an error is encountered
                    $scoScript .= "echo \"Cloning $repo_path on branch/tag $version\"\n";
                    $scoScript
                        .= "set git_output=`git clone -q --recursive -b $version $repo_path >& /dev/stdout`\n";

          # Check if the git clone completed successfully.  If not, print the error messages, adding
          # **GIT ERROR** to each line.
                    $scoScript .= "if ( \$? != 0 ) then\n";
                    $scoScript
                        .= "     echo \"\$git_output\" | sed 's/^/**GIT ERROR** /' > /dev/stderr\n";
                    $scoScript .= "     exit 1\n";
                    $scoScript .= "endif\n";
                }
                $scoScript .= "# Additional checkout commands from XML file\n";
                $scoScript .= "$csh\n\n";
            } ## end elsif ( $versionControl eq...)
            else {
                $scoScript .= "# Unknown version control system provided: $versionControl\n";
            }
        } ## end foreach my $name (@names)

        $scoScript .= "exit 0\n";

        # --------------------------------------------- normal return

        return $scoScript;

    } ## end sub processCheckoutScriptCreate($$)

    sub processCheckoutExistingCleanDir($$%)

        # ------ arguments: $exp $refToHash %options
        # ------ return ($flag, $status)
    {
        my ( $z, $r, %o ) = @_;
        my $scoScript = fremake::processCheckoutScriptCreate( $z, $r );
        my ( $fre, $expName, $scoScriptName )
            = ( $z->fre(), $z->name(), fremake::checkoutScriptName($z) );
        if ($scoScript) {
            FRETemplate::setVersionInfo( $fre, \$scoScript, $0, $expName, %o );
            if ( open my $scoScriptHandle, '>', $scoScriptName ) {
                print {$scoScriptHandle} $scoScript;
                close $scoScriptHandle;
                chmod 0755, $scoScriptName;
                system $scoScriptName;
                if ($?) {
                    $fre->out( FREMsg::FATAL, "The checkout script '$scoScriptName' failed! ($?)" );
                    return ( 0, FREDefaults::STATUS_FRE_SOURCE_PROBLEM );
                }
                processCompileCleanExecDir( $z, 1 );
                FREXML::save( fremake::checkoutVerifyName($z), $r );
                return ( 1, FREDefaults::STATUS_OK );
            }
            else {
                $fre->out( FREMsg::FATAL, "Unable to save the script '$scoScriptName'!" );
                return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
            }
        } ## end if ($scoScript)
        else {
            $fre->out( FREMsg::FATAL, "Unable to create the script '$scoScriptName'!" );
            return ( 0, FREDefaults::STATUS_FRE_SOURCE_GENERIC_PROBLEM );
        }
    } ## end sub processCheckoutExistingCleanDir($$%)

    sub processCheckoutExistingDir($$%)

        # ------ arguments: $exp $refToHash %options
        # ------ return ($flag, $status)
    {
        my ( $z, $r, %o ) = @_;
        my ( $scoScriptName, $scoVerifyName )
            = ( fremake::checkoutScriptName($z), fremake::checkoutVerifyName($z) );
        if ( -f $scoScriptName and -r $scoScriptName and -f $scoVerifyName and -r $scoVerifyName ) {
            my $fre = $z->fre();
            if ( FREXML::verify( $scoVerifyName, $r ) ) {
                $fre->out( FREMsg::WARNING,
                    "The checkout script '$scoScriptName' already exists and matches checkout instructions in the XML file, so checkout is skipped"
                );
                return ( 1, FREDefaults::STATUS_OK );
            }
            else {
                $fre->out(
                    FREMsg::WARNING,
                    "The existing checkout script '$scoScriptName' doesn't match checkout instructions in the XML file!",
                    "If you need a fresh checkout, please rerun the fremake with the --force-checkout (-f) option.",
                    "Please consider checking your changed sources in the SCM repository before!!",
                    "Try the --help option for more information."
                );
                return ( 1, FREDefaults::STATUS_FRE_SOURCE_NO_MATCH );
            }
        }
        else {
            return fremake::processCheckoutExistingCleanDir( $z, $r, %o );
        }
    } ## end sub processCheckoutExistingDir($$%)

    sub processCheckout($%)

        # ------ arguments: $exp %options
        # ------ return ($flag, $status)
    {
        my ( $z, %o ) = @_;
        my ( $fre, $ref ) = ( $z->fre(), $z->extractCheckoutInfo() );
        if ($ref) {
            if ( scalar( keys %{$ref} ) > 0 ) {
                my $srcDir = $z->srcDir();
                if ( $fre->property('FRE.versioncontrol.enabled') ) {
                    if ( -d $srcDir ) {
                        if ( -r $srcDir ) {
                            if ( $o{'force-checkout'} ) {
                                if ( fremake::processCheckoutClean($z) ) {
                                    if ( FREUtil::createDir($srcDir) ) {
                                        return fremake::processCheckoutExistingCleanDir( $z, $ref,
                                            %o );
                                    }
                                    else {
                                        $fre->out( FREMsg::FATAL,
                                            "Unable to create the source directory '$srcDir'!" );
                                        return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                                    }
                                }
                                else {
                                    return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                                }
                            }
                            else {
                                return fremake::processCheckoutExistingDir( $z, $ref, %o );
                            }
                        } ## end if ( -r $srcDir )
                        else {
                            $fre->out( FREMsg::FATAL,
                                "The source directory '$srcDir' is not readable!" );
                            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                        }
                    } ## end if ( -d $srcDir )
                    elsif ( FREUtil::createDir($srcDir) ) {
                        return fremake::processCheckoutExistingCleanDir( $z, $ref, %o );
                    }
                    else {
                        $fre->out( FREMsg::FATAL,
                            "Unable to create the source directory '$srcDir'!" );
                        return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                    }
                } ## end if ( $fre->property('FRE.versioncontrol.enabled'...))
                else {
                    if ( -d $srcDir ) {
                        if ( -r $srcDir ) {
                            return ( 1, FREDefaults::STATUS_OK );
                        }
                        else {
                            $fre->out( FREMsg::FATAL,
                                "The source directory '$srcDir' is not readable!" );
                            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                        }
                    }
                    else {
                        $fre->out( FREMsg::FATAL, "The source directory '$srcDir' doesn't exist!" );
                        return ( 0, FREDefaults::STATUS_FRE_SOURCE_GENERIC_PROBLEM );
                    }
                }
            } ## end if ( scalar( keys %{$ref...}))
            else {
                fremake::outNoComponents($z);
                return ( 0, FREDefaults::STATUS_FRE_SOURCE_NOT_EXISTS );
            }
        } ## end if ($ref)
        else {
            $fre->out( FREMsg::FATAL,
                "Unable to extract information about sources from the XML file!" );
            return ( 0, FREDefaults::STATUS_FRE_SOURCE_GENERIC_PROBLEM );
        }
    } ## end sub processCheckout($%)

    sub processCompileCleanExecDir

        # ------ arguments: $exp $performDistClean
    {
        my ( $z, $performDistClean ) = @_;
        my ( $execDir, $fre, $cmpScriptName )
            = ( $z->execDir(), $z->fre(), fremake::compileScriptName($z) );
        my $cleanCmd = $performDistClean ? "distclean; rm -f $cmpScriptName" : "clean";
        if ( -f "$execDir/Makefile" && -r "$execDir/Makefile" ) {
            qx(cd $execDir; make $cleanCmd);
            if ( !$? ) {
                $fre->out( FREMsg::WARNING,
                    "The executable directory '$execDir' has been cleaned by the 'make $cleanCmd'"
                );
            }
            else {
                $fre->out( FREMsg::WARNING,
                    "Unable to clean the executable directory '$execDir' by the 'make $cleanCmd' ($?)"
                );
            }
        }
        else {
            my @paths = <$execDir/*>;
            if ( scalar(@paths) > 0 ) {
                my $n = File::Path::rmtree( \@paths );
                $fre->out( FREMsg::WARNING, "The executable directory '$execDir' has been cleaned" )
                    if $n > 0;
            }
        }

    } ## end sub processCompileCleanExecDir

    sub processCompileClean($%)

        # ------ arguments: $exp %options
    {
        my ( $z, %o ) = @_;
        my ( $execDir, $fre ) = ( $z->execDir(), $z->fre() );
        my @scripts = <$execDir/*.{csh,cshrc}>;
        if ( scalar(@scripts) > 0 ) {
            my $timeStr = FREUtil::timeString();
            foreach my $script (@scripts) {
                my $scriptSaved = $script . '.' . $timeStr;
                unless ( File::Copy::move( $script, $scriptSaved ) ) {
                    $fre->out( FREMsg::FATAL, "Unable to rename '$script' to '$scriptSaved' ($!)" );
                    return 0;
                }
            }
            $fre->out(
                FREMsg::WARNING,
                "Since you've specified --force-compile (-F), existing compile and environment scripts have been renamed using timestamp '$timeStr'",
                "New compile and environment scripts will be created...",
                "You can remove old scripts later by typing:",
                map( "rm -f $_.$timeStr", @scripts )
            );
            processCompileCleanExecDir($z) unless $o{'keep-compiled'};
            return 1;
        }
        else {
            return 1;
        }
    } ## end sub processCompileClean($%)

    sub processCompileScriptCreate($$%)

        # ------ arguments: $exp $refToHash %options
    {

        my ( $z, $r, %o ) = @_;
        my ( $expName, $srcDir, $execDir, $ptmpDir, $fre )
            = ( $z->name(), $z->srcDir(), $z->execDir(), $z->ptmpDir(), $z->fre() );
        my $checkoutInfo = $z->extractCheckoutInfo();
        my $baseCsh      = $fre->baseCsh();
        my $mkmfTemplate = $fre->mkmfTemplate();

        # ------------------------------------------- deduce make overrides

        my ( $target, $makeOverrides ) = ( $fre->target(), '' );
        $makeOverrides .= ' REPRO=on'  if FRETargets::containsRepro($target);
        $makeOverrides .= ' DEBUG=on'  if FRETargets::containsDebug($target);
        $makeOverrides .= ' OPENMP=on' if FRETargets::containsOpenMP($target);

        if ( FRETargets::containsHDF5($target) ) {
            $makeOverrides .= ' NETCDF=4';
        }
        else {
            $makeOverrides .= ' NETCDF=3';
        }

        # --------------------------------- create a global list of include directories

        my %includeDirs = ();

        if ( -d $srcDir ) {
            my $defaultIncludeDirs = qx(find $srcDir -type d -name include);
            foreach my $dir ( split( "\n", $defaultIncludeDirs ) ) {
                $includeDirs{$dir} = 1 if $dir;
            }
        }

        foreach my $name ( keys %{$r} ) {
            my $ref = $r->{$name};
            foreach my $dir ( split( ' ', $ref->{includeDirs} ) ) {
                $includeDirs{$dir} = 1 if $dir;
            }
        }

        #    my $includeDirsList = join(' ', map {s/^$srcDir\///; $_} sort keys %includeDirs);
        my $includeDirsList = join( ' ', map { s/^$srcDir\///; '-I' . $_ } sort keys %includeDirs );

    # ---------------------------------------------- create a list of libraries in the linking order

        my %libs = ();

        foreach my $name ( keys %{$r} ) {
            my $ref = $r->{$name};
            if ( $ref->{libPath} ) {
                $fre->out( FREMsg::NOTE, "Using library '$ref->{libPath}'..." );
                $libs{ $ref->{libPath} } = $ref->{rank};
            }
            else {
                $libs{"$name/lib$name.a"} = $ref->{rank};
            }
        }

        my $libList = join( ' ', sort { $libs{$b} <=> $libs{$a} } keys %libs );

# -------------------------------------------------- create a list of component names in the XML order

        my @names = sort { $r->{$a}{lineNumber} <=> $r->{$b}{lineNumber} } keys %{$r};

# --------------------------------------------------------------------------- create the master Makefile

        my ( $Makefile, $tab ) = ( '', fremake::TAB );
        $Makefile .= "# Makefile for Experiment '$expName'\n\n";
        $Makefile .= "SRCROOT = \$src_dir/\n";
        $Makefile .= "BUILDROOT = \$bld_dir/\n";
        $Makefile .= "STAGEDIR = \$ptmp_dir/\$bld_dir/\n\n";
        $Makefile .= "MK_TEMPLATE = \$mkmf_template\n";
        $Makefile .= "include \\\$(MK_TEMPLATE)\n\n";
        $Makefile .= "fms_$expName.x: $libList\n";
        $Makefile .= "${tab}\\\$(LD) \\\$\^ \\\$(LDFLAGS) -o \\\$\@ \\\$(STATIC_LIBS)\n"
            if $o{link};
        $Makefile .= "\n";

        foreach my $name (@names) {
            my $ref = $r->{$name};
            unless ( $ref->{libPath} ) {
                my %requiredLibs = ();
                foreach my $required ( split( ' ', $ref->{requires} ) ) {
                    my $refRequired = $r->{$required};
                    if ( $refRequired->{libPath} ) {
                        $requiredLibs{ $refRequired->{libPath} } = $refRequired->{rank};
                    }
                    else {
                        $requiredLibs{"$required/lib$required.a"} = $refRequired->{rank};
                    }
                }
                $Makefile
                    .= "$name/lib$name.a: "
                    . join( ' ',
                    sort { $requiredLibs{$b} <=> $requiredLibs{$a} } keys %requiredLibs )
                    . " FORCE\n";
                $Makefile
                    .= "${tab}\\\$(MAKE) SRCROOT=\\\$(SRCROOT) BUILDROOT=\\\$(BUILDROOT) MK_TEMPLATE=\\\$(MK_TEMPLATE) $ref->{makeOverrides} --directory=$name \\\$(\@F) \n\n";
            }
        } ## end foreach my $name (@names)

        $Makefile .= "FORCE:\n\n";

        $Makefile .= "stage:\n";
        $Makefile .= "${tab}install -d \\\$(STAGEDIR)\n";
        $Makefile .= "${tab}install -m 555 fms_$expName.x \\\$(STAGEDIR)\n\n";

        $Makefile .= "clean:\n";
        foreach my $name (@names) {
            my $ref = $r->{$name};
            $Makefile .= "${tab}\\\$(MAKE) --directory=$name clean\n";
        }
        $Makefile .= "\n";

        $Makefile .= "localize:\n";
        foreach my $name (@names) {
            my $ref = $r->{$name};
            $Makefile .= "${tab}\\\$(MAKE) -f \\\$(BUILDROOT)$name/Makefile localize\n";
        }
        $Makefile .= "\n";

        $Makefile .= "distclean:\n";
        foreach my $name (@names) {
            my $ref = $r->{$name};
            $Makefile .= "${tab}\\\$(RM) -r $name\n";
        }
        $Makefile .= "${tab}\\\$(RM) fms_$expName.x\n";
        $Makefile .= "${tab}\\\$(RM) Makefile\n";

# ---------------------------------------------------------------------------------------- get FRE parameters

        my $freCommandsHomeDir = FRE::home();
        my $jobs               = $o{'make-jobs'} || $fre->property('FRE.tool.make.jobs.default');
        my $modulesHomeDir     = $fre->property('FRE.tool.modules.home');

# ------------------------------------------------------------------- create the environment setting script

        my $envScript = '';

        $envScript .= "# Platform-Specific Environment Setting File\n";
        $envScript
            .= "# ------------------------------------------------------------------------------\n";
        $envScript .= "#FRE version-info\n";
        $envScript
            .= "# ------------------------------------------------------------------------------\n\n";

        $envScript .= "setenv MAKEFLAGS --jobs=$jobs\n\n";

        $envScript .= "source $modulesHomeDir/init/tcsh\n";
        $envScript .= "$baseCsh\n";

        $envScript .= "limit stacksize unlimited\n\n";

        $envScript .= "# Environment Settings Added by NiNaC Module\n";
        $envScript
            .= "# ------------------------------------------------------------------------------\n";
        $envScript .= FREPlatforms::getPlatformSpecificNiNaCLoadCommands() . "\n";
        $envScript
            .= "# ------------------------------------------------------------------------------\n";
        $envScript .= "# END: Settings Added by NiNaC\n\n";

        $envScript .= "module list\n";

        $envScript .= "setenv PATH $freCommandsHomeDir/bin:\$PATH\n\n";
        $envScript .= "#FRE scheduler-make-verbose\n";

# -------------------------------------------------------------------------- create the compile script

        my $cmpScript     = '';
        my $envScriptName = fremake::envScriptName($z);
        $envScriptName =~ s/$execDir/\$bld_dir/;

        $cmpScript .= "#!/bin/tcsh -fx\n";
        $cmpScript .= "#FRE scheduler-options\n\n";
        $cmpScript .= "# Compile Script for Experiment '$expName'\n";
        $cmpScript
            .= "# ------------------------------------------------------------------------------\n";
        $cmpScript .= "#FRE version-info\n";
        $cmpScript
            .= "# ------------------------------------------------------------------------------\n\n";

        $cmpScript .= "set -r echoOn = \$?echo\n\n";
        $cmpScript .= "if ( \$echoOn ) unset echo\n";
        $cmpScript .= "echo \"<NOTE> : Starting at \$HOST on `date`\"\n";
        $cmpScript .= "if ( \$echoOn ) set echo\n\n";
        $cmpScript .= "unalias *\n\n";

        $cmpScript .= "# ---------------- Set build, src and stage directories\n\n";
        $cmpScript .= "set src_dir = $srcDir\n";
        $cmpScript .= "set bld_dir = $execDir\n";
        $cmpScript .= "set ptmp_dir = $ptmpDir\n\n";

        $cmpScript .= "# ---------------- Make template\n\n";
        $cmpScript .= "set mkmf_template = $mkmfTemplate\n\n";

        $cmpScript .= "# ---------------- set environment\n\n";
        $cmpScript .= sprintf "source %s/init/tcsh\n", $fre->property('FRE.tool.modules.home');
        $cmpScript .= sprintf "module use %s\n",
            $ENV{FRE_SYSTEM_MODULEFILES_DIR} || $fre->property('FRE.tool.modules.use');
        $cmpScript .= "if ( \$echoOn ) unset echo\n";
        $cmpScript .= "source $envScriptName\n";
        $cmpScript .= "if ( \$echoOn ) set echo\n\n";

        $cmpScript .= "# ---------------- write main Makefile\n\n";
        $cmpScript .= "sed -e 's/<TAB>/\\t/' >\$bld_dir/Makefile <<END\n";
        $cmpScript .= "$Makefile\n";
        $cmpScript .= "END\n\n";

        $cmpScript .= "# ---------------- create component Makefiles\n\n";

        foreach my $name (@names) {
            my $ref = $r->{$name};
            unless ( $ref->{libPath} ) {
                my %requiredDirs = ();
                foreach my $required ( split( ' ', $ref->{requires} ) ) {
                    my $refRequired = $r->{$required};
                    if ( $refRequired->{libPath} ) {
                        $requiredDirs{ $refRequired->{libHeaderDir} } = $refRequired->{rank};
                    }
                    else {
                        $requiredDirs{"\$bld_dir/$required"} = $refRequired->{rank};
                    }
                }
                my $otherFlags = join( ' ',
                    map  { '-I' . $_ }
                    sort { $requiredDirs{$b} <=> $requiredDirs{$a} } keys %requiredDirs );
                my $pathNames = $ref->{pathNames} || "pathnames_$name";

                #       $cmpScript .= "cd \$src_dir\n";
                $cmpScript .= "mkdir -p \$bld_dir/$name\n";

                # Generate list_paths command
                $cmpScript .= "list_paths -l -o \$bld_dir/$name/$pathNames ";
                my $paths_str = '';
                foreach my $path ( split( /\s+/, $ref->{paths} ) ) {
                    if ( $path =~ /^\// ) {
                        $path =~ s/$srcDir/\$src_dir/;
                        $paths_str .= "$path ";
                    }
                    else {
                        $paths_str .= "\$src_dir/$path ";
                    }
                }
                $cmpScript .= $paths_str;
                $cmpScript .= "\n";

                # Add compile csh section
                $cmpScript .= "$ref->{compileCsh}\n" if $ref->{compileCsh};
                $cmpScript .= "cd \$bld_dir\n";
                $cmpScript .= "pushd $name\n";
                $cmpScript
                    .= "mkmf -m Makefile -a \$src_dir -b \$bld_dir -p lib$name.a -t \$mkmf_template";
                $cmpScript .= " --use-cpp" if ( $ref->{doF90Cpp} );
                $cmpScript .= " -c \"$ref->{cppDefs}\"" if $ref->{cppDefs};
                $cmpScript .= " -o \"$otherFlags\""     if $otherFlags;
                $cmpScript .= " $includeDirsList"       if $includeDirsList;
                $cmpScript .= " $ref->{srcList}"        if $ref->{srcList};
                $cmpScript .= " \$bld_dir/$name/$pathNames";
                $cmpScript .= "\npopd\n\n";
            } ## end unless ( $ref->{libPath} )
        } ## end foreach my $name (@names)

        $cmpScript .= "# ---------------- call make on the main Makefile\n\n";
        $cmpScript .= "make $makeOverrides fms_$expName.x\n\n";
        $cmpScript .= "if ( \$status == 0 ) then\n";
        $cmpScript .= "  if ( \$?NiNaC_LVL ) then\n";
        $cmpScript .= "    if ( \$NiNaC_LVL > 0 ) then\n";
        $cmpScript .= "      # Run NiNaC\n";
        $cmpScript .= "      \$NiNaC_BldRx \$src_dir \$bld_dir\n";
        $cmpScript .= "      if ( \$status != 0 ) then\n";
        $cmpScript .= "        if ( \$echoOn ) unset echo\n";
        $cmpScript
            .= "        echo \"NiNaC Note: While NiNaC loaded attempt at NiNaC_BldRx failed with exit status \$status : FRE continuing as normal.\"\n";
        $cmpScript .= "        if ( \$echoOn ) set echo\n";
        $cmpScript .= "      endif\n";
        $cmpScript .= "    endif\n";
        $cmpScript .= "  endif\n\n";
        $cmpScript .= "  if ( \$echoOn ) unset echo\n";
        $cmpScript .= "  echo \"<NOTE> : make succeeded for $expName.\"\n";
        $cmpScript .= "  if ( \$echoOn ) set echo\n";
        $cmpScript .= "else\n";
        $cmpScript .= "  if ( \$echoOn ) unset echo\n";
        $cmpScript .= "  echo \"*ERROR*: make failed for $expName.\"\n";
        $cmpScript .= "  if ( \$echoOn ) set echo\n";
        $cmpScript .= "  exit 1\n";
        $cmpScript .= "endif\n\n";
        $cmpScript .= "exit 0\n";

        # ----------------------------------------------- normal return

        return ( $cmpScript, $envScript );

    } ## end sub processCompileScriptCreate($$%)

    sub processCompileExecuteOrSubmit($$%)

        # ------ arguments: $exp $refToHash %options
        # ------ return ($flag, $status)
    {
        my ( $z, $r, %o ) = @_;
        my ( $fre, $cmpScriptName, $cmpVerifyName )
            = ( $z->fre(), fremake::compileScriptName($z), fremake::compileVerifyName($z) );

       # ------------ Run NiNaC before executing or submitting the compile if NiNaC module is loaded

        if ( exists( $ENV{'NiNaC_LVL'} ) and $ENV{'NiNaC_LVL'} > 0 ) {

            # Get the source dir signature
            system( $ENV{'NiNaC_SrcRx'}, $z->srcDir() );

            # Alert the user on NiNaC_SrcRx failure
            if ( $? != 0 ) {
                print "NiNaC Note: While NiNaC loaded attempt at NiNaC_SrcRx "
                    . FREUtil::decodeChildStatus( $?, $! )
                    . " : FRE continuing as normal.\n";
            }

            # Ensure that the xml path is an absolute path
            my $xmlpath = File::Spec->rel2abs( $o{'xmlfile'} );

            # Split the xml path into file name and directory path
            my $xmlfile = File::Basename::basename($xmlpath);
            my $xmldir  = File::Basename::dirname($xmlpath);

            # Get the xml dir signature
            system( $ENV{'NiNaC_XmlRx'}, $xmlfile, $xmldir );

            # Alert the user on NiNaC_XmlRx failure
            if ( $? != 0 ) {
                print STDERR "NiNaC Note: While NiNaC loaded attempt at NiNaC_XmlRx "
                    . FREUtil::decodeChildStatus( $?, $! )
                    . " : FRE continuing as normal.\n";
            }
        } ## end if ( exists( $ENV{'NiNaC_LVL'...}))

        # ----------- Execute or submit

        if ( $o{execute} ) {
            my $cmpScriptNameOut = $cmpScriptName . '.o' . FREUtil::jobID();
            chop( my $res
                    = `(($cmpScriptName 2>&1 3>&-; echo \$? >&3 ) | tee $cmpScriptNameOut 1>&2 3>&- ) 3>&1`
            );
            if ( $res == 0 ) {
                FREXML::save( $cmpVerifyName, $r );
                return ( 1, FREDefaults::STATUS_OK );
            }
            else {
                $fre->out( FREMsg::FATAL,
                    "The compile script '$cmpScriptName' failed! ($res)",
                    "Please see the logfile '$cmpScriptNameOut'..."
                );
                return ( 0, FREDefaults::STATUS_FRE_COMPILE_PROBLEM );
            }
        }
        elsif ( $o{submit} ) {
            FREXML::save( $cmpVerifyName, $r );
            if ( $fre->property('FRE.scheduler.enabled') ) {
                my $submitCommand
                    = $fre->property('FRE.scheduler.submit.command') . ' ' . $cmpScriptName;
                $fre->out( FREMsg::NOTE, "Executing '$submitCommand'..." );
                print qx($submitCommand);
                return ( 1, FREDefaults::STATUS_OK );
            }
            else {
                $fre->out( FREMsg::WARNING,
                    "The compile script '$cmpScriptName' can't be submitted as a batch job on this site"
                );
                print "The compile script '$cmpScriptName' is ready\n";
                return ( 1, FREDefaults::STATUS_OK );
            }
        }
        else {
            FREXML::save( $cmpVerifyName, $r );
            if ( $fre->property('FRE.scheduler.enabled') ) {
                my $submitCommand
                    = $fre->property('FRE.scheduler.submit.command') . ' ' . $cmpScriptName;
                print "TO SUBMIT => $submitCommand\n";
                return ( 1, FREDefaults::STATUS_OK );
            }
            else {
                print "The compile script '$cmpScriptName' is ready\n";
                return ( 1, FREDefaults::STATUS_OK );
            }
        }
    } ## end sub processCompileExecuteOrSubmit($$%)

    sub processCompileExistingCleanDir($$%)

        # ------ arguments: $exp $refToHash %options
        # ------ return ($flag, $status)
    {
        my ( $z, $r, %o ) = @_;
        my ( $cmpScript, $envScript ) = fremake::processCompileScriptCreate( $z, $r, %o );
        my ( $fre, $expName, $envScriptName, $cmpScriptName )
            = ( $z->fre(), $z->name(), fremake::envScriptName($z), fremake::compileScriptName($z) );
        if ($cmpScript) {

            FRETemplate::setVersionInfo( $fre, \$envScript, $0, $expName, %o );
            FRETemplate::setSchedulerMakeVerbose( $fre, \$envScript );

            FRETemplate::setSchedulerAccount( $fre, \$cmpScript );
            FRETemplate::setSchedulerResources( $fre, \$cmpScript, 'make', $o{ncores},
                $o{walltime},
                undef, undef, undef );
            FRETemplate::setSchedulerNames( $fre, \$cmpScript,
                File::Basename::basename($cmpScriptName),
                $z->execDir() );
            FRETemplate::setVersionInfo( $fre, \$cmpScript, $0, $expName, %o );
            FRETemplate::setSchedulerMakeVerbose( $fre, \$cmpScript );

            if (open my $envScriptHandle,
                '>', $envScriptName and open my $cmpScriptHandle,
                '>', $cmpScriptName
                ) {
                print {$envScriptHandle} $envScript;
                close $envScriptHandle;
                print {$cmpScriptHandle} $cmpScript;
                close $cmpScriptHandle;
                chmod 0755, $cmpScriptName;
                return fremake::processCompileExecuteOrSubmit( $z, $r, %o );
            }
            else {
                $fre->( 0, "Unable to save the script '$cmpScriptName'!" );
                return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
            }

        } ## end if ($cmpScript)
        else {
            $fre->( 0, "Unable to create the script '$cmpScriptName'!" );
            return ( 0, FREDefaults::STATUS_FRE_COMPILE_GENERIC_PROBLEM );
        }
    } ## end sub processCompileExistingCleanDir($$%)

    sub processCompileExistingDir($$%)

        # ------ arguments: $exp $refToHash %options
    {
        my ( $z, $r, %o ) = @_;
        my ( $cmpScriptName, $cmpVerifyName )
            = ( fremake::compileScriptName($z), fremake::compileVerifyName($z) );
        if ( -f $cmpScriptName and -r $cmpScriptName and -f $cmpVerifyName and -r $cmpVerifyName ) {
            my $fre = $z->fre();
            if ( FREXML::verify( $cmpVerifyName, $r ) ) {
                $fre->out( FREMsg::WARNING,
                    "The compile script '$cmpScriptName' already exists and matches compile instructions in the XML file"
                );
                return fremake::processCompileExecuteOrSubmit( $z, $r, %o );
            }
            else {
                $fre->out(
                    FREMsg::FATAL,
                    "The existing compile script '$cmpScriptName' doesn't match compile instructions in the XML file!",
                    "Please rerun the fremake with the --force-compile (-F) option.",
                    "Try the --help option for more information."
                );
                return ( 0, FREDefaults::STATUS_FRE_COMPILE_NO_MATCH );
            }
        }
        else {
            return fremake::processCompileExistingCleanDir( $z, $r, %o );
        }
    } ## end sub processCompileExistingDir($$%)

    sub processCompile($%)

        # ------ arguments: $exp %options
        # ------ return ($flag, $status)
    {
        my ( $z, %o ) = @_;
        my ( $fre, $ref ) = ( $z->fre(), $z->extractCompileInfo() );
        if ($ref) {
            if ( scalar( keys %{$ref} ) > 0 ) {
                my $execDir = $z->execDir();
                if ( -d $execDir ) {
                    if ( $o{'force-compile'} ) {
                        if ( fremake::processCompileClean( $z, %o ) ) {
                            return fremake::processCompileExistingCleanDir( $z, $ref, %o );
                        }
                        else {
                            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                        }
                    }
                    else {
                        return fremake::processCompileExistingDir( $z, $ref, %o );
                    }
                }
                elsif ( FREUtil::createDir($execDir) ) {
                    return fremake::processCompileExistingCleanDir( $z, $ref, %o );
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "Unable to create the executable directory '$execDir'!" );
                    return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                }
            } ## end if ( scalar( keys %{$ref...}))
            else {
                fremake::outNoComponents($z);
                return ( 0, FREDefaults::STATUS_FRE_COMPILE_NOT_EXISTS );
            }
        } ## end if ($ref)
        else {
            $fre->out( FREMsg::FATAL, "Unable to extract compile instructions from the XML file!" );
            return ( 0, FREDefaults::STATUS_FRE_COMPILE_GENERIC_PROBLEM );
        }
    } ## end sub processCompile($%)

    sub skipExp($)

        # ------ arguments: $exp
    {
        my $z = shift;
        my ( $expName, $fre ) = ( $z->name(), $z->fre() );
        $fre->out( FREMsg::FATAL, "Skipping the experiment '$expName'..." );
    }

}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

    my %opt = (
        'link'     => 1,
        'ncores'   => fremake::NCORES_DEFAULT,
        'walltime' => fremake::WALLTIME_DEFAULT,
        'target'   => FREDefaults::Target(),
        'xmlfile'  => FREDefaults::XMLFile()
    );

    Getopt::Long::GetOptions( \%opt, fremake::OPTLIST )
        or ( print fremake::Usage() and exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM );
    if ( $opt{version} ) { print fremake::VERSION, "\n" and exit FREDefaults::STATUS_OK; }
    if ( $opt{help} ) { print fremake::Help() and exit FREDefaults::STATUS_OK; }

    unless ( scalar(@ARGV) > 0 ) {
        my $self = File::Basename::basename($0);
        FREMsg::out(
            $opt{verbose}, 0,
            "At least one experiment name is needed on the command line",
            "Try '$self --help' for more information"
        );
        exit FREDefaults::STATUS_COMMAND_NO_EXPERIMENTS;
    }

    if ( exists( $opt{ncores} ) ) {
        unless ( $opt{ncores} > 0 ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL,
                "The --ncores option value must be a positive number" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( exists( $opt{walltime} ) ) {
        unless ( $opt{walltime} > 0 ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL,
                "The --walltime option value must be a positive number" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( $opt{platform} ) {
        unless ( $opt{platform} && substr( $opt{platform}, 0, 1 ) ne '-' ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL, "The --platform option's value is missing" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( exists( $opt{target} ) ) {
        unless ( $opt{target} && substr( $opt{target}, 0, 1 ) ne '-' ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL, "The --target option's value is missing" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( exists( $opt{xmlfile} ) ) {
        unless ( $opt{xmlfile} && substr( $opt{xmlfile}, 0, 1 ) ne '-' ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL, "The --xmlfile option's value is missing" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ($opt{'mail-list'}) {
        for (split ',', $opt{'mail-list'}) {
            unless (Email::Valid->address($_)) {
                FREMsg::out( $opt{verbose}, FREMsg::FATAL, "The email address '$_' specified in --mail-list isn't valid" );
                exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
            }
        }
        FREMsg::out( $opt{verbose}, FREMsg::NOTE, "The email list '$opt{'mail-list'}' will be used FRE notifications instead of the default '\$USER\@noaa.gov'" );
    }

    my $fre = FRE->new( 'fremake', %opt ) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;

    # check for FRE version mismatch between XML and current shell
    $fre->check_for_fre_version_mismatch;

    unless ( $fre->property('FRE.tool.fremake.enabled') ) {
        my $platformSite = $fre->platformSite();
        $fre->out( FREMsg::FATAL,
            "You are not supposed to call this tool on the '$platformSite' site" );
        exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    }

    unless ( $fre->property('FRE.versioncontrol.enabled') ) {
        if ( $opt{'force-checkout'} ) {
            $fre->out( FREMsg::WARNING,
                "The --force-checkout option isn't supported on this site" );
        }
    }

    my @exps = ();
    foreach my $expName ( FREUtil::listUnique(@ARGV) ) {
        my $exp = FREExperiment->new( $fre, $expName )
            or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
        push @exps, $exp;
    }

    my $status = 0;

    foreach my $exp (@exps) {

        # ------------------------------------ set the experiment name

        $fre->setCurrentExperimentName( $exp->name() );

        # ---------------------------------------- check executable, checkout, compile

        ( my $rc, $status ) = fremake::checkExecutable($exp);
        if ($rc) {
            ( my $rc, $status ) = fremake::processCheckout( $exp, %opt );
            if ($rc) {
                ( my $rc, $status ) = fremake::processCompile( $exp, %opt );
                if ($rc) {

                  # -------------------------------------------------- all is OK, no messages needed
                }
                else {
                    fremake::skipExp($exp) if scalar(@exps) > 1;
                }
            }
            else {
                fremake::skipExp($exp) if scalar(@exps) > 1;
            }
        }
        else {
            fremake::skipExp($exp) if scalar(@exps) > 1;
        }

        # ------------------------------------ unset the experiment name

        $fre->unsetCurrentExperimentName();

    } ## end foreach my $exp (@exps)

    exit $status;

}
