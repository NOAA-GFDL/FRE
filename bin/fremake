#!/usr/bin/perl
# -*- cperl -*-
#
# $Id: fremake,v 18.0.2.16 2011/02/09 22:46:03 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to Create a Script to Compile a Model
# ------------------------------------------------------------------------------
# arl    Ver  18.00  Merged revision 17.0.4.12 onto trunk           March 10
# afy -------------- Branch 18.0.2 -------------------------------- March 10
# afy    Ver   1.00  Modify Help subroutine (list targets)          April 10
# afy    Ver   1.01  Modify Usage subroutine (reorder, attributes)  April 10
# afy    Ver   1.02  Add single-letter option names                 April 10
# afy    Ver   1.03  Add option --validate                          April 10
# afy    Ver   1.04  Check for experiment names separately          April 10
# afy    Ver   2.00  Improve building in the current session        April 10
# afy    Ver   2.01  Use new FREUtil.pm module (jobID)              April 10
# afy    Ver   3.00  Add (modified) processCheckoutScriptCreate     May 10
# afy    Ver   3.01  Modify processCheckoutExistingCleanDir         May 10
# afy    Ver   3.02  Add (modified) processCompileScriptCreate      May 10
# afy    Ver   3.03  Modify processCompileExistingCleanDir          May 10
# afy    Ver   4.00  Use/Set FRE_COMMANDS_HOME directory            May 10
# afy    Ver   5.00  Fix processCheckoutScriptCreate (vcRoot)       May 10
# afy    Ver   6.00  Modify processCompileScriptCreate (new FRE.pm) May 10
# afy    Ver   7.00  Use new FREDefaults.pm to return status        June 10
# afy    Ver   7.01  Use new FREXML.pm (based on the XML::Dumper)   June 10
# afy    Ver   7.02  Add check for the executable existence/perms   June 10
# afy    Ver   8.00  Reconfigure Getopt::Long (no 'auto_abbrev')    September 10
# afy    Ver   8.01  Add single-letter aliases to all the options   September 10
# afy    Ver   8.02  Modify option --validate (no aliases)          September 10
# afy    Ver   8.03  Modify option --version (low case)             September 10
# afy    Ver   8.04  Use new module FRETemplate                     September 10
# afy    Ver   8.05  Modify processCompileExecuteOrSubmit ($submit) September 10
# afy    Ver   9.00  Use new module FRETemplate (setScheduler*)     September 10
# afy    Ver  10.00  Rename option --npes => --ncores               September 10
# afy    Ver  10.01  Modify processCompileScriptCreate (ncores)     September 10
# afy    Ver  10.02  Modify processCompileScriptCreate (tabs!)      September 10
# afy    Ver  10.03  Modify processCompileScriptCreate (cosmetics)  September 10
# afy    Ver  10.04  Modify Usage subroutine (corrections)          September 10
# afy    Ver  11.00  Add option --partition                         September 10
# afy    Ver  12.00  Modify processCompileScriptCreate (modules)    December 10
# afy    Ver  13.00  Modify processCompileScriptCreate (fix)        December 10
# afy    Ver  14.00  Use new module FREMsg (symbolic levels)        January 11
# afy    Ver  14.01  Modify processCheckoutScriptCreate (hashes)    January 11
# afy    Ver  14.02  Modify processCompileScriptCreate (hashes)     January 11
# afy    Ver  14.03  Modify processCompileScriptCreate (overrides)  January 11
# afy    Ver  14.04  Modify processCompileScriptCreate (libList)    January 11
# afy    Ver  15.00  Modify processCompileExecuteOrSubmit (checks)  January 11
# afy    Ver  16.00  Use new FRETemplate module (*Resources)        February 11
# afy    Ver  16.01  Remove option --partition                      February 11
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2011
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use File::Basename();
use File::Copy();
use Getopt::Long(':config', 'no_ignore_case', 'no_auto_abbrev');

use FRE();
use FREDefaults();
use FREExperiment();
use FREMsg();
use FRETargets();
use FRETemplate();
use FREUtil();
use FREXML();

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////// Global constants //
# //////////////////////////////////////////////////////////////////////////////

{

  package fremake;

  use constant VERSION => '$Id: fremake,v 18.0.2.16 2011/02/09 22:46:03 afy Exp $';

  use constant OPTLIST =>
  (
    'force-compile|F',
    'force-checkout|f',
    'execute|E',
    'help|h',
    'ncores|n=i',
    'platform|p=s',
    'submit|s',
    'target|t=s',
    'validate',
    'version|V',
    'verbose|v+',
    'walltime|w=i',
    'xmlfile|x=s'
  );
  
  use constant WALLTIME_DEFAULT => 120;
  use constant NCORES_DEFAULT => 8;
  use constant TAB => '<TAB>';

}

# //////////////////////////////////////////////////////////////////////////////
# ///////////////////////////////////////////////////////////////// Utilities //
# //////////////////////////////////////////////////////////////////////////////

{

  package fremake;
  
  use Cwd();
  
  my $self = File::Basename::basename($0);

  sub Usage()
  # ------ arguments: none
  {
    my $cwd = Cwd::getcwd();
    my $xml = FREDefaults::XMLFile();
    my $pfm = FREDefaults::Platform();
    my $tgt = FREDefaults::Target();
    my $ncs = fremake::NCORES_DEFAULT;
    my $wtm = fremake::WALLTIME_DEFAULT;
    my $beg = "\e[0;4m";
    my $end = "\e[m";
    return
    (
      "\n",
      "  Usage: $self [option|experiment] ...\n\n",
      "  Options:\n\n",
      "   -F,          --force-compile      ${beg}f${end}orce compile in case the executable directory exists\n", 
      "   -f,          --force-checkout     ${beg}f${end}orce checkout in case the source directory exists\n\n", 
      "   -E,          --execute            ${beg}e${end}xecute all the created scripts in the current session\n", 
      "   -h,          --help               print ${beg}h${end}elp message and exit\n",
      "   -n NUM,      --ncores=NUM         ${beg}n${end}umber of processor cores to use (default is $ncs)\n",
      "   -p STRING,   --platform=STRING    hardware and software ${beg}p${end}latform STRING (default is '$pfm')\n", 
      "   -s,          --submit             ${beg}s${end}ubmit all the created scripts as batch jobs\n",
      "   -t STRING,   --target=STRING      use compilation directives, ${beg}t${end}argeted by STRING (default is '$tgt')\n", 
      "                --validate           validate the FILE against its XML schema before processing\n",
      "   -V,          --version            print the tool ${beg}v${end}ersion and exit\n",
      "   -v,          --verbose            get ${beg}v${end}erbose messages (repeat the option to increase verbosity level)\n", 
      "   -w NUM,      --walltime=NUM       maximum ${beg}w${end}all time (in minutes) to use (default is $wtm)\n", 
      "   -x FILE,     --xmlfile=FILE       experiment suite ${beg}X${end}ML configuration FILE (default is '$cwd/$xml')\n\n", 
      "  All the option names may be abbreviated, a single leading dash is also acceptable.\n",
      "  At least one experiment from the FILE must be listed as an argument.\n\n"
    );
  }
  
  sub Help()
  # ------ arguments: none
  {
    my @usage = fremake::Usage();
    my $tgts = join("', '", FRETargets::all());
    my $tgst = join("', '", FRETargets::starters());
    return
    (
      "\n",
      "   Synopsis: $self creates a tcsh script to compile sources for FRE experiment(s).\n",
      "@usage",
      "   Use --force-checkout to get a fresh checkout to the source directory.\n",
      "      An existing source directory is normally reused if possible. However it might be an issue\n",
      "      if current checkout instructions do not follow changes in the experiment suite configuration file.\n", 
      "      The option --force-checkout allows to get a fresh checkout according to the current configuration file.\n", 
      "      The existing source directory will be saved with the timestamp if a new checkout is forced.\n",
      "   Use --force-compile to compile a fresh executable.\n", 
      "      An existing executable directory is normally reused if possible. It's an error if current compile\n",
      "      instructions don't match the experiment suite configuration file UNLESS the option --force-compile is used.\n",
      "      This option allows to recreate the compile script according to the current configuration file.\n",   
      "      The existing executable directory is NOT saved if a new compilation is forced.\n",
      "      Rather, we save only scripts with the timestamp and do 'make clean' in that directory.\n",
      "   Use --platform to pick a platform for experiment(s).\n", 
      "      The <platform> node in the experiment suite configuration file is used\n", 
      "      to set platform-specific data and instructions.\n",
      "   Use --target to define compilation and linkage directives for experiment(s).\n",
      "      Predefined targets refer to groups of directives, existing in the 'mkmf' template file.\n",
      "      Possible predefined targets are: '$tgts'.\n",
      "      Any number of targets from this list can be used here, and you can also add your own target (but not more than one).\n",
      "      Targets '$tgst' are mutually exclusive - not more than one of them is allowed in the target list.\n",
      "      Your own target should refer to a <compile> node with the corresponding value of its 'target' attribute.\n", 
      "      Multiple targets are separated by comma or dash. All the directives, referred by multiple targets, are merged.\n", 
      "   Use --execute to run the created script right away.\n",
      "      If the target platform is not where $self is being run, do not specify --execute.\n", 
      "      Submit as a batch job or run by hand on the right platform.\n",
      "   Use --submit to automatically submit all the created scripts.\n\n"
    );
  }

  sub checkoutScriptName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my $srcDir = $z->srcDir();
    return "$srcDir/checkout.csh";
  }
  
  sub checkoutVerifyName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my $srcDir = $z->srcDir();
    return "$srcDir/.xml";
  }
  
  sub compileScriptName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my ($expName, $execDir) = ($z->name(), $z->execDir());
    return "$execDir/compile_$expName.csh";
  }
  
  sub compileVerifyName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my $execDir = $z->execDir();
    return "$execDir/.xml";
  }
  
  sub envScriptName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my $execDir = $z->execDir();
    return "$execDir/env.cshrc";
  }
  
  sub execName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my ($expName, $execDir) = ($z->name(), $z->execDir());
    return "$execDir/fms_$expName.x";
  }
  
  sub checkExecutable($)
  # ------ arguments: $exp
  # ------ return ($flag, $status)
  {
    my $z = shift;
    my ($execName, $fre) = (fremake::execName($z), $z->fre());
    my ($execNamePredefined, $expObject) = $z->extractExecutable();
    if ($execNamePredefined)
    {
      if (-f $execNamePredefined)
      {
        if (-x $execNamePredefined)
        {
	  $fre->out(FREMsg::WARNING, "The predefined executable '$execNamePredefined' already exists");
	  return (0, FREDefaults::STATUS_FS_PATH_EXISTS);
        }
        else
        {
	  $fre->out(FREMsg::FATAL, "The predefined executable '$execNamePredefined' exists, but you don't have permissions to run it");
	  return (0, FREDefaults::STATUS_FS_PERMISSION_PROBLEM);
        }
      }
      else
      {
	if ($execNamePredefined eq $execName)
	{
          $fre->out(FREMsg::NOTE, "The predefined executable '$execNamePredefined' doesn't exist - a script to build it will be created");
          return (1, FREDefaults::STATUS_OK);
	}
	else
	{
          $fre->out(FREMsg::FATAL, "The predefined executable '$execNamePredefined' can't be built - its pathname isn't standard");
          return (0, FREDefaults::STATUS_FRE_PATH_UNEXPECTED);
	}
      }
    }
    else
    {
      if (-f $execName)
      {
        if (-x $execName)
	{
	  $fre->out(FREMsg::NOTE, "The executable '$execName' already exists - a script to rebuild it will be created anyway");
	  return (1, FREDefaults::STATUS_FS_PATH_EXISTS);
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The executable '$execName' exists, but you don't have permissions to run it");
	  return (0, FREDefaults::STATUS_FS_PERMISSION_PROBLEM);
	}
      }
      else
      {
        $fre->out(FREMsg::NOTE, "The executable '$execName' doesn't exist - a script to build it will be created");
        return (1, FREDefaults::STATUS_OK);
      }
    }
  }

  sub outNoComponents($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my ($fre, $expParent) = ($z->fre(), $z->parent());
    my @msg = ("Unable to find any <component> nodes in the XML file!");
    push @msg, "Please consider running the fremake on the parent experiment '" . $expParent->name() . "'." if $expParent;
    $fre->out(FREMsg::FATAL, @msg);
  }

  sub processCheckoutClean($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my ($tmpDir, $fre) = ($z->tmpDir(), $z->fre());
    if (FREUtil::createDir($tmpDir))
    {
      my $srcDir = $z->srcDir();
      my $timeStr = FREUtil::timeString();
      my $saveDir = "$tmpDir/src.$timeStr";
      if (File::Copy::move($srcDir, $saveDir))
      {
	$fre->out
	(
	  FREMsg::WARNING,
	  "Current source directory is '$srcDir'...",
	  "Since you've specified --force-checkout, I've moved its content into the directory '$saveDir'.", 
	  "A new source directory will be created and populated by sources from the CVS...",
	  "You can remove the saved directory later by typing:", 
	  "rm -rf $saveDir"
	);
	return 1;
      }
      else
      {
	$fre->out(FREMsg::FATAL, "Unable to move '$srcDir' to '$saveDir'! ($!)");
	return 0;
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to create the directory '$tmpDir'!");
      return 0;
    }
  }
  
  sub processCheckoutScriptCreate($$)
  # ------ arguments: $exp $refToHash
  {

    my ($z, $r) = @_;
    my ($expName, $srcDir, $fre) = ($z->name(), $z->srcDir(), $z->fre());

    $fre->out(FREMsg::NOTE, "Using source directory '$srcDir'...");

    # --------------------------------------------------------- get and sort component names

    my @names = sort {$r->{$a}{lineNumber} <=> $r->{$b}{lineNumber}} keys %{$r};

    # ---------------------------------------------------------------------------- create the checkout script

    my $scoScript = '';

    $scoScript .= "#!/bin/tcsh -f\n";
    $scoScript .= "# Checkout Script for Experiment '$expName'\n";
    $scoScript .= "# ------------------------------------------------------------------------------\n";
    $scoScript .= "#FRE version-info\n";
    $scoScript .= "# ------------------------------------------------------------------------------\n\n";
    $scoScript .= "unalias *\n\n";
    $scoScript .= "echo Using source directory = $srcDir...\n";
    $scoScript .= "cd $srcDir\n\n";

    foreach my $name (@names)
    {
      my $ref = $r->{$name};
      $scoScript .= "# ---------------- component '$name'\n";
      $scoScript .= "setenv CVSROOT $ref->{vcRoot}\n";
      $scoScript .= "cvs co -r $ref->{codeTag} $ref->{codeBase}\n";
      $scoScript .= "$ref->{sourceCsh}\n\n";
    }

    $scoScript .= "exit 0\n";

    # --------------------------------------------- normal return

    return $scoScript;

  }

  sub processCheckoutExistingCleanDir($$%)
  # ------ arguments: $exp $refToHash %options
  # ------ return ($flag, $status)
  {
    my ($z, $r, %o) = @_;
    my $scoScript = fremake::processCheckoutScriptCreate($z, $r);
    my ($fre, $scoScriptName) = ($z->fre(), fremake::checkoutScriptName($z)); 
    if ($scoScript)
    {
      FRETemplate::setVersionInfo(\$scoScript, $z, $0, %o);
      if (open my $scoScriptHandle, '>', $scoScriptName)
      {
	print {$scoScriptHandle} $scoScript;
	close $scoScriptHandle;
	chmod 0755, $scoScriptName;
	print qx($scoScriptName);
	if (!$?)
	{
          FREXML::save(fremake::checkoutVerifyName($z), $r);
	  return (1, FREDefaults::STATUS_OK);
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The checkout script '$scoScriptName' failed! ($?)");
	  return (0, FREDefaults::STATUS_FRE_SOURCE_PROBLEM);
	}
      }
      else
      {
	$fre->out(FREMsg::FATAL, "Unable to save the script '$scoScriptName'!");
	return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to create the script '$scoScriptName'!");
      return (0, FREDefaults::STATUS_FRE_SOURCE_GENERIC_PROBLEM);
    }
  }
  
  sub processCheckoutExistingDir($$%)
  # ------ arguments: $exp $refToHash %options
  # ------ return ($flag, $status)
  {
    my ($z, $r, %o) = @_;
    my ($scoScriptName, $scoVerifyName) = (fremake::checkoutScriptName($z), fremake::checkoutVerifyName($z));
    if (-f $scoScriptName and -r $scoScriptName and -f $scoVerifyName and -r $scoVerifyName)
    {
      my $fre = $z->fre();
      if (FREXML::verify($scoVerifyName, $r))
      {
	$fre->out(FREMsg::WARNING, "The checkout script '$scoScriptName' already exists and matches checkout instructions in the XML file, so checkout is skipped");
	return (1, FREDefaults::STATUS_OK);
      }
      else
      {
        $fre->out
	(
	  1,
	  "The existing checkout script '$scoScriptName' doesn't match checkout instructions in the XML file!",
          "If you need a fresh checkout, please rerun the fremake with the --force-checkout (-f) option.",
	  "Please consider checking your changed sources in the CVS before that!", 
          "Try the --help option for more information."
	);
	return (1, FREDefaults::STATUS_FRE_SOURCE_NO_MATCH);
      }
    }
    else
    {
      return fremake::processCheckoutExistingCleanDir($z, $r, %o);
    }
  }
  
  sub processCheckout($%)
  # ------ arguments: $exp %options
  # ------ return ($flag, $status)
  {
    my ($z, %o) = @_;
    my ($fre, $ref) = ($z->fre(), $z->extractCheckoutInfo());
    if ($ref)
    {
      if (scalar(keys %{$ref}) > 0)
      {
	my $srcDir = $z->srcDir();
	if (-d $srcDir)
	{
          if ($o{'force-checkout'})
	  {
	    if (fremake::processCheckoutClean($z))
	    {
	      if (FREUtil::createDir($srcDir))
	      {
		return fremake::processCheckoutExistingCleanDir($z, $ref, %o);
	      }
	      else
	      {
		$fre->out(FREMsg::FATAL, "Unable to create the source directory '$srcDir'!");
		return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	      }
	    }
	    else
	    {
	      return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	    }
	  }
	  else
	  {
	    return fremake::processCheckoutExistingDir($z, $ref, %o); 
	  }
	}
	elsif (FREUtil::createDir($srcDir))
	{
          return fremake::processCheckoutExistingCleanDir($z, $ref, %o);
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to create the source directory '$srcDir'!");
	  return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	}
      }
      else
      {
        fremake::outNoComponents($z);
	return (0, FREDefaults::STATUS_FRE_SOURCE_NOT_EXISTS);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to extract checkout instructions from the XML file!");
      return (0, FREDefaults::STATUS_FRE_SOURCE_GENERIC_PROBLEM);
    }
  }

  sub processCompileClean($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my ($execDir, $fre) = ($z->execDir(), $z->fre());
    my @scripts = <$execDir/*.{csh,cshrc}>;
    if (scalar(@scripts) > 0)
    {
      my $tmpDir = $z->tmpDir();
      if (FREUtil::createDir($tmpDir))
      {
	my $timeStr = FREUtil::timeString();
	foreach my $script (@scripts)
	{
	  my $scriptSaved = $tmpDir . '/' . File::Basename::basename($script) . '.' . $timeStr;
	  my $res = File::Copy::move($script, $scriptSaved);
	  unless ($res)
	  {
	    $fre->out(FREMsg::FATAL, "Unable to move '$script' to '$scriptSaved'! ($!)");
	    return 0;
	  }
        }
	$fre->out
	(
	  1,
	  "Current executable directory is '$execDir'...",
	  "Since you've specified --force-compile, I've moved the existing compile script into the directory '$tmpDir'.",
	  "The executable directory will be cleaned by 'make clean', and then the compile script will be recreated..."
	);
	if (-f "$execDir/Makefile")
	{
	  chdir $execDir;
	  qx(make clean);
	}
	return 1;
      }
      else
      {
	$fre->out(FREMsg::FATAL, "Unable to create the directory '$tmpDir'!");
	return 0;
      }
    }
    else
    {
      return 1;
    }
  }

  sub processCompileScriptCreate($$)
  # ------ arguments: $exp $refToHash
  {

    my ($z, $r) = @_;
    my ($expName, $srcDir, $execDir, $fre) = ($z->name(), $z->srcDir(), $z->execDir(), $z->fre());

    $fre->out(FREMsg::NOTE, "Using executable directory '$execDir'...");

    my $baseCsh	= $fre->baseCsh();
    my $mkmfTemplate = $fre->mkmfTemplate();

    # ------------------------------------------- deduce make overrides

    my ($target, $makeOverrides) = ($fre->target(), '');
    $makeOverrides .= ' REPRO=on'  if FRETargets::containsRepro($target);
    $makeOverrides .= ' DEBUG=on'  if FRETargets::containsDebug($target);
    $makeOverrides .= ' OPENMP=on' if FRETargets::containsOpenMP($target);

    if (FRETargets::containsHDF5($target))
    {
      $makeOverrides .= ' NETCDF=4';
    }
    else
    {
      $makeOverrides .= ' NETCDF=3';
    }

    # --------------------------------------- create a list of include directories

    my %includeDirList;
    if (-d $srcDir)
    {
      my $defaultIncludeDirs = qx(find $srcDir -type d -name include);
      foreach my $dir (split("\n", $defaultIncludeDirs))
      {
	$includeDirList{$dir} = 1 if $dir;
      }
    }

    foreach my $name (keys %{$r})
    {
      my $ref = $r->{$name};
      foreach my $dir (split(' ', $ref->{includeDirs}))
      {
	$includeDirList{$dir} = 1 if $dir;
      }
    }
    
    my $includeList = join(' ', map {s/^$srcDir\///; $_} keys %includeDirList);

    # ------------------------------------------- create a list of library header directories

    my %libHeaderDirList;
    foreach my $name (keys %{$r})
    {
      my $ref = $r->{$name};
      my $dir = $ref->{libHeaderDir};
      $libHeaderDirList{$dir} = 1 if $dir;
    }

    my $libHeaderList = join(' ', map {'-I' . $_} keys %libHeaderDirList);

    # ---------------------------------------------- create a list of libraries in the linking order

    my @libList = ();
    foreach my $name (sort {$r->{$b}{rank} <=> $r->{$a}{rank}} keys %{$r})
    {
      my $ref = $r->{$name};
      if (exists($ref->{libPath}) and $ref->{libPath})
      {
	$fre->out(FREMsg::NOTE, "Using library '$ref->{libPath}'");
	push @libList, $ref->{libPath};
      }
      else
      {
        push @libList, "lib$name.a";
      }
    }

    # -------------------------------------------------- create a list of component names in the XML order

    my @names = sort {$r->{$a}{lineNumber} <=> $r->{$b}{lineNumber}} keys %{$r};

    # --------------------------------------------------------------------------- create the master Makefile

    my ($Makefile, $tab) = ('', fremake::TAB);
    $Makefile .= "# Makefile for Experiment '$expName'\n";
    $Makefile .= "include $mkmfTemplate\n\n";
    $Makefile .= "fms_$expName.x: " . join(' ', @libList) . "\n";
    $Makefile .= "${tab}\\\$(LD) \\\$\^ \\\$(LDFLAGS) -o \\\$\@ \n\n";

    foreach my $name (@names)
    {
      my $ref = $r->{$name};
      unless (exists($ref->{libPath}) and $ref->{libPath})
      {
	my @prerequisites = ();
	foreach my $required (split(' ', $ref->{requires}))
	{
	  my $refRequired = $r->{$required};
	  if (exists($refRequired->{libPath}) and $refRequired->{libPath})
	  {
            push @prerequisites, $refRequired->{libPath};
	  }
	  else
	  {
            push @prerequisites, "lib$required.a";
	  }
	}
	$Makefile .= "lib$name.a: " . join(' ', @prerequisites) . " FORCE\n";
	$Makefile .= "${tab}make $makeOverrides $ref->{makeOverrides} -f Makefile.$name \\\$\@\n\n";
      }
    }

    $Makefile .= "FORCE:\n\n";

    $Makefile .= "clean:\n";
    foreach my $name (@names)
    {
      my $ref = $r->{$name};
      $Makefile .= "${tab}make $makeOverrides $ref->{makeOverrides} -f Makefile.$name clean\n";
    }
    $Makefile .= "\n";

    $Makefile .= "localize:\n";
    foreach my $name (@names)
    {
      my $ref = $r->{$name};
      $Makefile .= "${tab}make $makeOverrides $ref->{makeOverrides} -f Makefile.$name localize\n";
    }

    # ---------------------------------------------------------------------------------------- get FRE parameters

    my $freCommandsHomeDir = FRE::home();
    my $jobs = $fre->property('FRE.tool.make.jobs.default');
    my $moduleInitDir = $fre->property('FRE.tool.module.initDir') || '$MODULESHOME/init';

    # ------------------------------------------------------------------- create the environment setting script

    my $envScript = '';

    $envScript .= "# Platform-Specific Environment Setting File\n";
    $envScript .= "# ------------------------------------------------------------------------------\n";
    $envScript .= "#FRE version-info\n";
    $envScript .= "# ------------------------------------------------------------------------------\n\n";

    $envScript .= "setenv MAKEFLAGS jobs=$jobs\n\n";

    $envScript .= "unset echo\n";
    $envScript .= "source $moduleInitDir/tcsh\n";
    $envScript .= "$baseCsh\n";
    $envScript .= "module list\n";
    $envScript .= "set echo\n\n";

    $envScript .= "setenv PATH $freCommandsHomeDir/bin:\$PATH\n\n";
    $envScript .= "#FRE scheduler-make-verbose\n";

    # -------------------------------------------------------------------------- create the compile script

    my $cmpScript = '';
    my $envScriptName = fremake::envScriptName($z);

    $cmpScript .= "#!/bin/tcsh -f\n";
    $cmpScript .= "#FRE scheduler-options\n\n";
    $cmpScript .= "# Compile Script for Experiment '$expName'\n";
    $cmpScript .= "# ------------------------------------------------------------------------------\n";
    $cmpScript .= "#FRE version-info\n";
    $cmpScript .= "# ------------------------------------------------------------------------------\n\n";
    
    $cmpScript .= "echo Starting on `date`\n";
    $cmpScript .= "echo \$HOST \$HOSTNAME\n";
    $cmpScript .= "set echo\n";
    $cmpScript .= "unalias *\n\n";

    $cmpScript .= "# ---------------- set environment\n\n";
    $cmpScript .= "source $envScriptName\n\n";

    $cmpScript .= "# ---------------- write main Makefile\n\n";
    $cmpScript .= "cat >$execDir/Makefile <<END\n";
    $cmpScript .= "$Makefile\n";
    $cmpScript .= "END\n\n";

    $cmpScript .= "# ---------------- create component Makefiles\n\n";

    foreach my $name (@names)
    {
      my $ref = $r->{$name};
      unless (exists($ref->{libPath}) and $ref->{libPath})
      {
	my $pathNames = $ref->{pathNames} || "pathnames_$name";
	$cmpScript .= "cd $srcDir\n";
	$cmpScript .= "list_paths -o $pathNames $ref->{paths}\n";
	$cmpScript .= "$ref->{compileCsh}\n" if $ref->{compileCsh};
	$cmpScript .= "cd $execDir\n";
	$cmpScript .= "mkmf -m Makefile.$name -a $srcDir -p lib$name.a -t $ref->{mkmfTemplate}";
	$cmpScript .= " -c \"$ref->{cppDefs}\"" if $ref->{cppDefs};
	$cmpScript .= " -o \"$libHeaderList\"" if $libHeaderList;
	$cmpScript .= " $ref->{srcList}" if $ref->{srcList};
	$cmpScript .= " $pathNames"; 
	$cmpScript .= " $includeList" if $includeList;
	$cmpScript .= "\n\n";
      }
    }

    $cmpScript .= "# ---------------- adjust the main Makefile\n\n";
    $cmpScript .= "cat Makefile | sed -e 's/${tab}/\\t/' > Makefile.\$\$ && mv -f Makefile.\$\$ Makefile\n\n";
    $cmpScript .= "# ---------------- call make on the main Makefile\n\n";
    $cmpScript .= "make $makeOverrides fms_$expName.x\n\n";
    $cmpScript .= "if ( \$status ) then\n";
    $cmpScript .= "  unset echo\n";
    $cmpScript .= "  echo ERROR: make failed for $expName.\n";
    $cmpScript .= "  exit 1\n";
    $cmpScript .= "else\n";
    $cmpScript .= "  unset echo\n";
    $cmpScript .= "  echo NOTE: make succeeded for $expName.\n";
    $cmpScript .= "endif\n";

    # ----------------------------------------------- normal return

    return ($cmpScript, $envScript);

  }

  sub processCompileExecuteOrSubmit($$%)
  # ------ arguments: $exp $refToHash %options
  # ------ return ($flag, $status)
  {
    my ($z, $r, %o) = @_;
    my ($fre, $cmpScriptName, $cmpVerifyName) = ($z->fre(), fremake::compileScriptName($z), fremake::compileVerifyName($z));
    if ($o{execute})
    {
      my $cmpScriptNameOut = $cmpScriptName . '.o' . FREUtil::jobID();
      my $res = system("$cmpScriptName 2>&1 | tee $cmpScriptNameOut");
      if ($res == 0)
      {
	FREXML::save($cmpVerifyName, $r);
	return (1, FREDefaults::STATUS_OK);
      }
      else
      {
        $fre->out(FREMsg::FATAL, "The compile script '$cmpScriptName' failed! ($res)");
	$fre->out(FREMsg::FATAL, "Please see the logfile '$cmpScriptNameOut'...");
	return (0, FREDefaults::STATUS_FRE_COMPILE_PROBLEM);
      }
    }
    elsif ($o{submit}) 
    {
      FREXML::save($cmpVerifyName, $r);
      if ($fre->property('FRE.scheduler.enabled'))
      {
        my $submit = $fre->property('FRE.scheduler.submit.command');
        $fre->out(FREMsg::NOTE, "Executing '$submit $cmpScriptName'...");
        print qx($submit $cmpScriptName);
        return (1, FREDefaults::STATUS_OK);
      }
      else
      {
        $fre->out(FREMsg::WARNING, "The compile script '$cmpScriptName' can't be submitted as a batch job on this site");
        $fre->out(FREMsg::NOTE, "The compile script '$cmpScriptName' is ready");
        return (1, FREDefaults::STATUS_OK);
      }
    }
    else
    {
      FREXML::save($cmpVerifyName, $r);
      if ($fre->property('FRE.scheduler.enabled'))
      {
        my $submit = $fre->property('FRE.scheduler.submit.command');
        print "TO SUBMIT => $submit $cmpScriptName\n";
        return (1, FREDefaults::STATUS_OK);
      }
      else
      {
        $fre->out(FREMsg::NOTE, "The compile script '$cmpScriptName' is ready");
        return (1, FREDefaults::STATUS_OK);
      }
    }
  }

  sub processCompileExistingCleanDir($$%)
  # ------ arguments: $exp $refToHash %options
  # ------ return ($flag, $status)
  {
    my ($z, $r, %o) = @_;
    my ($cmpScript, $envScript) = fremake::processCompileScriptCreate($z, $r);
    my ($fre, $envScriptName, $cmpScriptName) = ($z->fre(), fremake::envScriptName($z), fremake::compileScriptName($z));
    if ($cmpScript)
    {

      FRETemplate::setVersionInfo(\$envScript, $z, $0, %o);
      FRETemplate::setSchedulerMakeVerbose(\$envScript, $z);

      FRETemplate::setSchedulerResources(\$cmpScript, $z, 'make', $o{ncores}, $o{walltime} * 60, '', '');
      FRETemplate::setSchedulerNames(\$cmpScript, $z, File::Basename::basename($cmpScriptName), $z->execDir());
      FRETemplate::setVersionInfo(\$cmpScript, $z, $0, %o);
      FRETemplate::setSchedulerMakeVerbose(\$cmpScript, $z);

      if (open my $envScriptHandle, '>', $envScriptName and open my $cmpScriptHandle, '>', $cmpScriptName)
      {
	print {$envScriptHandle} $envScript;
	close $envScriptHandle;
	print {$cmpScriptHandle} $cmpScript;
	close $cmpScriptHandle; 
	chmod 0755, $cmpScriptName;
	return fremake::processCompileExecuteOrSubmit($z, $r, %o);
      }
      else
      {
        $fre->(0, "Unable to save the script '$cmpScriptName'!");
        return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
      }

    }
    else
    {
      $fre->(0, "Unable to create the script '$cmpScriptName'!");
      return (0, FREDefaults::STATUS_FRE_COMPILE_GENERIC_PROBLEM);
    }
  }
  
  sub processCompileExistingDir($$%)
  # ------ arguments: $exp $refToHash %options
  {
    my ($z, $r, %o) = @_;
    my ($cmpScriptName, $cmpVerifyName) = (fremake::compileScriptName($z), fremake::compileVerifyName($z));
    if (-f $cmpScriptName and -r $cmpScriptName and -f $cmpVerifyName and -r $cmpVerifyName)
    {
      my $fre = $z->fre();
      if (FREXML::verify($cmpVerifyName, $r))
      {
	$fre->out(FREMsg::WARNING, "The compile script '$cmpScriptName' already exists and matches compile instructions in the XML file");
	return fremake::processCompileExecuteOrSubmit($z, $r, %o);
      }
      else
      {
	$fre->out
	(
	  0,
	  "The existing compile script '$cmpScriptName' doesn't match compile instructions in the XML file!",
          "Please rerun the fremake with the --force-compile (-F) option.", 
          "Try the --help option for more information."
	); 
	return (0, FREDefaults::STATUS_FRE_COMPILE_NO_MATCH);
      }
    }
    else
    {
      return fremake::processCompileExistingCleanDir($z, $r, %o);
    }
  }
  
  sub processCompile($%)
  # ------ arguments: $exp %options
  # ------ return ($flag, $status)
  {
    my ($z, %o) = @_;
    my ($fre, $ref) = ($z->fre(), $z->extractCompileInfo());
    if ($ref)
    {
      if (scalar(keys %{$ref}) > 0)
      {
	my $execDir = $z->execDir();
	if (-d $execDir)
	{
          if ($o{'force-compile'})
	  {
	    if (fremake::processCompileClean($z))
	    {
	      return fremake::processCompileExistingCleanDir($z, $ref, %o);
	    }
	    else
	    {
	      return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	    }
	  }
	  else
	  {
	    return fremake::processCompileExistingDir($z, $ref, %o);
	  }
	}
	elsif (FREUtil::createDir($execDir))
	{
          return fremake::processCompileExistingCleanDir($z, $ref, %o);
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to create the executable directory '$execDir'!");
	  return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	}
      }
      else
      {
	fremake::outNoComponents($z);
	return (0, FREDefaults::STATUS_FRE_COMPILE_NOT_EXISTS);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to extract compile instructions from the XML file!");
      return (0, FREDefaults::STATUS_FRE_COMPILE_GENERIC_PROBLEM);
    }
  }
  
  sub skipExp($)
  # ------ arguments: $exp 
  {
    my $z = shift;
    my ($expName, $fre) = ($z->name(), $z->fre());
    $fre->out(FREMsg::FATAL, "Skipping the experiment '$expName'...");
  }
  
}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

  my %opt =
  (
    'ncores'	=> fremake::NCORES_DEFAULT,
    'walltime'	=> fremake::WALLTIME_DEFAULT,
    'platform'	=> FREDefaults::Platform(),
    'target'	=> FREDefaults::Target(),
    'xmlfile'	=> FREDefaults::XMLFile()
  );

  Getopt::Long::GetOptions(\%opt, fremake::OPTLIST) or (print fremake::Usage() and exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM);
  if ($opt{version}) {print fremake::VERSION,"\n" and exit FREDefaults::STATUS_OK;}
  if ($opt{help}) {print fremake::Help() and exit FREDefaults::STATUS_OK;}

  if (scalar(@ARGV) == 0)
  {
    my $self = File::Basename::basename($0);
    FREMsg::out($opt{verbose}, 0, "At least one experiment name is needed on the command line", "Try '$self --help' for more information");
    exit FREDefaults::STATUS_COMMAND_NO_EXPERIMENTS;
  }

  my $fre = FRE->new('fremake', %opt) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;

  my @exps = ();
  foreach my $expName (@ARGV)
  {
    my $exp = FREExperiment->new($fre, $expName) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    push @exps, $exp;
  }

  my $status = 0;
  
  foreach my $exp (@exps)
  {

    # ------------------------------------ set the experiment name

    $fre->setCurrentExperimentName($exp->name());

    # ---------------------------------------- check executable, checkout, compile

    (my $rc, $status) = fremake::checkExecutable($exp);
    if ($rc)
    {
      (my $rc, $status) = fremake::processCheckout($exp, %opt);
      if ($rc)
      {
        (my $rc, $status) = fremake::processCompile($exp, %opt);
	if ($rc)
	{
	  # -------------------------------------------------- all is OK, no messages needed
	}
	else
	{
          fremake::skipExp($exp) if scalar(@exps) > 1;
	}
      }
      else
      {
        fremake::skipExp($exp) if scalar(@exps) > 1;
      }
    }
    else
    {
      fremake::skipExp($exp) if scalar(@exps) > 1;
    }

    # ------------------------------------ unset the experiment name

    $fre->unsetCurrentExperimentName();

  }
  
  exit $status;

}
