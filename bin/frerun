#!/usr/bin/perl
# -*- cperl -*-
#
# $Id: frerun,v 18.0.2.29 2010/12/27 01:02:01 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to Create a Script to Run a Model
# ------------------------------------------------------------------------------
# arl    Ver  18.00  Merged revision 17.0.4.21 onto trunk           March 10
# afy -------------- Branch 18.0.2 -------------------------------- March 10
# afy    Ver   1.00  Modify Help subroutine (list targets)          March 10
# afy    Ver   1.01  Add --archive option                           March 10
# afy    Ver   1.02  Modify init (set flagArchive)                  March 10
# afy    Ver   1.03  Modify init (no staged combining for reg.)     March 10
# afy    Ver   2.00  Modify Help subroutine again (list targets)    April 10
# afy    Ver   2.01  Modify Usage subroutine (reorder, attributes)  April 10
# afy    Ver   2.02  Add shorter option names                       April 10
# afy    Ver   2.03  Add option --validate                          April 10
# afy    Ver   2.04  Check for experiment names separately          April 10
# afy    Ver   2.05  Modify init (don't set FREROOT)                April 10
# afy    Ver   2.06  Modify init (set flagOutputType)               April 10
# afy    Ver   2.07  Modify init (set flagOutputPostProcess)        April 10
# afy    Ver   2.08  Modify setProductionOutputDirectory (no frepp) April 10
# afy    Ver   2.09  Modify outputRegressionScript (no frepp)       April 10
# afy    Ver   2.10  Modify init (offline + unique => online)       April 10
# afy    Ver   2.11  Add option --execute                           April 10
# afy    Ver   3.00  Remove option --build                          May 10
# afy    Ver   3.01  Add (modified) execName subroutine             May 10
# afy    Ver   3.02  Modify init (don't set siteDir/flagRemake)     May 10
# afy    Ver   3.03  Modify init (set freCommandsHomeDir)           May 10
# afy    Ver   3.04  Add baseDate subroutine                        May 10
# afy    Ver   3.05  Modify setTables subroutine (use setBaseDate)  May 10
# afy    Ver   4.00  Modify init (use new FRE.pm)                   May 10
# afy    Ver   5.00  Add --target option alias 't'                  June 10
# afy    Ver   6.00  Use new FREDefaults.pm to return status        June 10
# afy    Ver   6.01  Force if/elsif/else tree design                June 10
# afy    Ver   6.02  Modify setProductionParameters subroutine      June 10
# afy    Ver   6.03  Modify outputScriptExecuteOrSubmit subroutine  June 10
# afy    Ver   6.04  Add pathname-returning subroutines             June 10
# afy    Ver   6.05  Standardize skipExp subroutine                 June 10
# afy    Ver   6.06  Modify init (default getFmsData)               June 10
# afy    Ver   6.07  Add calendarType subroutine                    June 10
# afy    Ver   6.08  Modify setNamelists (set timeStampFormat)      June 10
# afy    Ver   7.00  Add option --submit-staged	                    June 10
# afy    Ver   7.01  Add option --npes (for staging only)           June 10
# afy    Ver   7.02  Add option --walltime (for staging only)       June 10
# afy    Ver   7.03  Modify init (change ptmpDir/hsmDir settings)   June 10
# afy    Ver   7.04  Modify outputScriptExecuteOrSubmit (staging)   June 10
# afy    Ver   8.00  Modify outputScriptInputDir (use properties)   June 10
# afy    Ver   8.01  Modify outputScriptJobId (use properties)      June 10
# afy    Ver   9.00  Modify setMPI (use new FREDefaults.pm)         July 10
# afy    Ver  10.00  Weaken errors processing for suites            July 10
# afy    Ver  11.00  Add processRegressionRun subroutine            August 10
# afy    Ver  11.01  Add processRegression subroutine               August 10
# afy    Ver  11.02  Add processRegressionSuite subroutine          August 10
# afy    Ver  11.03  Add processProduction subroutine               August 10
# afy    Ver  11.04  Restructure the main loop using added subs     August 10
# afy    Ver  11.05  Add option --dual                              August 10
# afy    Ver  12.00  Modify init (more history combining types)     August 10
# afy    Ver  13.00  Modify init (history combining type checkup)   August 10
# afy    Ver  13.01  Cosmetics in messages                          August 10
# afy    Ver  13.02  Modify option --dual (alias 'du' => 'D')       August 10
# afy    Ver  13.03  Modify option --execute (alias 'e' => 'E')     August 10
# afy    Ver  13.04  Modify option --extend (alias 'ext' => 'e')    August 10
# afy    Ver  13.05  Modify option --overwrite (add alias 'o')      August 10
# afy    Ver  13.06  Modify option --unique (add alias 'u')         August 10
# afy    Ver  13.07  Modify option --namelist (add alias 'N')       August 10
# afy    Ver  13.08  Modify option --npes (add alias 'n')           August 10
# afy    Ver  14.00  Reconfigure Getopt::Long (no 'auto_abbrev')    August 10
# afy    Ver  14.01  Merge two options --transfer-* into one        August 10
# afy    Ver  14.02  Modify option --submit (allow 'staged' value)  August 10
# afy    Ver  14.03  Remove option --submit-staged                  August 10
# afy    Ver  14.04  Add single-letter aliases to all the options   August 10
# afy    Ver  14.05  Add option --check                             August 10
# afy    Ver  14.06  Use new module FRETemplate (new set* subs)     August 10
# afy    Ver  14.07  Modify setMPI (pass the ./$executable:t)       August 10
# afy    Ver  15.00  Correction for the --dual option               August 10
# afy    Ver  16.00  Modify option --transfer (negatable)           August 10
# afy    Ver  16.01  Revive option --submit-staged                  August 10
# afy    Ver  16.02  Modify option --submit (don't allow values)    August 10
# afy    Ver  16.03  Modify option --validate (no aliases)          August 10
# afy    Ver  16.04  Modify option --version (low case)             August 10
# afy    Ver  16.05  Default option --dual from a property          August 10
# afy    Ver  16.06  Default option --transfer from a property      August 10
# afy    Ver  17.00  Modify outputScriptExecuteOrSubmit (no qsub)   September 10
# afy    Ver  17.01  Use new module FRETemplate                     September 10
# afy    Ver  18.00  Use new module FRETemplate (setScheduler*)     September 10
# afy    Ver  18.01  Modify set*Parameters (no stdoutDir)           September 10
# afy    Ver  18.02  Modify outputScriptJobId (property name)       September 10
# afy    Ver  18.03  Modify outputScripExecuteOrSubmit (stdoutDir)  September 10
# afy    Ver  18.04  Remove output*Script subroutines               September 10
# afy    Ver  18.05  Modify processRegressionRun (set all names)    September 10
# afy    Ver  18.06  Modify processProduction (set all names)       September 10
# afy    Ver  19.00  Rename option --npes => --ncores               September 10
# afy    Ver  19.01  Modify outputScriptExecuteOrSubmit (ncores)    September 10
# afy    Ver  20.00  Modify outputScriptExecuteOrSubmit (staging)   September 10
# afy    Ver  21.00  Modify outputScriptJobId (add parameter)       September 10
# afy    Ver  21.01  Modify outputScriptJobId (generic pattern)     September 10
# afy    Ver  22.00  Add option --partition                         September 10
# afy    Ver  23.00  Simplify staged submitting (no FRE_INPUT_DIR)  October 10
# afy    Ver  23.01  Add option --submit-chained                    October 10
# afy    Ver  23.02  Modify init (add partitions/queues setup)      October 10
# afy    Ver  23.00  Modify outputScriptExecuteOrSubmit (names)     October 10
# afy    Ver  24.00  Add option --output-staging                    October 10
# afy    Ver  24.01  Assign 'platform' settable constant            October 10
# afy    Ver  25.00  Assign 'target' settable constant              October 10
# afy    Ver  26.00  Rethink the option --output-staging            November 10
# afy    Ver  26.01  Rename flag*CombineType => flag*StagingType    November 10
# afy    Ver  26.02  Rename flag*Combine => flag*CombineHistory     November 10
# afy    Ver  27.00  Properties for --ncores/walltime defaults      November 10
# afy    Ver  28.00  Use new FREMsg module (symbolic level names)   December 10
# afy    Ver  28.01  Add productionParametersExist subroutine       December 10
# afy    Ver  28.02  Modify init (fileSender/outputStager times)    December 10
# afy    Ver  28.03  Modify init (mail mode)                        December 10
# afy    Ver  29.00  Modify init (add moduleInitDir setting)        December 10
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2010
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use Cwd();
use File::Basename();
use File::Spec();
use Getopt::Long(':config', 'no_ignore_case', 'no_auto_abbrev');
use POSIX();

use FRE();
use FREDefaults();
use FREExperiment();
use FREMsg();
use FRETargets();
use FRETemplate();
use FREUtil();

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////// Global constants //
# //////////////////////////////////////////////////////////////////////////////

{

  package frerun;

  use constant VERSION => '$Id: frerun,v 18.0.2.29 2010/12/27 01:02:01 afy Exp $';

  use constant OPTLIST =>
  (
    'archive|a!',
    'check|c',
    'combine-history|C!',
    'debug|g=s',
    'dual|D!',
    'extend|e',
    'logging|L!',
    'namelist|N',
    'output-staging|O=s',
    'overwrite|o',
    'regression|r=s',
    'submit-chained|S',
    'submit-staged',
    'transfer|T!',
    'unique|u',
    'execute|E',
    'help|h',
    'ncores|n=i',
    'partition|P=s',
    'platform|p=s',
    'submit|s',
    'target|t=s',
    'validate',
    'version|V',
    'verbose|v+',
    'walltime|w=i',
    'xmlfile|x=s'
  );
  
  use constant PRAGMA_PREFIX => '#FRE';
  use constant PRAGMA_SETUP_PLATFORM_CSH => 'setup-platform-csh';
  use constant PRAGMA_EXPERIMENT_RUNTIME_CSH => 'experiment-runtime-csh';
  use constant PRAGMA_EXPERIMENT_INPUT_CSH_INIT => 'experiment-input-csh-init';
  use constant PRAGMA_EXPERIMENT_INPUT_CSH_ALWAYS_OR_POSTINIT => 'experiment-input-csh-always-or-postinit';
  use constant PRAGMA_EXPERIMENT_POSTPROCESS_CSH => 'experiment-postprocess-csh';

  use constant RUNSCRIPT_TEMPLATE_MAIN => 'runscript.template.main';

  use constant REGRESSION_SUITE => ('basic', 'restarts', 'scaling');
  
  use constant OUTPUT_STAGING_TYPES => ('online', 'offline', 'staged', 'bySegment');
  
  use constant NCORES_DEFAULT => 2;
  use constant WALLTIME_DEFAULT => 30;
  
}

# //////////////////////////////////////////////////////////////////////////////
# ///////////////////////////////////////////////////////////////// Utilities //
# //////////////////////////////////////////////////////////////////////////////

{

  package frerun;

  my $self = File::Basename::basename($0);

  sub Usage()
  # ------ arguments: none
  {
    my $cwd = Cwd::getcwd();
    my $xml = FREDefaults::XMLFile();
    my $pfm = FREDefaults::Platform();
    my $tgt = FREDefaults::Target();
    my $beg = "\e[0;4m";
    my $end = "\e[m";
    return
    (
      "\n",
      "  Usage: $self [option|experiment] ...\n\n",
      "  Options:\n\n",
      "   -a,          --archive               save the model output in the ${beg}a${end}rchive (negatable, default is on)\n",
      "   -c,          --check                 ${beg}c${end}heck the model output with the main model run (which makes sense for unique runs only)\n",
      "   -C,          --combine-history       ${beg}c${end}ombine history files after each segment run (negatable, default is on)\n",
      "   -g STRING,   --debug=STRING          run in debu${beg}g${end} mode STRING (possible values are 'totalview' and 'setup')\n",
      "   -D,          --dual                  create a pair of runscripts - the main one and the ${beg}d${end}ual one (negatable, default depends on site)\n",
      "   -e,          --extend                ${beg}e${end}xtend default run of existing experiment\n",
      "   -L,          --logging               enable batch system ${beg}l${end}ogging (negatable, default is on)\n",
      "   -N,          --namelist              print all the ${beg}n${end}amelists with all substitutions and overrides\n",
      "   -O,          --output-staging=STRING type of ${beg}o${end}utput data staging ('online', 'offline', 'staged' or 'bySegment')\n",     
      "   -o,          --overwrite             ${beg}o${end}verwrite default run of existing experiment\n", 
      "   -r STRING,   --regression=STRING     run in ${beg}r${end}egression test mode STRING with minimal output processing\n",
      "   -S,          --submit-chained        ${beg}s${end}ubmit all the created scripts as input data staging jobs, submitting run jobs at their end\n",
      "                --submit-staged         ${beg}s${end}ubmit all the created scripts as batch jobs with input data staging\n",
      "   -T,          --transfer              ${beg}t${end}ransfer all the remotedly created model output back to GFDL (negatable, default depends on site)\n",
      "   -u,          --unique                create a new ${beg}u${end}nique run of existing experiment\n\n", 
      "   -E,          --execute               ${beg}e${end}xecute all the created scripts in the current session\n", 
      "   -h,          --help                  print ${beg}h${end}elp message and exit\n",
      "   -n NUM,      --ncores=NUM            ${beg}n${end}umber of processor cores to use for input data staging (default depends on site)\n",
      "   -P STRING,   --partition=STRING      ${beg}p${end}artition to use for model runs\n",
      "   -p STRING,   --platform=STRING       hardware and software ${beg}p${end}latform STRING (default is '$pfm')\n", 
      "   -s,          --submit                ${beg}s${end}ubmit all the created scripts as batch jobs\n",
      "   -t STRING,   --target=STRING         use compilation directives, ${beg}t${end}argeted by STRING (default is '$tgt')\n", 
      "                --validate              validate the FILE against its XML schema before processing\n",
      "   -V,          --version               print the tool ${beg}v${end}ersion and exit\n",
      "   -v,          --verbose               get ${beg}v${end}erbose messages (repeat the option to increase verbosity level)\n", 
      "   -w NUM,      --walltime=NUM          maximum ${beg}w${end}all time (in minutes) to use for input data staging (default depends on site)\n", 
      "   -x FILE,     --xmlfile=FILE          experiment suite ${beg}X${end}ML configuration FILE (default is '$cwd/$xml')\n\n", 
      "  At least one experiment from the FILE must be listed as an argument.\n\n"
    );
  }
  
  sub Help()
  # ------ arguments: none
  {
    my @usage = frerun::Usage();
    my $tgts = join("', '", FRETargets::all());
    my $tgst = join("', '", FRETargets::starters());
    return
    (
      "\n",
      "   Synopsis: $self creates a tcsh script to run FRE experiment(s).\n",
      "@usage",
      "   Use --noarchive to disallow saving model output into archive (valid for regression tests only).\n",
      "      The (unpacked) model output will be kept in the disk cache (ptmp) only.\n",
      "   Use --nocombine-history to disallow combining history files (valid for regression tests only).\n",
      "      This option is on by default, so history files will be combined after each segment run.\n",
      "      (The type of history combining is defined by an attribute 'combine' in the <postProcess> node)\n",
      "   Use --overwrite, --extend or --unique to manipulate the experiment output directory.\n",
      "      You can completely overwrite the output directory, you can extend the run of the same experiment,\n",
      "      or you can create another unique instance of the output directory for the same experiment.\n",
      "   Use --dual to automatically create a pair of runscripts - the main one and the dual one.\n",
      "      The dual runscript is functionally identical to runscripts with --unique and --check options enabled,\n",
      "      it will keep the model output in a separate directory and compare it with the data from the main model run.\n",
      "      The --dual option is recognized for production runs only.\n",    
      "   Use --regression to run a regression test instead of the <production> run.\n", 
      "      Regression tests have minimal treatment of output files.\n",
      "   Use --submit-chained to automatically submit all the created scripts in the chaining mode.\n",
      "      The script is submitted with parameters, which allow it to perform input data staging,\n",
      "      to submit the normal run script (provided that the input data staging was successful), and then exit.\n",
      "      This makes sense, when the input data staging script and the normal run script have to be executed\n",
      "      in different computing environments (different access to filesystems, etc).\n",
      "   Use --submit-staged to automatically submit all the created scripts in the input data staging mode.\n",
      "      The same script is submitted twice with different parameters, so it works as the input data stager at first,\n",
      "      then it works normally with input data, prepared by the stager.\n",  
      "   Use --platform to pick a platform for experiment(s).\n", 
      "      The <platform> node in the experiment suite configuration file is used\n", 
      "      to set platform-specific data and instructions.\n",
      "   Use --target to define compilation and linkage directives for experiment(s).\n",
      "      Predefined targets refer to groups of directives, existing in the 'mkmf' template file.\n",
      "      Possible predefined targets are: '$tgts'.\n",
      "      Any number of targets from this list can be used here, and you can also add your own target (but not more than one).\n",
      "      Targets '$tgst' are mutually exclusive - not more than one of them is allowed in the target list.\n",
      "      Your own target should refer to a <compile> node with the corresponding value of its 'target' attribute.\n", 
      "      Multiple targets are separated by comma or dash. All the directives, referred by multiple targets, are merged.\n", 
      "   Use --execute to run the created script right away.\n",
      "      If the target platform is not where $self is being run, do not specify --execute.\n", 
      "      Submit as a batch job or run by hand on the right platform.\n",
      "   Use --submit to automatically submit all the created scripts as batch jobs.\n\n"
    );
  }

  sub regressionRunScriptName($$)
  # ------ arguments: $exp $extension
  {
    my ($z, $x) = @_;
    my ($expName, $scriptsDir) = ($z->name(), $z->scriptsDir());
    return "$scriptsDir/run/${expName}_$x"; 
  }

  sub productionRunScriptName($$)
  # ------ arguments: $exp $extension
  {
    my ($z, $x) = @_;
    my ($expName, $scriptsDir) = ($z->name(), $z->scriptsDir());
    return "$scriptsDir/run/$expName$x"; 
  }

  sub stdoutName($$)
  # ------ arguments: $exp $scriptName
  {
    my ($z, $n) = @_;
    my ($basename, $stdoutDir, $jobId) = (File::Basename::basename($n), $z->stdoutDir(), FREUtil::jobID());
    return "$stdoutDir/run/$basename.o$jobId";
  }

  sub createDirectory($$$)
  # ------ arguments: $fre $directory $verbose
  # ------ create a directory 
  {
    my ($fre, $d, $v) = @_;
    if (-d $d)
    {
      if (-w $d)
      {
        return 1;
      }
      else
      {
        $fre->out(FREMsg::FATAL, "The directory '$d' exists, but it's not writable");
	return 0;
      }
    }
    elsif ($d =~ m/^\/work/)
    {
      unless (FREUtil::execute('ac-work', "mkdir -p $d"))
      {
        $fre->out(FREMsg::NOTE, "createDir: $d");
	return 1;
      }
      else
      {
        $fre->out(FREMsg::FATAL, "The directory '$d' can't be created");
	return 0;
      }
    }
    elsif ($d =~ m/^\/archive/)
    {
      unless (FREUtil::execute('ac-arch', "mkdir -p $d"))
      {
        $fre->out(FREMsg::NOTE, "createDir: $d");
	return 1;
      }
      else
      {
        $fre->out(FREMsg::FATAL, "The directory '$d' can't be created");
	return 0;
      }
    }
    else
    {
      return FREUtil::createDir($d, $v);
    }
  }

  sub getTemplate($$)
  # ------ arguments: $fre $filename
  # ------ returns a script template from the site directory
  # ------ return ($sript, $status)
  {
    my ($fre, $n) = @_;
    my $pathname = $fre->siteDir() . '/' . $n;
    if (open my $templateHandle, '<', $pathname)
    {
      $/ = undef;
      my $s = <$templateHandle>;
      $s =~ s/^# ?$//mg;
      $s =~ s/^# .*$//mg;
      $s =~ s/\n{2,}/\n\n/sg;
      close $templateHandle;
      return ($s, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(FREMsg::FATAL, "The main runscript template '$pathname' isn't found");
      return (0, FREDefaults::STATUS_FRE_RUN_NO_TEMPLATE);
    }
  }

  sub execName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my ($value, $exp) = $z->extractExecutable();
    if ($value)
    {
      return $value;
    }
    else
    {
      my ($execDir, $name) = ($exp->execDir(), $exp->name());
      return "$execDir/fms_$name.x";
    }
  }

  sub init($%)
  # ------ arguments: $exp %options
  # ------ return ($sript, $status)
  {

    my ($z, %o) = @_;
    my $fre = $z->fre();
    
    my ($s, $status) = frerun::getTemplate($fre, frerun::RUNSCRIPT_TEMPLATE_MAIN);
    if ($s)
    {

      # ------------------------------------- executable

      my $execName = frerun::execName($z);
      if (-f $execName and -x $execName)
      {
	$fre->out(FREMsg::NOTE, "Using executable '$execName'...");
      }
      else
      {
	$fre->out(FREMsg::WARNING, "Your executable '$execName' doesn't exist or has wrong permissions");
      }

      # ---------------------------------------------------------------------- output data staging

      my $flagOutputStagingType = $o{'output-staging'} || $z->extractValue('postProcess/@combine');

      if ($flagOutputStagingType)
      {
	if (scalar(grep($_ eq $flagOutputStagingType, frerun::OUTPUT_STAGING_TYPES)) > 0)
	{
	  if ($fre->property("FRE.output.staging.$flagOutputStagingType"))
	  {
	    if ($flagOutputStagingType eq 'offline')
	    {
	      if (!$o{archive})
	      {
		$flagOutputStagingType = 'online';
		$fre->out(FREMsg::WARNING, "The 'offline' output staging can't be used with the --noarchive option - using the 'online' one...");
	      }
              elsif ($o{regression})
	      {
		$flagOutputStagingType = 'online';
		$fre->out(FREMsg::WARNING, "The 'offline' output staging can't be used for regression tests - using the 'online' one...");
	      }
	      elsif ($o{unique})
	      {
		$flagOutputStagingType = 'online';
		$fre->out(FREMsg::WARNING, "The 'offline' output staging can't be used for unique runs - using the 'online' one...");
	      }
	      else
	      {
                $fre->out(FREMsg::NOTE, "The 'offline' output staging will be used...");
	      }
	    }
	    elsif ($flagOutputStagingType eq 'staged')
	    {
	      if (!$o{archive})
	      {
		$flagOutputStagingType = 'online';
		$fre->out(FREMsg::WARNING, "The 'staged' output staging can't be used with the --noarchive option - using the 'online' one...");
	      }
	      else
	      {
                $fre->out(FREMsg::NOTE, "The 'staged' output staging will be used...");
	      }
	    }
	    elsif ($flagOutputStagingType eq 'bySegment')
	    {
	      if (!$o{archive})
	      {
		$flagOutputStagingType = 'online';
		$fre->out(FREMsg::WARNING, "The 'bySegment' output staging can't be used with the --noarchive option - using the 'online' one...");
	      }
	      else
	      {
                $fre->out(FREMsg::NOTE, "The 'bySegment' output staging will be used...");
	      }
	    }
	    else
	    {
              $fre->out(FREMsg::NOTE, "The '$flagOutputStagingType' output staging will be used...");
	    }
	  }
	  else
	  {
	    $flagOutputStagingType = 'online';
	    $fre->out(FREMsg::WARNING, "The '$flagOutputStagingType' output staging isn't supported at this site - using the 'online' one...");
	  }
	}
	else
	{
	  $flagOutputStagingType = 'online';
	  $fre->out(FREMsg::WARNING, "The '$flagOutputStagingType' output staging type isn't supported - using the 'online' one...");
	}
      }
      else
      {
        $flagOutputStagingType = 'online';
        $fre->out(FREMsg::WARNING, "The output staging isn't defined - using the 'online' one...");
      }
      
      # --------------------------------------------------------------------------------------- history combining

      my $flagOutputCombineHistory = ($o{'combine-history'}) ? 'On' : 'Off';
      if ($flagOutputCombineHistory eq 'Off')
      {
        if ($o{regression})
	{
          $fre->out(FREMsg::NOTE, "The history won't be combined...");
	}
	else
        {
	  $flagOutputCombineHistory = 'On';
	  $fre->out(FREMsg::WARNING, "You can use the --nocombine-history option for regression tests only - ignored...");
	}
      }

      # -------------------------------------------------------------------------------- output archiving

      my $flagOutputArchive = ($o{archive}) ? 'On' : 'Off';
      if ($flagOutputArchive eq 'Off')
      {
	if ($o{regression})
	{
          $fre->out(FREMsg::NOTE, "The model output will be kept in the disk cache only...");
	}
	else
	{
          $flagOutputArchive = 'On';
          $fre->out(FREMsg::WARNING, "You can use the --noarchive option for regression tests only - ignored...");
	}
      }
      
      # -------------------------------------------------------------- getFmsData and its parameters

      my @getFmsData = ($fre->getFmsData() || '$freCommandsHomeDir/bin/get_fms_data');
      my $fmsRelease = $fre->fmsRelease();
      push @getFmsData, ('-r', $fmsRelease) if $fmsRelease;

      # ----------------------------------------------------------- setting constants/variables 

      FRETemplate::setFlag(\$s, 'flagRunType', ($o{regression}) ? 'Regression' : 'Production');
      FRETemplate::setFlag(\$s, 'flagLogging', ($o{logging}) ? 'On' : 'Off');
      FRETemplate::setFlag(\$s, 'flagOutputType', ($o{extend}) ? 'Extend' : (($o{overwrite}) ? 'Overwrite' : (($o{unique}) ? 'Unique' : 'Initial')));
      FRETemplate::setFlag(\$s, 'flagOutputFormat', (FRETargets::containsHDF5($fre->target())) ? 'HDF5' : '64Bit');
      FRETemplate::setFlag(\$s, 'flagOutputStagingType', ucfirst $flagOutputStagingType);
      FRETemplate::setFlag(\$s, 'flagOutputCombineHistory', $flagOutputCombineHistory);
      FRETemplate::setFlag(\$s, 'flagOutputArchive', $flagOutputArchive);
      FRETemplate::setFlag(\$s, 'flagOutputPostProcess', (!$o{regression} && !$o{unique}) ? "On" : "Off");
      FRETemplate::setFlag(\$s, 'flagOutputTransfer', ($o{transfer}) ? 'On' : 'Off');
      FRETemplate::setFlag(\$s, 'flagOutputCheck', ($o{check}) ? 'On' : 'Off');

      FRETemplate::setVariable(\$s, 'platform', $o{platform});
      FRETemplate::setVariable(\$s, 'target', $o{target});
      FRETemplate::setVariable(\$s, 'name', $z->name());
      FRETemplate::setVariable(\$s, 'rtsxml', $fre->configFileAbsPathName());
      FRETemplate::setVariable(\$s, 'moduleInitDir', $fre->property('FRE.tool.module.initDir') || '$MODULESHOME/init');
      FRETemplate::setVariable(\$s, 'freCommandsHomeDir', FRE::home());
      FRETemplate::setVariable(\$s, 'workDir', $z->workDir());
      FRETemplate::setVariable(\$s, 'ptmpDir', $z->ptmpDir());
      FRETemplate::setVariable(\$s, 'archiveDir', $z->archiveDir());
      FRETemplate::setVariable(\$s, 'executable', $execName);
      FRETemplate::setVariable(\$s, 'mailMode', $fre->mailMode());
      
      FRETemplate::setVariable(\$s, 'fileSenderPartition', $fre->property('FRE.scheduler.partition.transfer'));
      FRETemplate::setVariable(\$s, 'fileSenderQueue', $fre->property('FRE.scheduler.queue.transfer'));
      FRETemplate::setVariable(\$s, 'fileSenderTimeAscii', $fre->property('FRE.scheduler.runtime.fileSender.ascii') || $fre->property('FRE.scheduler.runtime.max'));
      FRETemplate::setVariable(\$s, 'fileSenderTimeRestarts', $fre->property('FRE.scheduler.runtime.fileSender.restarts') || $fre->property('FRE.scheduler.runtime.max'));
      FRETemplate::setVariable(\$s, 'fileSenderTimeHistory', $fre->property('FRE.scheduler.runtime.fileSender.history') || $fre->property('FRE.scheduler.runtime.max'));
      
      FRETemplate::setVariable(\$s, 'outputStagerPartition', $fre->property('FRE.scheduler.partition.outputStager'));
      FRETemplate::setVariable(\$s, 'outputStagerQueue', $fre->property('FRE.scheduler.queue.outputStager'));
      FRETemplate::setVariable(\$s, 'outputStagerTime', $fre->property('FRE.scheduler.runtime.outputStager') || $fre->property('FRE.scheduler.runtime.max'));
      
      FRETemplate::setList(\$s, 'ppRefineDiagScriptNames', $z->extractPPRefineDiagScripts());
      FRETemplate::setList(\$s, 'getFmsData', @getFmsData);

      # ------------------------------------------ normal return

      return ($s, FREDefaults::STATUS_OK);

    }
    else
    {
    
      return (0, $status);
      
    }

  }

  sub prepareInputFile($$$)
  # ------ arguments: $exp $source $target
  # ------ internal helper to setup an input file
  # ------ return ($sript, $status)
  {

    my ($z, $s, $t) = @_;
    my $fre= $z->fre();

    if (File::Spec->file_name_is_absolute($s))
    {

      if (!File::Spec->file_name_is_absolute($t))
      {

	my $csh = '';

        my $sName = substr($s, 1);
	my $sArchiveFlag = FREUtil::fileIsArchive($s);
	$sName = FREUtil::fileArchiveExtensionStrip($sName) if $sArchiveFlag;

	my ($tFileName, $tDirName) = File::Basename::fileparse($t);
	my $tDirectoryFlag = ($tDirName ne './');
	
	if ($sArchiveFlag and $tDirectoryFlag and !$tFileName)
	{
	  $csh .= 'hsmget ' . $sName . '/\* && \\' . "\n";
          $csh .= 'if (! -d $workDir/' . $tDirName . ') mkdir -p $workDir/' . $tDirName . ' && \\' . "\n";
	  $csh .= 'ls $hsmDir/' . $sName . '/* | xargs ln -f -t $workDir/' . $tDirName . "\n";
	}
	elsif ($sArchiveFlag and $tFileName)
	{
	  $fre->out(FREMsg::FATAL, "The source archive '$s' can't be linked to the non-directory target '$t'");
	  return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
	}
	elsif (!$sArchiveFlag and ($tDirectoryFlag or $tFileName))
	{
	  $csh .= 'hsmget ' . $sName . ' && \\' . "\n";
          $csh .= 'if (! -d $workDir/' . $tDirName . ') mkdir -p $workDir/' . $tDirName . ' && \\' . "\n" if $tDirectoryFlag;
	  $csh .= 'ln -f $hsmDir/' . $sName . ' $workDir/' . $tDirName . (($tFileName) ? $tFileName : '.') . "\n";
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The target pathname is empty");
	  return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
	}

	if ($csh)
	{
	  $csh .= 'if ( $status != 0 ) then' . "\n";
	  $csh .= '  set dataFilesNotOK = ( $dataFilesNotOK ' . $s . ' )' . "\n";
	  $csh .= 'endif' . "\n";
	}

	return ($csh, FREDefaults::STATUS_OK);
	  
      }
      else
      {
	$fre->out(FREMsg::FATAL, "The target pathname '$t' isn't relative");
	return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "The source pathname '$s' isn't absolute");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

  }

  sub setInputVariableFile($$$)
  # ------ arguments: $script $exp $variableName
  # ------ internal helper to setup an input file, defined via a shell variable
  {

    my ($s, $z, $n) = @_;
    my ($fre, $fileName) = ($z->fre(), $z->extractVariableFile($n));

    if ($fileName)
    {
      $fre->out(FREMsg::NOTE, "name='$n' value='$fileName'");
      FRETemplate::setVariable(\$s, $n, $fileName);
    }
    else
    {
      $fre->out(FREMsg::WARNING, "Variable '$n' has no value");
      FRETemplate::setVariable(\$s, $n, "''");
    }

    return $s;

  }

  sub setInputInitialConditions($$)
  # ------ arguments: $script $exp
  {
    my ($s, $z) = @_;
    return frerun::setInputVariableFile($s, $z, 'initCond');
  }

  sub setInputGridSpecification($$)
  # ------ arguments: $script $exp
  {
    my ($s, $z) = @_;
    return frerun::setInputVariableFile($s, $z, 'gridSpec');
  }

  sub setInputDatasets($$)
  # ------ arguments: $script $exp
  # ------ return ($sript, $status)
  {

    my ($s, $z) = @_;
    my ($fre, @results) = ($z->fre(), $z->extractDatasets());
    my $dataSets;
    my $csh;

    while (scalar(@results) > 0)
    {
      my $source = shift @results;
      my $target = shift @results;
      if ($source =~ m/\//)
      {
	my ($cshSnippet, $status) = frerun::prepareInputFile($z, $source, $target);
	if ($cshSnippet)
	{
          $csh .= $cshSnippet . "\n";
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The pathname '$source' can't be setup in the runscript");
	  return (0, $status);
	}
      }
      else
      {
        $dataSets .= ' ' . $source;
      }
    }

    if ($dataSets)
    {
      $fre->out(FREMsg::WARNING, "The usage of 'get_fms_data' datasets is deprecated - please list your input files explicitly in the XML file");
      $s =~ s/#fmsDataSets_from_xml/get_fms_data$dataSets/;
    }
    else
    {
      $s =~ s/#fmsDataSets_from_xml//;
    }
    
    $s =~ s/#dataFiles_from_xml/$csh/;

    return ($s, FREDefaults::STATUS_OK);

  }

  sub setShellCommands($$)
  # ------ arguments: $script $exp
  {
  
    my ($s, $z) = @_;

    my %adjustment =
    (
      init	=> ['if ( $irun == 1 && $ireload == 1 ) then'."\n", "\n".'endif'."\n"],
      postInit	=> ['if ( $irun != 1 || $ireload != 1 ) then'."\n", "\n".'endif'."\n"]
    );
    
    my $expand = sub($$)
    {
      my ($k, $v) = @_;
      my $prefix = frerun::PRAGMA_PREFIX;
      my $placeholder = qr/^[ \t]*$prefix[ \t]+$k[ \t]*$/m;
      chomp ($v);
      $s =~ s/$placeholder/$v/;
    };

    $expand->(frerun::PRAGMA_SETUP_PLATFORM_CSH, $z->fre()->platformValue('csh'));
    $expand->(frerun::PRAGMA_EXPERIMENT_RUNTIME_CSH, $z->extractShellCommands('runtime/csh'));
    $expand->(frerun::PRAGMA_EXPERIMENT_INPUT_CSH_INIT, $z->extractShellCommands('input/csh[not(@type="always") and not(@type="postInit")]', %adjustment));
    $expand->(frerun::PRAGMA_EXPERIMENT_INPUT_CSH_ALWAYS_OR_POSTINIT, $z->extractShellCommands('input/csh[@type="always" or @type="postInit"]', %adjustment));
    $expand->(frerun::PRAGMA_EXPERIMENT_POSTPROCESS_CSH, $z->extractShellCommands('postProcess/csh'));
    
    return $s;
    
  }

  sub calendarType($)
  # ------ arguments: $refToHash
  {
    my $r = shift;
    my $calendarType;
    foreach my $key (sort keys %{$r})
    {
      my $value = $r->{$key};
      $value =~ s/^\s*!.*$//mg;
      if ($value =~ m/calendar\s*=\s*(?:'(.*)'|"(.*)")/m)
      {
        $calendarType = $1;
	last;
      }
    }
    return $calendarType;
  }

  sub baseDate($)
  # ------ arguments: $namelist
  {
    my $l = shift;
    my $baseDate = ($l =~ m/current_date\s*=\s*(\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+)/s) ? $1 : '0,0,0,0,0,0';
    $baseDate =~ s/,/ /g;
    return $baseDate;
  }

  sub setTables($$$)
  # ------ arguments: $script $exp $namelist
  # ------ return ($sript, $status)
  {
  
    my ($s, $z, $l) = @_;
    my $fre = $z->fre();
    $l =~ s/^\s*!.*$//mg;
    
    $fre->out(FREMsg::NOTE, "Extracting tables...");

    # --------------------------------------------------------------------- dataTable
    
    my $dataTable = $z->extractTable('dataTable');
    if ($dataTable != -1)
    {
      $dataTable = "cat >> data_table <<EOF\n$dataTable\nEOF\n" if $dataTable;
      $s =~ s/#dataTable_from_xml/$dataTable/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the data table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------------- fieldTable

    my $fieldTable = $z->extractTable('fieldTable');
    if ($fieldTable != -1)
    {
      if ($l)
      {
	if ($fieldTable !~ /^\s*"TRACER"\s*,\s*"atmos_mod"\s*,\s*"sphum".*/im)
	{
          $fieldTable .= '# added by FRE: sphum must be present in atmos' . "\n";
	  $fieldTable .= ' "TRACER", "atmos_mod",    "sphum"' . "\n";
	  $fieldTable .= '           "longname",     "specific humidity"' . "\n";
	  $fieldTable .= '           "units",        "kg/kg" /'. "\n";
	}
	if ($fieldTable !~ /^\s*"TRACER"\s*,\s*"land_mod"\s*,\s*"sphum".*/im)
	{
          $fieldTable .= '# added by FRE: sphum must be present on land' . "\n";
	  $fieldTable .= ' "TRACER", "land_mod",     "sphum"' . "\n";
	  $fieldTable .= '           "longname",     "specific humidity"' . "\n";
	  $fieldTable .= '           "units",        "kg/kg" /' . "\n";
	}
      }
      $fieldTable = "cat >> field_table <<EOF\n$fieldTable\nEOF\n" if $fieldTable; 
      $s =~ s/#fieldTable_from_xml/$fieldTable/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the field table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------------------- diagTable
    
    my $diagTable = $z->extractTable('diagTable');
    if ($diagTable != -1)
    {
      my $baseDate = frerun::baseDate($l);
      FRETemplate::setVariable(\$s, 'baseDate', "'$baseDate'");
      $diagTable =~ s/^\s*\$baseDate\s*$/$baseDate/m;
      $diagTable = "cat >> diag_table <<EOF\n$diagTable\nEOF\n" if $diagTable; 
      $s =~ s/#diagTable_from_xml/$diagTable/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the diagnostic table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # ------------------------------------------------------------------------ tracerTreeTable
    
    my $tracerTreeTable = $z->extractTable('tracerTreeTable');
    if ($tracerTreeTable != -1)
    {
      $tracerTreeTable = "cat >> ocean_tracer_tree <<EOF\n$tracerTreeTable\nEOF\n" if $tracerTreeTable;
      $s =~ s/#tracerTreeTable_from_xml/$tracerTreeTable/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the tracer tree table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------- tracerTreeInit
    
    my $tracerTreeInit = $z->extractTable('tracerTreeInit');
    if ($tracerTreeInit != -1)
    {
      $tracerTreeInit = "cat >> ocean_tracer_tree_init <<EOF\n$tracerTreeInit\nEOF\n" if $tracerTreeInit;
      $s =~ s/#tracerTreeInit_from_xml/$tracerTreeInit/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the tracer tree initialization");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # ------------------- normal return
    
    return ($s, FREDefaults::STATUS_OK);

  }

  sub extractRegressionTimingParameters($$)
  # ------ arguments: $exp $runNode
  {

    my ($z, $n) = @_;

    # -------------------------------------------- extract parameter values

    my $ml = $z->nodeValue($n, '@months') || '0';
    my $dl = $z->nodeValue($n, '@days') || '0';
    my $hl = $z->nodeValue($n, '@hours');

    # ------------------------------------------------ adjust months/days/hours lists 

    my @ma = split(' ', $ml);
    my @da = split(' ', $dl);
    my @ha = split(' ', $hl);

    my $nr = (@ma gt @da) ? ((@ma gt @ha) ? @ma : @ha) : ((@da gt @ha) ? @da : @ha);

    while (@ma < $nr) {push(@ma, '0');}
    while (@da < $nr) {push(@da, '0');}
    while (@ha < $nr) {push(@ha, '0');}

    $ml = join(' ', @ma);
    $dl = join(' ', @da);
    $hl = join(' ', @ha) if $hl;
    
    # ------------------------ return three lists
    
    return ($ml, $dl, $hl); 

  }

  sub setRegressionParameters($$$$$$$)
  # ------ arguments: $script $exp $runNode $monthslist $dayslist $hourslist $partition
  # ------ return ($sript, $extension, $status)
  {

    my ($s, $z, $n, $m, $d, $h, $p) = @_;

    # -------------------------------------------- extract parameter values

    my $np = $z->nodeValue($n, '@npes');
    my $rt = $z->nodeValue($n, '@runTimePerJob');

    # ------------------------------------------------------------ set parameters in the script

    my $nr = scalar(split(' ', $m));

    FRETemplate::setVariable(\$s, 'npes', $np);
    FRETemplate::setVariable(\$s, 'segmentsPerSimulation', $nr);
    FRETemplate::setVariable(\$s, 'segmentsPerJob', $nr);
    FRETemplate::setVariable(\$s, 'jobsPerSimulation', 1);
    FRETemplate::setVariable(\$s, 'combineFreq', $nr);

    FRETemplate::setList(\$s, 'monthslist', ($m));
    FRETemplate::setList(\$s, 'dayslist', ($d));

    if ($h)
    {
      $s =~ s/( *)(set -r dayslist = .+)/$1$2\n$1set -r hourslist = ( $h )/;
      $s =~ s/( *)(set days = .+)/$1$2\n$1set hours = \$hourslist[\$irun]/;
      $s =~ s/time_stamp -bf digital/time_stamp -bhf digital/;
      $s =~ s/time_stamp -ef digital/time_stamp -ehf digital/;
    } 

    # ----------------------------------------------------- set scheduler resources

    FRETemplate::setSchedulerResources(\$s, $z, $np, $rt, $rt, $p, 'run');

    # ---------------------------------------------- generate extension string

    my $m0 = (split(' ', $m))[0];
    my $d0 = (split(' ', $d))[0];
    my $h0 = (split(' ', $h))[0];

    my $x =
    (
      ($h)
      ?
      $nr . 'x' . $m0 . 'm' . $d0 . 'd' . $h0 . 'h_' . $np . 'pe'
      :
      $nr . 'x' . $m0 . 'm' . $d0 . 'd_' . $np . 'pe'
    );

    # ----------------------------------------- return result

    return ($s, $x, FREDefaults::STATUS_OK);

  }
  
  sub productionParametersExist($)
  # ------ arguments: $exp
  # ------ return 1 if production runtime parameters exist
  {
    my $z = shift;
    my $simTime = $z->extractValue('runtime/production/@simTime');
    return ($simTime) ? 1 : 0;
  }
  
  sub setProductionParameters($$$)
  # ------ arguments: $script $exp $partition
  # ------ return ($sript, $extension, $status)
  {

    my ($s, $z, $p) = @_;
    my $fre = $z->fre();

    # --------------------------------------- extract timing parameters

    my $np	   = $z->extractValue('runtime/production/@npes');
    my $simTime    = $z->extractValue('runtime/production/@simTime');
    my $simUnits   = $z->extractValue('runtime/production/@units');
    my $simRunTime = $z->extractValue('runtime/production/@runTime') || $fre->runTime($np);
    my $segTime    = $z->extractValue('runtime/production/segment/@simTime');
    my $segUnits   = $z->extractValue('runtime/production/segment/@units');
    my $segRunTime = $z->extractValue('runtime/production/segment/@runTime');

    # ------------------------------------------------------ check and adjust simulation/segment model time

    if ($np > 0)
    {
      my $patternUnits = qr/^(?:years|year|months|month)$/;
      if (($simTime > 0) and ($simUnits =~ m/$patternUnits/))
      {
        if (($segTime > 0) and ($segUnits =~ m/$patternUnits/))
	{
	  my $patternYears = qr/^(?:years|year)$/;
	  $simTime *= 12 if $simUnits =~ m/$patternYears/;
	  $segTime *= 12 if $segUnits =~ m/$patternYears/;
	  if ($segTime <= $simTime)
	  {
	    my $patternRunTime = qr/^\d\d:\d\d:\d\d$/;
	    if ($simRunTime =~ m/$patternRunTime/)
	    {
	      if ($segRunTime =~ m/$patternRunTime/)
	      {
		my ($simRunTimeMinutes, $segRunTimeMinutes) = (FREUtil::makeminutes($simRunTime), FREUtil::makeminutes($segRunTime));
		if ($segRunTimeMinutes <= $simRunTimeMinutes)
		{
		  # ---------------------------------------------------------------------------- print original values
		  $fre->out(FREMsg::NOTE, "simTime = $simTime months, segTime = $segTime months");
		  $fre->out(FREMsg::NOTE, "simRunTimeMin = $simRunTimeMinutes minutes, segRunTimeMin = $segRunTimeMinutes minutes");
		  # --------------------------------------------------------------------------------- calculate major timing parameters
		  my $segPerSim = POSIX::ceil($simTime / $segTime);
		  $fre->out(FREMsg::NOTE, "segPerSim ($segPerSim) = simTime ($simTime) / segTime ($segTime) (rounded up)");
		  my $segPerJob = POSIX::floor($simRunTimeMinutes / $segRunTimeMinutes);
		  $fre->out(FREMsg::NOTE, "segPerJob ($segPerJob) = simRunTimeMin ($simRunTimeMinutes) / segRunTimeMin ($segRunTimeMinutes) (rounded down)");
		  my $jobPerSim = POSIX::ceil($segPerSim / $segPerJob);  
		  $fre->out(FREMsg::NOTE, "jobPerSim ($jobPerSim) = segPerSim ($segPerSim) / segPerJob ($segPerJob) (rounded up)");
		  # ------------------------------------------------------------------------------------------------ create months/days lists
		  my @ma = ();
		  while (@ma < $segPerJob) {push(@ma, $segTime);}
		  my @da = (); 
		  while (@da < $segPerJob) {push(@da, '0');}
		  # ----------------------------------------------------------------------------------------------- calculate combining frequency 
		  my $combineFreq = 1;
		  if ($segTime < 12 and 12 <= $simTime)
		  {
		    if (12 % $segTime == 0)
		    {
        	      $combineFreq = 12 / $segTime;
		    }
		    else
		    {
        	      $fre->out(FREMsg::WARNING, "The segment length ($segTime months) is not divisor of 12 - the postprocessor will combine output only");
        	      $combineFreq = $segTime;
		    }
		  }
		  elsif (12 > $simTime)
		  {
		    $fre->out(FREMsg::WARNING, "The production run length ($simTime months) < 1 year - the postprocessor will combine output only");
		  }
		  elsif ($segTime % 12 != 0)
		  {
		    $fre->out(FREMsg::WARNING, "The segment length ($segTime months) is not divisible by 12 - the postprocessor will combine output only");
		  }
		  # ------------------------------------------------------------------------------------------ set parameters in the script
		  FRETemplate::setVariable(\$s, 'npes', $np);
		  FRETemplate::setVariable(\$s, 'segmentsPerSimulation', $segPerSim);
		  FRETemplate::setVariable(\$s, 'segmentsPerJob', $segPerJob);
		  FRETemplate::setVariable(\$s, 'jobsPerSimulation', $jobPerSim);
		  FRETemplate::setVariable(\$s, 'combineFreq', $combineFreq);
		  FRETemplate::setList(\$s, 'monthslist', @ma);
		  FRETemplate::setList(\$s, 'dayslist', @da);
		  # ----------------------------------------------------------------------------------- set scheduler resources
		  FRETemplate::setSchedulerResources(\$s, $z, $np, $simRunTime, $segRunTime, $p, 'run');
		  # ------------------------------------------------------------------------------- normal return
		  return ($s, '', FREDefaults::STATUS_OK);
		}
		else
		{
		  $fre->out(FREMsg::FATAL, "The segment running time '$segRunTimeMinutes' must not exceed the maximum job running time allowed '$simRunTimeMinutes'");
		  return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
		}
	      }
	      else
	      {
        	$fre->out(FREMsg::FATAL, "Segment running time '$segRunTime' must be nonempty and have the HH:MM:SS format");
		return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	      }
	    }
	    else
	    {
              $fre->out(FREMsg::FATAL, "Simulation running time '$simRunTime' must be noempty and have the HH:MM:SS format");
	      return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	    }
	  }
	  else
	  {
	    $fre->out(FREMsg::FATAL, "The segment time '$segTime' must not exceed the simulation time '$simTime'");
	    return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	  }
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Segment time '$segTime' must be nonempty and have one of (years|year|months|month) units defined");
	  return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Simulation time '$simTime' must be nonempty and have one of (years|year|months|month) units defined");
	return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Number of processors must be a positive integer");
      return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
    }      

  }
  
  sub setRegressionOutputDirectory($$$%)
  # ------ arguments: $script $exp $extension %options
  # ------ setups output directory via FREUtil::execute helper and writes its name in the script
  # ------ if the directory exists and the "unique" option is on, then appends a number to the directory/extension
  # ------ if the directory exists and the "overwrite" option is on, then removes and recreates the directory
  # ------ return ($script, $extension, $status)
  {

    my ($s, $z, $x, %o) = @_;
    
    my ($fre, $od, $host, $res) = ($z->fre(), $z->archiveDir() . '/' . $x, 'ac-arch', 1);

    $fre->out(FREMsg::NOTE, "Creating output directories for regression tests...");

    if (FREUtil::execute($host, "test -d $od -a -w $od") == 0)
    {
      if ($o{unique})
      {
        my $i = 1;
        while (-d "$od$i") {$i++;}
        $od .= "$i";
        $x .= "$i";
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      elsif ($o{overwrite})
      {
        $res = FREUtil::execute($host, "rm -rf $od/ascii $od/restart $od/history; mkdir -p $od/ascii");
      }
      elsif (FREUtil::execute($host, "test -d $od/ascii -a -w $od/ascii"))
      {
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Output directory '$od/ascii' exists, so you must specify either --overwrite or --unique");
	return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
      }
    }
    else
    {
      $res = FREUtil::execute($host, "mkdir -p $od/ascii");
    }

    if ($res == 0)
    {
      $fre->out(FREMsg::NOTE, "Created output directory $od/ascii");
      FRETemplate::setVariable(\$s, 'outputDir', $od);
      return ($s, $x, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to create the output directory '$od/ascii'!");
      return (0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }

  }

  sub setProductionOutputDirectory($$$%)
  # ------ arguments: $script $exp $extension %options
  # ------ setups output directory via FREUtil::execute helper and writes its name in the script
  # ------ if the directory exists and the "unique" option is on, then appends a number to the directory/extension
  # ------ if the directory exists and the "overwrite" option is on, then removes and recreates the directory
  # ------ return ($script, $extension, $status)
  {

    my ($s, $z, $x, %o) = @_;
    
    my ($fre, $od, $host, $res) = ($z->fre(), $z->archiveDir(), 'ac-arch', 1);
    
    $fre->out(FREMsg::NOTE, "Creating output directories for production run...");

    if (FREUtil::execute($host, "test -d $od -a -w $od") == 0)
    {
      if ($o{unique})
      {
        $fre->out(FREMsg::NOTE, "Performing unique production run, no post-processing for this run");
	FRETemplate::setSchedulerDualRuns(\$s, $z);
        my $i = 1;
        while ( -d "$od/$i" ) {$i++;}
        $od .= "/$i";
        $x .= "__$i";
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      elsif ($o{overwrite})
      {
        $res = FREUtil::execute($host, "rm -rf $od/ascii $od/restart $od/history $od/postProcess $od/analysis; mkdir -p $od/ascii");
      }
      elsif ($o{extend})
      {
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      elsif (FREUtil::execute($host, "test -d $od/ascii -a -w $od/ascii"))
      {
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Output directory '$od/ascii' exists, so you must specify --extend, --overwrite or --unique");
	return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
      } 
    }
    else
    {
      $res = FREUtil::execute($host, "mkdir -p $od/ascii");
    }
    
    if ($res == 0)
    {
      $fre->out(FREMsg::NOTE, "Created output directory $od/ascii");
      FRETemplate::setVariable(\$s, 'outputDir', $od);
      return ($s, $x, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to create the output directory '$od/ascii'!");
      return (0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }
    
  }
  
  sub namelistsAsString($)
  # ------ arguments: $refToNameListsHash
  {
    my $r = shift;
    my $nmlString = '';
    foreach my $key (sort(keys(%{$r})))
    {
      next unless $key;
      my $content = $r->{$key};
      $nmlString .= '<namelist name="' . $key . '">' . "\n";
      $nmlString .= $content . "\n";
      $nmlString .= '</namelist>' . "\n";
    }
    return $nmlString;
  }
  
  sub checkNamelists($$)
  # ------ arguments: $exp $refToNameListsHash
  {
    my ($z, $r) = @_;
    my $fre = $z->fre();
    my $targetListRepro = FRETargets::containsRepro($fre->target());
    if (exists($r->{xgrid_nml}))
    {
      my @xgridNml = split(/\n/, $r->{xgrid_nml});
      my $nmlRepro = (scalar(grep(/make_exchange_reproduce.+true/i, @xgridNml)) > 0);
      if ($nmlRepro and !$targetListRepro)
      {
        $fre->out(FREMsg::WARNING, "The 'make_exchange_reproduce' is .TRUE. in the 'xgrid_nml' namelist, which contradicts with absence of 'repro' in your targets");
      }
      elsif (!$nmlRepro and $targetListRepro)
      {
        $fre->out(FREMsg::WARNING, "The 'make_exchange_reproduce' is absent or isn't .TRUE. in the 'xgrid_nml' namelist, which contradicts with 'repro' in your targets");
      }
    }
    elsif ($targetListRepro)
    {
      $fre->out(FREMsg::WARNING, "The 'xgrid_nml' namelist isn't found, which contradicts with 'repro' in your targets");
    }
  }
  
  sub extractOverrideParams($$$)
  # ------ arguments: $exp $runNode $refToNamelistsHash 
  {

    my ($z, $n, $r) = @_;
    my $fre = $z->fre();

    my $res = $z->nodeValue($n, '@overrideParams');
    $res .= ';' if ($res and $res !~ /.*;$/);

    my $atmos_layout = $z->nodeValue($n, '@atmos_layout');
    if ($atmos_layout)
    {
      $res .= "bgrid_core_driver_nml:layout=$atmos_layout;" if $r->{bgrid_core_driver_nml};
      $res .= "fv_core_nml:layout=$atmos_layout;" if $r->{fv_core_nml};
      $fre->out
      (
        1,
	"Usage of 'atmos_layout' is deprecated; instead, use",
	"<run overrideParams=\"fv_core_nml:layout=$atmos_layout\" ...>",
	"or <run overrideParams=\"bgrid_core_driver_nml:layout=$atmos_layout\" ...>"
      );
    }

    my $zetac_layout = $z->nodeValue($n, '@zetac_layout');
    if ($zetac_layout)
    {
      $res .= "zetac_layout_nml:layout=$zetac_layout;";
      $fre->out
      (
        1,
	"Usage of 'zetac_layout' is deprecated; instead, use",
	"<run overrideParams=\"zetac_layout_nml:layout=$zetac_layout;namelist:var=val;...\" ...>"
      );
    }

    my $ice_layout = $z->nodeValue($n, '@ice_layout');
    if ($ice_layout)
    {
      $res .= "ice_model_nml:layout=$ice_layout;";
      $fre->out
      (
        1,
	"Usage of 'ice_layout' is deprecated; instead, use",
	"<run overrideParams=\"ice_model_nml:layout=$ice_layout;namelist:var=val;...\" ...>"
      );
    }

    my $ocean_layout = $z->nodeValue($n, '@ocean_layout');
    if ($ocean_layout)
    {
      $res .= "ocean_model_nml:layout=$ocean_layout;";
      $fre->out
      (
        1,
	"Usage of 'ocean_layout' is deprecated; instead, use",
	"<run overrideParams=\"ocean_model_nml:layout=$ocean_layout;namelist:var=val;...\" ...>"
      );
    }

    my $land_layout = $z->nodeValue($n, '@land_layout');
    if ($land_layout)
    {
      $res .= "land_model_nml:layout=$land_layout;";
      $fre->out
      (
        1,
	"Usage of 'land_layout' is deprecated; instead, use",
	"<run overrideParams=\"land_model_nml:layout=$land_layout;namelist:var=val;...\" ...>"
      );
    }
    
    return $res;

  }

  sub overrideRegressionNamelists($$$%)
  # ------ arguments: $exp $runNode $hourslist %namelistsHash
  # ------ return overridden namelists hash
  {

    my ($z, $n, $h, %l) = @_;
    my $fre = $z->fre();
    
    frerun::checkNamelists($z, \%l);

    if ($h)
    {
      my $hoursNml = $l{coupler_nml};
      unless ($hoursNml =~ /.*hours\s*=\s*(\$hours)\s*(.*)/)
      {
        $hoursNml =~ s/( *)(days *=)/$1hours = \$hours,\n$1$2/;
        $fre->out(FREMsg::NOTE, "Adding hours to coupler_nml...\n$hoursNml\n");
        $l{coupler_nml} = $hoursNml;
      }
    }

    my $nmlOverrides = frerun::extractOverrideParams($z, $n, \%l);
    my @nmls = split(/;/, $nmlOverrides);

    foreach my $nml (@nmls)
    {

      my ($namelist, $var, $val) = split(/[:=]/, $nml);
      $namelist =~ s/\s*//g;
      $var =~ s/\s*//g;
      unless ($namelist and $var) {$fre->out(FREMsg::WARNING, "Got an empty namelist in overrideParams"); next;}

      $fre->out(FREMsg::NOTE, "overrideParams from xml: $namelist:$var=$val");

      if (exists($l{$namelist}))
      {
        $fre->out(FREMsg::NOTE, "original namelist:  $namelist\n$l{$namelist}");
        if ($l{$namelist} =~ /\b($var\s*=\s*)(\S.*)(([,\n]\s*\w+\s*=\s*.*)*)/i)
	{
          $l{$namelist} =~ s/\b($var\s*=\s*)(\S.*)(([,\n]\s*\w+\s*=\s*.*)*)/$1$val$3/i;
        }
	else
	{
          $l{$namelist} =~ s/^(\s*)/$1$var = $val,\n$1/;
        }
      }
      else
      {
        $l{$namelist} = "	$var = $val";
      }

      $fre->out(FREMsg::NOTE, "overridden namelist: $namelist\n$l{$namelist}");

    }

    return %l;

  }

  sub overrideProductionNamelists($%)
  # ------ arguments: $exp %namelistsHash
  # ------ return overridden namelists hash
  {

    my ($z, %l) = @_;

    my $setLayout = sub($$)
    {
      my ($n, $v) = @_;
      if (exists($l{$n}))
      {
	if ($l{$n} =~ /\b(layout\s*=\s*)(\d+|\$\w+)\s*,\s*(\d+|\$\w+)\b(.*)/i)
	{
          $l{$n} =~ s/\b(layout\s*=\s*)(\d+|\$\w+)\s*,\s*(\d+|\$\w+)\b(.*)/$1$v$4/i;
	}
	else
	{ 
          $l{$n} =~ s/^(\s*)/$1layout = $v,\n$1/;
	}
      }
      else
      {
	$l{$n} = "	layout = $v";
      }
    };

    frerun::checkNamelists($z, \%l);

    my $atmos_layout = $z->extractValue('runtime/production/peLayout/@atmos');
    $setLayout->('bgrid_core_driver_nml', $atmos_layout) if $atmos_layout;
    $setLayout->('fv_core_nml', $atmos_layout) if $atmos_layout;

    my $zetac_layout = $z->extractValue('runtime/production/peLayout/@zetac');
    $setLayout->('zetac_layout_nml', $zetac_layout) if $zetac_layout;

    my $ice_layout = $z->extractValue('runtime/production/peLayout/@ice');
    $setLayout->('ice_model_nml', $ice_layout) if $ice_layout;

    my $ocean_layout = $z->extractValue('runtime/production/peLayout/@ocean');
    $setLayout->('ocean_model_nml', $ocean_layout) if $ocean_layout;

    my $land_layout = $z->extractValue('runtime/production/peLayout/@land');
    $setLayout->('land_model_nml', $land_layout) if $land_layout;

    return %l;

  }

  sub setNamelists($%)
  # ------ arguments: $script %namelistsHash
  # ------ returns script, updated from namelists
  {

    my ($s, %l) = @_;
    
    my $calendarType = frerun::calendarType(\%l);
    my $timeStampFormat = ($calendarType and ($calendarType ne 'no_calendar')) ? 'digital' : 'days';
    FRETemplate::setVariable(\$s, 'timeStampFormat', $timeStampFormat);

    my $nmlString = "cat > input.nml <<EOF\n";
    foreach my $key (sort(keys(%l)))
    {
      next unless $key;
      my $content = $l{$key};
      $nmlString .= " \&$key\n$content\n\/\n\n";
    }
    $nmlString .= "EOF\n";

    $s =~ s/#namelists_from_xml/$nmlString/;
    return $s;

  }

  sub setMPI($$$%)
  # ------ arguments: $script $exp $runNode %options
  {

    my ($s, $z, $n, %o) = @_;
    my $fre = $z->fre();

    my $histx = ($n) ? $z->nodeValue($n, '@histx') : '';
    if ($histx)
    {
      if ($o{regression})
      {
	unless (FREDefaults::SiteIsGFDL())
	{
	  $fre->out(FREMsg::WARNING, "histx can only be used at GFDL on the Altix platform.  Not using histx...");
	  $histx = '';
	}
      }
      else
      {
        $fre->out(FREMsg::WARNING, "histx can only be used for regression runs.  Not using histx...");
	$histx = '';
      }
    }

    my $csh = '';
    
    if ($o{target} =~ m/debug/ or $o{debug} eq 'totalview')
    {
      $csh .= 'setenv TRAP_FPE overfl=trace,exit;divzero=trace,exit;invalid=trace,exit' . "\n";
    }

    if ($ENV{MPIRUN_EXEC})
    {
      $fre->out(FREMsg::NOTE, "Using your environment variable MPIRUN_EXEC: $ENV{MPIRUN_EXEC}");
      $csh .= $ENV{MPIRUN_EXEC};
    }
    elsif ($o{debug} eq 'totalview')
    {
      $fre->out(FREMsg::NOTE, "Will launch TotalView...");
      $csh .= 'foreach i ( $executable:h/Makefile* )' . "\n";
      $csh .= '  make localize -f $i' . "\n";
      $csh .= 'end' . "\n";
      $csh .= 'totalview mpirun -a -np $npes'; 
    }
    elsif ($o{debug} eq 'setup')
    {
      $fre->out(FREMsg::NOTE, "Will exit before the mpirun call...");
      $csh .= "\n";
      $csh .= 'exit 1' . "\n\n";
      $csh .= '/usr/bin/time -p mpirun -np $npes';
    }
    elsif ($histx)
    {
      $fre->out(FREMsg::NOTE, "Will use histx profiling tool...");
      $csh .= 'source /opt/sgi/histx/setup.csh' . "\n";
      $csh .= '/usr/bin/time -p mpirun -np $npes `which histx` -o hi ' . $histx;
    }
    else
    {
      $csh .= '/usr/bin/time -p mpirun -np $npes';
    }

    $csh .= ' ./$executable:t |& tee fms.out';

    $fre->out(FREMsg::NOTE, "Running executable with:\n$csh");

    $s =~ s/#parlib_run_from_xml/$csh/;
    return $s;

  }
  
  sub outputScriptJobId($$$)
  # ------ arguments: $fre $string $mode
  # ------ return $jobId
  {
    my ($fre, $s, $m) = @_;
    my $submitOutputPattern = $fre->property("FRE.scheduler.submit.output.pattern.$m") || $fre->property('FRE.scheduler.submit.output.pattern');
    return ($s =~ m/$submitOutputPattern/m) ? $1 : '';
  }
  
  sub outputScriptOption($$$)
  # ------ arguments: $fre $name $value
  {
    my ($fre, $n, $v) = @_;
    my $optionString = $fre->property($n);
    $optionString =~ s/\$/$v/;
    return $optionString;
  }
  
  sub outputScriptExecuteOrSubmit($$$$%)
  # ------ arguments: $script $exp $scriptAbsName $stdoutAbsName %options
  # ------ write $script to the $scriptAbsName file, chmod, and optionally execute or submit
  # ------ return ($script, $status)
  {
    my ($s, $z, $n, $o, %o) = @_;
    my $fre = $z->fre();
    my $stdoutDir = File::Basename::dirname($o);
    if (frerun::createDirectory($fre, $stdoutDir, $o{verbose}))
    {
      my $scriptsDir = File::Basename::dirname($n);
      if (frerun::createDirectory($fre, $scriptsDir, $o{verbose}))
      {
	if (open my $scriptHandle, '>', $n)
	{
	  print {$scriptHandle} $s;
	  close $scriptHandle;
	  if (chmod 0755, $n)
	  {
	    if ($o{execute})
	    {
	      my $res = system("$n 2>&1 | tee $o");
	      if ($res == 0)
	      {
		return ($s, FREDefaults::STATUS_OK);
	      }
	      else
	      {
        	$fre->out(FREMsg::FATAL, "The runscript '$n' failed! ($res)", "Please see the logfile '$o'...");
		return (0, FREDefaults::STATUS_FRE_RUN_EXECUTION_PROBLEM);
	      }
	    }
	    elsif ($o{submit}) 
	    {
	      my $submit = $fre->property('FRE.scheduler.submit.command');
	      $fre->out(FREMsg::NOTE, "Executing '$submit $n'...");
	      print qx($submit $n);
	      return ($s, FREDefaults::STATUS_OK);
	    }
	    elsif ($o{'submit-chained'})
	    {
	      my $scriptBasename = File::Basename::basename($n);
	      my $submit = $fre->property('FRE.scheduler.submit.command');
	      my $name = frerun::outputScriptOption($fre, 'FRE.scheduler.option.name', "${scriptBasename}_chain");
	      my $resources = FRETemplate::schedulerResourcesAsString($z, $o{ncores}, $o{walltime} * 60, '', '', 'transfer');
	      my $submitChainCommand = "$submit $name $resources -v FRE_STAGE=CHAIN $n";
	      $fre->out(FREMsg::NOTE, "Executing '$submitChainCommand'...");
	      print qx($submitChainCommand);
	      return ($s, FREDefaults::STATUS_OK);
	    }
	    elsif ($o{'submit-staged'})
	    {
	      my $scriptBasename = File::Basename::basename($n);
	      my $submit = $fre->property('FRE.scheduler.submit.command');
	      my $name = frerun::outputScriptOption($fre, 'FRE.scheduler.option.name', "${scriptBasename}_input");
	      my $resources = FRETemplate::schedulerResourcesAsString($z, $o{ncores}, $o{walltime} * 60, '', '', 'transfer');
	      my $submitInputCommand = "$submit $name $resources -v FRE_STAGE=INPUT $n";
	      $fre->out(FREMsg::NOTE, "Executing '$submitInputCommand'...");
	      my $submitInputMsg = qx($submitInputCommand);
	      print "$submitInputMsg";
	      my $jobId = frerun::outputScriptJobId($fre, $submitInputMsg, 'transfer');
	      if ($jobId)
	      {
		my $optionDependsOn = frerun::outputScriptOption($fre, 'FRE.scheduler.option.dependsOn', $jobId);
		my $submitRunCommand = "$submit $optionDependsOn $n";
		$fre->out(FREMsg::NOTE, "Executing '$submitRunCommand'...");
		print qx($submitRunCommand);
		return ($s, FREDefaults::STATUS_OK);
	      }
	      else
	      {
		$fre->out(FREMsg::FATAL, "Unable to submit the input data staging job for '$scriptBasename'");
		return ($s, FREDefaults::STATUS_FRE_RUN_EXECUTION_PROBLEM);
	      }
	    }
	    else
	    {
	      my $submit = $fre->property('FRE.scheduler.submit.command');
	      print "TO SUBMIT => $submit $n\n";
	      return ($s, FREDefaults::STATUS_OK);
	    }
	  }
	  else
	  {
            $fre->out(FREMsg::FATAL, "Unable to change the script '$n' permissions!");
	    return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	  }
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to save the script '$n'!");
	  return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	}
      }
      else
      {
	$fre->out(FREMsg::FATAL, "Unable to create the scripts directory '$scriptsDir'!");
	return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to create the stdout directory '$stdoutDir'!");
      return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }
  }
  
  sub processRegressionRun($$$$%)
  # ------ arguments: $script $exp $refToNamelists $runNode %options
  {
    my ($s, $z, $r, $n, %o) = @_;
    my ($mlist, $dlist, $hlist) = frerun::extractRegressionTimingParameters($z, $n);
    my ($rtScript, $extension, $status) = frerun::setRegressionParameters($s, $z, $n, $mlist, $dlist, $hlist, $o{partition});
    if ($rtScript)
    {
      ($rtScript, $extension, $status) = frerun::setRegressionOutputDirectory($rtScript, $z, $extension, %o);
      if ($rtScript)
      {
	my %nmlOverridden = frerun::overrideRegressionNamelists($z, $n, $hlist, %{$r});
        $rtScript = frerun::setNamelists($rtScript, %nmlOverridden);
	$rtScript = frerun::setMPI($rtScript, $z, $n, %o);
	my $scriptName = frerun::regressionRunScriptName($z, $extension);
        my $stdoutName = frerun::stdoutName($z, $scriptName);
	my $stdoutDir = File::Basename::dirname($stdoutName);
        FRETemplate::setVariable(\$rtScript, 'scriptName', $scriptName);
        FRETemplate::setVariable(\$rtScript, 'stdoutDir', $stdoutDir);
        FRETemplate::setSchedulerNames(\$rtScript, $z, File::Basename::basename($scriptName), $stdoutDir);
        return frerun::outputScriptExecuteOrSubmit($rtScript, $z, $scriptName, $stdoutName, %o);
      }
      else
      {
	return (0, $status);
      }
    }
    else
    {
      return (0, $status);
    }
  }
  
  sub processRegression($$$%)
  # ------ arguments: $exp $refToNamelists $label %options
  {
    my ($z, $r, $l, %o) = @_;
    my ($expName, $fre, %nml) = ($z->name(), $z->fre(), %{$r});
    $fre->out(FREMsg::NOTE, "Creating runscripts for the regression test '$l'...");
    my ($runScript, $status) = frerun::init($z, %o);
    if ($runScript)
    {
      ($runScript, $status) = frerun::setInputDatasets($runScript, $z);
      if ($runScript)
      {
	($runScript, $status) = frerun::setTables($runScript, $z, $nml{coupler_nml});
	if ($runScript)
	{
	  $runScript = frerun::setInputInitialConditions($runScript, $z);
	  $runScript = frerun::setInputGridSpecification($runScript, $z);
 	  $runScript = frerun::setShellCommands($runScript, $z);
	  FRETemplate::setVersionInfo(\$runScript, $z, $0, %o);	    
	  my $x = 'regression[@label="' . $l . '" or @name="' . $l . '"]';
	  my @regNodes = $z->extractNodes('runtime', $x);
	  if (scalar(@regNodes) == 1)
	  {
	    my @runNodes = $z->extractNodes('runtime/' . $x, 'run');
	    if (scalar(@runNodes) > 1)
	    {
	      for (my $i = 0; $i < scalar(@runNodes); $i++)
	      {
                $fre->out(FREMsg::NOTE, "Creating a runscript #$i for the regression test '$l'...");
	        (my $rc, $status) = frerun::processRegressionRun($runScript, $z, $r, $runNodes[$i], %o);
		if ($rc)
		{
	          $fre->out(FREMsg::NOTE, "A runscript #$i for the regression test '$l' in the experiment '$expName' has been created successfully");
		}
		else
		{
                  $fre->out(FREMsg::FATAL, "Unable to create a runscript #$i for the regression test '$l' in the experiment '$expName'");
		  return (0, $status);
		}
              }
	      return (1, FREDefaults::STATUS_OK);
	    }
	    elsif (scalar(@runNodes) == 1)
	    {
	      (my $rc, $status) = frerun::processRegressionRun($runScript, $z, $r, $runNodes[0], %o);
	      if ($rc)
	      {
	        $fre->out(FREMsg::NOTE, "A runscript for the regression test '$l' in the experiment '$expName' has been created successfully");
		return (1, FREDefaults::STATUS_OK);
	      }
	      else
	      {
                $fre->out(FREMsg::FATAL, "Unable to create a runscript for the regression test '$l' in the experiment '$expName'");
		return (0, $status);
	      }
	    }
	    else
	    {
	      $fre->out(FREMsg::FATAL, "The regression test '$l' doesn't have any runs in the experiment '$expName'");
	      return (0, FREDefaults::STATUS_FRE_GENERIC_PROBLEM);
	    }
	  }
	  else
	  {
	    $fre->out(FREMsg::FATAL, "The regression test '$l' doesn't exist or defined more than once in the experiment '$expName'");
	    return (0, FREDefaults::STATUS_FRE_GENERIC_PROBLEM);
	  }
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to setup tables for the experiment '$expName'");
	  return (0, $status);
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Unable to setup input data for the experiment '$expName'");
	return (0, $status);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to initialize the experiment '$expName'");
      return (0, $status);
    }
  }
  
  sub processRegressionSuite($$%)
  # ------ arguments: $exp $refToNamelists %options 
  {
    my ($z, $r, %o) = @_;
    my ($expName, $fre, %nml) = ($z->name(), $z->fre(), %{$r});
    $fre->out(FREMsg::NOTE, "Creating runscripts for the regression tests suite...");
    my ($runScript, $status) = frerun::init($z, %o);
    if ($runScript)
    {
      ($runScript, $status) = frerun::setInputDatasets($runScript, $z);
      if ($runScript)
      {
	($runScript, $status) = frerun::setTables($runScript, $z, $nml{coupler_nml});
	if ($runScript)
	{
	  $runScript = frerun::setInputInitialConditions($runScript, $z);
	  $runScript = frerun::setInputGridSpecification($runScript, $z);
 	  $runScript = frerun::setShellCommands($runScript, $z);
	  FRETemplate::setVersionInfo(\$runScript, $z, $0, %o);	    
	  foreach my $regLabel (frerun::REGRESSION_SUITE)
	  {
            $fre->out(FREMsg::NOTE, "Creating runscripts for the regression test '$regLabel'...");
	    my $x = 'regression[@label="' . $regLabel . '" or @name="' . $regLabel . '"]';
	    my @regNodes = $z->extractNodes('runtime', $x);
	    if (scalar(@regNodes) == 1)
	    {
	      my @runNodes = $z->extractNodes('runtime/' . $x, 'run');
	      if (scalar(@runNodes) > 1)
	      {
		for (my $i = 0; $i < scalar(@runNodes); $i++)
		{
                  $fre->out(FREMsg::NOTE, "Creating a runscript #$i for the regression test '$regLabel'...");
	          (my $rc, $status) = frerun::processRegressionRun($runScript, $z, $r, $runNodes[$i], %o);
		  if ($rc)
		  {
	            $fre->out(FREMsg::NOTE, "A runscript #$i for the regression test '$regLabel' in the experiment '$expName' has been created successfully");
		  }
		  else
		  {
                    $fre->out(FREMsg::FATAL, "Unable to create a runscript #$i for the regression test '$regLabel' in the experiment '$expName'");
		    return (0, $status);
		  }
        	}
	      }
	      elsif (scalar(@runNodes) == 1)
	      {
	        (my $rc, $status) = frerun::processRegressionRun($runScript, $z, $r, $runNodes[0], %o);
		if ($rc)
		{
	          $fre->out(FREMsg::NOTE, "A runscript for the regression test '$regLabel' in the experiment '$expName' has been created successfully");
		}
		else
		{
                  $fre->out(FREMsg::FATAL, "Unable to create a runscript for the regression test '$regLabel' in the experiment '$expName'");
		  return (0, $status);
		}
	      }
	      else
	      {
		$fre->out(FREMsg::WARNING, "The suite is incomplete - the regression test '$regLabel' doesn't have any runs in the experiment '$expName'");
	      }
	    }
	    else
	    {
	      $fre->out(FREMsg::WARNING, "The suite is incomplete - the regression test '$regLabel' doesn't exist or defined more than once in the experiment '$expName'");
	    }
	  }
	  return (1, FREDefaults::STATUS_OK);
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to setup tables for the experiment '$expName'");
	  return (0, $status);
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Unable to setup input data for the experiment '$expName'");
	return (0, $status);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to initialize the experiment '$expName'");
      return (0, $status);
    }
  }
  
  sub processProduction($$%)
  # ------ arguments: $exp $refToNamelists %options 
  {
    my ($z, $r, %o) = @_;
    my ($expName, $fre, %nml) = ($z->name(), $z->fre(), %{$r});
    $fre->out(FREMsg::NOTE, "Creating a runcript for the experiment '$expName'...");
    my ($runScript, $status) = frerun::init($z, %o);
    if ($runScript)
    {
      ($runScript, $status) = frerun::setInputDatasets($runScript, $z);
      if ($runScript)
      {
	($runScript, $status) = frerun::setTables($runScript, $z, $nml{coupler_nml});
	if ($runScript)
	{
	  $runScript = frerun::setInputInitialConditions($runScript, $z);
	  $runScript = frerun::setInputGridSpecification($runScript, $z);
 	  $runScript = frerun::setShellCommands($runScript, $z);
	  FRETemplate::setVersionInfo(\$runScript, $z, $0, %o);	    
	  ($runScript, my $extension, $status) = frerun::setProductionParameters($runScript, $z, $o{partition});
	  if ($runScript)
	  {
	    ($runScript, $extension, $status) = frerun::setProductionOutputDirectory($runScript, $z, $extension, %o);
	    if ($runScript)
	    {
	      my %nmlOverridden = frerun::overrideProductionNamelists($z, %nml);
	      $runScript = frerun::setNamelists($runScript, %nmlOverridden);
	      $runScript = frerun::setMPI($runScript, $z, '', %o);
	      my $scriptName = frerun::productionRunScriptName($z, $extension);
              my $stdoutName = frerun::stdoutName($z, $scriptName);
	      my $stdoutDir = File::Basename::dirname($stdoutName);
              FRETemplate::setVariable(\$runScript, 'scriptName', $scriptName);
	      FRETemplate::setVariable(\$runScript, 'stdoutDir', $stdoutDir);
              FRETemplate::setSchedulerNames(\$runScript, $z, File::Basename::basename($scriptName), $stdoutDir);
              ($runScript, $status) = frerun::outputScriptExecuteOrSubmit($runScript, $z, $scriptName, $stdoutName, %o);
	      if ($runScript)
	      {
		return (1, FREDefaults::STATUS_OK);
	      }
	      else
	      {
		$fre->out(FREMsg::FATAL, "Unable to create (or run) a runscript for the experiment '$expName'");
		return (0, $status);
	      }
	    }
	    else
	    {
	      $fre->out(FREMsg::FATAL, "Unable to setup output directories for the experiment '$expName'");
	      return (0, $status);
	    }
	  }
	  else
	  {
	    $fre->out(FREMsg::FATAL, "Unable to setup timing parameters for the experiment '$expName'");
	    return (0, $status);
	  }
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to setup tables for the experiment '$expName'");
	  return (0, $status);
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Unable to setup input data for the experiment '$expName'");
	return (0, $status);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to initialize the experiment '$expName'");
      return (0, $status);
    }
  }

  sub skipExp($)
  # ------ arguments: $exp 
  {
    my $z = shift;
    my ($expName, $fre) = ($z->name(), $z->fre());
    $fre->out(FREMsg::FATAL, "Skipping the experiment '$expName'...");
  }

}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

  my %opt =
  (
    'archive'		=> 1,
    'combine-history'	=> 1,
    'logging'		=> 1,
    'platform'		=> FREDefaults::Platform(),
    'target'		=> FREDefaults::Target(),
    'xmlfile'		=> FREDefaults::XMLFile()
  );

  Getopt::Long::GetOptions(\%opt, frerun::OPTLIST) or (print frerun::Usage() and exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM);
  if ($opt{version}) {print frerun::VERSION,"\n" and exit FREDefaults::STATUS_OK;}
  if ($opt{help}) {print frerun::Help() and exit FREDefaults::STATUS_OK;}
  
  if (scalar(@ARGV) == 0)
  {
    my $self = File::Basename::basename($0);
    FREMsg::out($opt{verbose}, 0, "At least one experiment name is needed on the command line", "Try '$self --help' for more information");
    exit FREDefaults::STATUS_COMMAND_NO_EXPERIMENTS;
  }

  if ($opt{extend} + $opt{overwrite} + $opt{unique} > 1)
  {
    FREMsg::out($opt{verbose}, 0, "Options --extend, --overwrite and --unique are mutually exclusive - only one of them can be present");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }
  
  if ($opt{submit} + $opt{'submit-chained'} + $opt{'submit-staged'} > 1)
  {
    FREMsg::out($opt{verbose}, 0, "Options --submit, --submit-chained and --submit-staged are mutually exclusive - only one of them can be present");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }
  
  if (exists($opt{'output-staging'}) and scalar(grep($_ eq $opt{'output-staging'}, frerun::OUTPUT_STAGING_TYPES)) == 0)
  {
    FREMsg::out($opt{verbose}, 0, "The option --output-staging='$opt{'output-staging'}' is invalid - the option value must be one of: online, offline, staged, bySegment");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }
  
  if (exists($opt{'output-staging'}) and ($opt{'output-staging'} ne 'online') and !$opt{archive})
  {
    FREMsg::out($opt{verbose}, 0, "Options --output-staging='$opt{'output-staging'}' and --noarchive are incompatible");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }

  if (($opt{'output-staging'} eq 'offline') and $opt{regression})
  {
    FREMsg::out($opt{verbose}, 0, "The 'offline' output staging can't be used for regression tests");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }

  if (($opt{'output-staging'} eq 'offline') and $opt{unique})
  {
    FREMsg::out($opt{verbose}, 0, "The 'offline' output staging can't be used for unique runs");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }

  if ($opt{check} and !$opt{unique})
  {
    FREMsg::out($opt{verbose}, 1, "Option --check is allowed only when the option --unique is present, the --check option is ignored");
    delete $opt{check};
  }

  if ($opt{dual} and $opt{regression})
  {
    FREMsg::out($opt{verbose}, 1, "Options --dual and --regression are incompatible, the --dual option is ignored");
    delete $opt{dual};
  }
  
  if ($opt{dual} and $opt{unique})
  {
    FREMsg::out($opt{verbose}, 0, "Options --dual and --unique are incompatible, the --dual option is ignored");
    delete $opt{dual};
  }

  if ($opt{transfer} and $opt{check})
  {
    FREMsg::out($opt{verbose}, 1, "Option --transfer is not allowed when the option --check is present, the --transfer option is ignored");
    delete $opt{transfer};
  }
  
  my $fre = FRE->new('frerun', %opt) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;

  if (!exists($opt{dual}) and !$opt{regression} and !$opt{unique} and $fre->property('FRE.option.dual.default'))
  {
    FREMsg::out($opt{verbose}, 1, "Option --dual has been automatically added");
    %opt = (%opt, 'dual' => 1);
  }

  if (!exists($opt{transfer}) and !$opt{check} and $fre->property('FRE.option.transfer.default'))
  {
    FREMsg::out($opt{verbose}, 1, "Option --transfer has been automatically added");
    %opt = (%opt, 'transfer' => 1);
  }

  {
    my $ncores = $opt{ncores} || $fre->property('FRE.input.staging.coresPerJob.default') || frerun::NCORES_DEFAULT;
    %opt = (%opt, 'ncores' => $ncores);
  }
  
  {
    my $walltime = $opt{walltime} || $fre->property('FRE.input.staging.walltime.default') || frerun::WALLTIME_DEFAULT;
    %opt = (%opt, 'walltime' => $walltime);
  }
  
  my @exps = ();
  foreach my $expName (@ARGV)
  {
    my $exp = FREExperiment->new($fre, $expName) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    push @exps, $exp;
  }

  my $status = FREDefaults::STATUS_OK;
  
  foreach my $exp (@exps)
  {

    # --------------------------------- set the experiment name
    
    my $expName = $exp->name();
    $fre->setCurrentExperimentName($expName);
    $fre->out(FREMsg::NOTE, "Setting up the experiment '$expName'...");

    # ---------------------------------------------------------------- process the experiment
    
    my %nml = $exp->extractNamelists();
    if (!exists($nml{-1}))
    {
      if ($opt{namelist})
      {
	if ($opt{regression})
	{
          # --------------------------------------------------------------- regression namelists output
	  my @regLabels = ($opt{regression} eq 'suite') ? frerun::REGRESSION_SUITE : $opt{regression};
	  foreach my $regLabel (@regLabels)
	  {
            $fre->out(FREMsg::NOTE, "Extracting namelists for the regression test '$regLabel'...");
	    my $x = 'regression[@label="' . $regLabel . '" or @name="' . $regLabel . '"]';
	    my @regNodes = $exp->extractNodes('runtime', $x);
	    if (scalar(@regNodes) == 1)
	    {
	      my @runNodes = $exp->extractNodes('runtime/' . $x, 'run');
	      if (scalar(@runNodes) > 0)
	      {
		for (my $i = 0; $i < scalar(@runNodes); $i++)
		{
		  my $runNode = $runNodes[$i];
		  my ($mlist, $dlist, $hlist) = frerun::extractRegressionTimingParameters($exp, $runNode);
		  my %nmlOverridden = frerun::overrideRegressionNamelists($exp, $runNode, $hlist, %nml);
		  print frerun::namelistsAsString(\%nmlOverridden), "\n";
		}
              }
	      else
	      {
	        if ($opt{regression} eq 'suite')
		{
		  $fre->out(FREMsg::WARNING, "The suite is incomplete - the regression test '$regLabel' doesn't have any runs for the experiment '$expName'");
		}
		else
		{
		  $fre->out(FREMsg::FATAL, "The regression test '$regLabel' doesn't have any runs for the experiment '$expName'");
		  frerun::skipExp($exp) if scalar(@exps) > 1;
		  $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
		  last;
		} 
	      }
	    }
	    else
	    {
	      if ($opt{regression} eq 'suite')
	      {
		$fre->out(FREMsg::WARNING, "The suite is incomplete - the regression test '$regLabel' doesn't exist or defined more than once for the experiment '$expName'");
	      }
	      else
	      {
		$fre->out(FREMsg::FATAL, "The regression test '$regLabel' doesn't exist or defined more than once for the experiment '$expName'");
		frerun::skipExp($exp) if scalar(@exps) > 1;
		$status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
		last;
	      } 
	    }
	  }
	}
	else
	{
          # ------------------------------------------------- production namelists output
          $fre->out(FREMsg::NOTE, "Extracting namelists for the experiment '$expName'...");
          my %nmlOverridden = frerun::overrideProductionNamelists($exp, %nml);
	  print frerun::namelistsAsString(\%nmlOverridden), "\n";
	}
      }
      elsif ($opt{regression} eq 'suite')
      {
	# ----------------------------------------------------------------- regression scripts suite creation
        (my $rc, $status) = frerun::processRegressionSuite($exp, \%nml, %opt);
	if ($rc)
	{
	  $fre->out(FREMsg::NOTE, "The regression tests suite in the experiment '$expName' has been processed successfully");
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to process the regression tests suite in the experiment '$expName'");
	  frerun::skipExp($exp) if scalar(@exps) > 1;
	}
      }
      elsif ($opt{regression})
      {
	# ----------------------------------------------------------------- regression scripts creation
        (my $rc, $status) = frerun::processRegression($exp, \%nml, $opt{regression}, %opt);
	if ($rc)
	{
	  $fre->out(FREMsg::NOTE, "The regression test '$opt{regression}' in the experiment '$expName' has been processed successfully");
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to process the regression test '$opt{regression}' in the experiment '$expName'");
	  frerun::skipExp($exp) if scalar(@exps) > 1;
	}
      }
      elsif (frerun::productionParametersExist($exp))
      {
	# ----------------------------------------------------------------- production runscript creation
	(my $rc, $status) = frerun::processProduction($exp, \%nml, %opt);
	if ($rc)
	{
	  $fre->out(FREMsg::NOTE, "A runscript for the experiment '$expName' has been created successfully");
	  if ($opt{dual})
	  {
	    (my $rc, $status) = frerun::processProduction($exp, \%nml, (%opt, 'check' => 1, 'extend' => 0, 'overwrite' => 0, 'transfer' => 0, 'unique' => 1));
	    if ($rc)
	    {
	      $fre->out(FREMsg::NOTE, "A dual runscript for the experiment '$expName' has been created successfully");
	    }
	    else
	    {
	      $fre->out(FREMsg::FATAL, "Unable to create a dual runscript for the experiment '$expName'");
	      frerun::skipExp($exp) if scalar(@exps) > 1;
	    }
	  } 
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to create a runscript for the experiment '$expName'");
	  frerun::skipExp($exp) if scalar(@exps) > 1;
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Unable to find runtime production parameters for the experiment '$expName'");
	frerun::skipExp($exp) if scalar(@exps) > 1;
        $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to extract namelists for the experiment '$expName'");
      frerun::skipExp($exp) if scalar(@exps) > 1;
      $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    }
    
    # ------------------------------------ unset the experiment name
    
    $fre->unsetCurrentExperimentName();

  }
  
  exit $status;

}
