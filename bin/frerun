#!/usr/bin/perl
# -*- cperl -*-
#
# $Id: frerun,v 18.0.2.9.2.1 2010/07/09 23:41:15 fms Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to Create a Script to Run a Model
# ------------------------------------------------------------------------------
# arl    Ver  18.00  Merged revision 17.0.4.21 onto trunk           March 10
# afy -------------- Branch 18.0.2 -------------------------------- March 10
# afy    Ver   1.00  Modify Help subroutine (list targets)          March 10
# afy    Ver   1.01  Add --archive option                           March 10
# afy    Ver   1.02  Modify init (set flagArchive)                  March 10
# afy    Ver   1.03  Modify init (no staged combining for reg.)     March 10
# afy    Ver   2.00  Modify Help subroutine again (list targets)    April 10
# afy    Ver   2.01  Modify Usage subroutine (reorder, attributes)  April 10
# afy    Ver   2.02  Add shorter option names                       April 10
# afy    Ver   2.03  Add option --validate                          April 10
# afy    Ver   2.04  Check for experiment names separately          April 10
# afy    Ver   2.05  Modify init (don't set FREROOT)                April 10
# afy    Ver   2.06  Modify init (set flagOutputType)               April 10
# afy    Ver   2.07  Modify init (set flagOutputPostProcess)        April 10
# afy    Ver   2.08  Modify setProductionOutputDirectory (no frepp) April 10
# afy    Ver   2.09  Modify outputRegressionScript (no frepp)       April 10
# afy    Ver   2.10  Modify init (offline + unique => online)       April 10
# afy    Ver   2.11  Add option --execute                           April 10
# afy    Ver   3.00  Remove option --build                          May 10
# afy    Ver   3.01  Add (modified) execName subroutine             May 10
# afy    Ver   3.02  Modify init (don't set siteDir/flagRemake)     May 10
# afy    Ver   3.03  Modify init (set freCommandsHomeDir)           May 10
# afy    Ver   3.04  Add baseDate subroutine                        May 10
# afy    Ver   3.05  Modify setTables subroutine (use setBaseDate)  May 10
# afy    Ver   4.00  Modify init (use new FRE.pm)                   May 10
# afy    Ver   5.00  Add --target option alias 't'                  June 10
# afy    Ver   6.00  Use new FREDefaults.pm to return status        June 10
# afy    Ver   6.01  Force if/elsif/else tree design                June 10
# afy    Ver   6.02  Modify setProductionParameters subroutine      June 10
# afy    Ver   6.03  Modify outputScriptExecuteOrSubmit subroutine  June 10
# afy    Ver   6.04  Add pathname-returning subroutines             June 10
# afy    Ver   6.05  Standardize skipExp subroutine                 June 10
# afy    Ver   6.06  Modify init (default getFmsData)               June 10
# afy    Ver   6.07  Add calendarType subroutine                    June 10
# afy    Ver   6.08  Modify setNamelists (set timeStampFormat)      June 10
# afy    Ver   7.00  Add option --submit-staged	                    June 10
# afy    Ver   7.01  Add option --npes (for staging only)           June 10
# afy    Ver   7.02  Add option --walltime (for staging only)       June 10
# afy    Ver   7.03  Modify init (change ptmpDir/hsmDir settings)   June 10
# afy    Ver   7.04  Modify outputScriptExecuteOrSubmit (staging)   June 10
# afy    Ver   8.00  Modify outputScriptInputDir (use properties)   June 10
# afy    Ver   8.01  Modify outputScriptJobId (use properties)      June 10
# afy    Ver   9.00  Modify setMPI (use new FREDefaults.pm)         July 10
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2010
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use Cwd();
use File::Basename();
use File::Spec();
use Getopt::Long(':config', 'no_ignore_case');
use POSIX();

use FRE();
use FREDefaults();
use FREExperiment();
use FREMsg();
use FRETargets();
use FRETemplate();
use FREUtil();

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////// Global constants //
# //////////////////////////////////////////////////////////////////////////////

{

  package frerun;

  use constant VERSION => '$Id: frerun,v 18.0.2.9.2.1 2010/07/09 23:41:15 fms Exp $';

  use constant OPTLIST =>
  (
    'archive!',
    'combine-history!',
    'debug=s',
    'extend|ext',
    'logging!',
    'namelist',
    'overwrite',
    'regression=s',
    'submit-staged|ss',
    'transfer-ascii|ta',
    'transfer-restart|tr',
    'unique',
    'execute|e',
    'help',
    'npes=i',
    'platform=s',
    'validate|S',
    'submit|s',
    'target|t=s',
    'Version',
    'verbose|v+',
    'walltime=i',
    'xmlfile=s'
  );
  
  use constant PRAGMA_PREFIX => '#FRE';
  use constant PRAGMA_SETUP_PLATFORM_CSH => 'setup-platform-csh';
  use constant PRAGMA_EXPERIMENT_RUNTIME_CSH => 'experiment-runtime-csh';
  use constant PRAGMA_EXPERIMENT_INPUT_CSH_INIT => 'experiment-input-csh-init';
  use constant PRAGMA_EXPERIMENT_INPUT_CSH_ALWAYS_OR_POSTINIT => 'experiment-input-csh-always-or-postinit';
  use constant PRAGMA_EXPERIMENT_POSTPROCESS_CSH => 'experiment-postprocess-csh';

  use constant RUNSCRIPT_TEMPLATE_MAIN => 'runscript.template.main';

  use constant REGRESSION_SUITE => ('basic', 'restarts', 'scaling');
  
  use constant NPES_DEFAULT => 2;
  use constant WALLTIME_DEFAULT => 30;

}

# //////////////////////////////////////////////////////////////////////////////
# ///////////////////////////////////////////////////////////////// Utilities //
# //////////////////////////////////////////////////////////////////////////////

{

  package frerun;

  my $self = File::Basename::basename($0);

  sub Usage()
  # ------ arguments: none
  {
    my $cwd = Cwd::getcwd();
    my $xml = FREDefaults::XMLFile();
    my $pfm = FREDefaults::Platform();
    my $tgt = FREDefaults::Target();
    my $nps = frerun::NPES_DEFAULT;
    my $wtm = frerun::WALLTIME_DEFAULT;
    my $beg = "\e[0;4m";
    my $end = "\e[m";
    return
    (
      "\n",
      "  Usage: $self [options] experiment [experiment ...]\n\n",
      "  Options:\n\n",
      "   -a,        --archive            save model output in the ${beg}a${end}rchive (negatable, default is on)\n",
      "   -c,        --combine-history    ${beg}c${end}ombine history files after each segment run (negatable, default is on)\n",
      "   -d STRING, --debug=STRING       run in ${beg}d${end}ebug mode STRING (possible values are totalview|setup)\n",
      "   -ext,      --extend             ${beg}ext${end}end default run of existing experiment\n",
      "   -l,        --logging            enable batch system ${beg}l${end}ogging (negatable, default is on)\n",
      "   -n,        --namelist           print all the ${beg}n${end}amelists with all substitutions and overrides\n", 
      "   -o,        --overwrite          ${beg}o${end}verwrite default run of existing experiment\n", 
      "   -r STRING, --regression=STRING  run in ${beg}r${end}egression test mode STRING with minimal output processing\n",
      "   -ss,       --submit-staged      ${beg}s${end}ubmit all the created scripts as batch jobs with input data ${beg}s${end}taging\n",
      "   -ta,       --transfer-ascii     ${beg}t${end}ransfer ${beg}a${end}scii files to GFDL (default is off)\n",
      "   -tr,       --transfer-restart   ${beg}t${end}ransfer ${beg}r${end}estart files to GFDL (default is off)\n",
      "   -u,        --unique             create new ${beg}u${end}nique run of existing experiment\n\n", 
      "   -e,        --execute            ${beg}e${end}xecute all the created scripts in the current session\n", 
      "   -h,        --help               print ${beg}h${end}elp message and exit\n",
      "   -n NUM,    --npes=NUM           ${beg}n${end}umber of processors to use for input data staging (default is $nps)\n",
      "   -p STRING, --platform=STRING    hardware and software ${beg}p${end}latform STRING (default is '$pfm')\n", 
      "   -S,        --validate           validate the FILE against the ${beg}s${end}chema before processing\n",
      "   -s,        --submit             ${beg}s${end}ubmit all the created scripts as batch jobs\n",
      "   -t STRING, --target=STRING      use compilation directives, ${beg}t${end}argeted by STRING (default is '$tgt')\n", 
      "   -V,        --Version            print the tool ${beg}v${end}ersion and exit\n",
      "   -v,        --verbose            get ${beg}v${end}erbose messages (repeat the option to increase verbosity level)\n", 
      "   -w NUM,    --walltime=NUM       maximum ${beg}w${end}all time (in minutes) to use for input data staging (default is $wtm)\n", 
      "   -x FILE,   --xmlfile=FILE       experiment suite ${beg}X${end}ML configuration FILE (default is '$cwd/$xml')\n\n", 
      "  All the option names may be abbreviated, a single leading dash is also acceptable.\n",
      "  At least one experiment from the FILE must be listed as an argument.\n\n"
    );
  }
  
  sub Help()
  # ------ arguments: none
  {
    my @usage = frerun::Usage();
    my $tgts = join("', '", FRETargets::all());
    my $tgst = join("', '", FRETargets::starters());
    return
    (
      "\n",
      "   Synopsis: $self creates a C-shell script to run FRE experiment(s).\n",
      "@usage",
      "   Use --noarchive to disallow saving model output into archive (valid for regression tests only).\n",
      "      The (unpacked) model output will be kept in the disk cache (ptmp) only.\n",
      "   Use --nocombine-history to disallow combining history files (valid for regression tests only).\n",
      "      This option is on by default, so history files will be combined after each segment run.\n",
      "      (The type of history combining is defined by an attribute 'combine' in the <postProcess> node)\n",
      "   Use --overwrite, --extend or --unique to manipulate the experiment output directory.\n",
      "      You can completely overwrite the output directory, you can extend the run of the same experiment,\n",
      "      or you can create another unique instance of the output directory for the same experiment.\n", 
      "   Use --regression to run a regression test instead of the <production> run.\n", 
      "      Regression tests have minimal treatment of output files.\n",
      "   Use --submit-staged to automatically submit all the created scripts in the input data staging mode.\n",
      "      The same script is submitted twice with different parameters, so it works as the input data stager at first,\n",
      "      then it works normally with input data, prepared by the stager.\n",  
      "   Use --platform to pick a platform for experiment(s).\n", 
      "      The <platform> node in the experiment suite configuration file is used\n", 
      "      to set platform-specific data and instructions.\n",
      "   Use --target to define compilation and linkage directives for experiment(s).\n",
      "      Predefined targets refer to groups of directives, existing in the 'mkmf' template file.\n",
      "      Possible predefined targets are: '$tgts'.\n",
      "      Any number of targets from this list can be used here, and you can also add your own target (but not more than one).\n",
      "      Targets '$tgst' are mutually exclusive - not more than one of them is allowed in the target list.\n",
      "      Your own target should refer to a <compile> node with the corresponding value of its 'target' attribute.\n", 
      "      Multiple targets are separated by comma or dash. All the directives, referred by multiple targets, are merged.\n", 
      "   Use --execute to run the created script right away.\n",
      "      If the target platform is not where $self is being run, do not specify --execute.\n", 
      "      Submit as a batch job or run by hand on the right platform.\n",
      "   Use --submit to automatically submit all the created scripts.\n\n"
    );
  }

  sub regressionRunScriptName($$)
  # ------ arguments: $exp $extension
  {
    my ($z, $x) = @_;
    my ($expName, $scriptsDir) = ($z->name(), $z->scriptsDir());
    return "$scriptsDir/run/${expName}_$x"; 
  }

  sub productionRunScriptName($$)
  # ------ arguments: $exp $extension
  {
    my ($z, $x) = @_;
    my ($expName, $scriptsDir) = ($z->name(), $z->scriptsDir());
    return "$scriptsDir/run/$expName$x"; 
  }

  sub stdoutName($$)
  # ------ arguments: $exp $scriptName
  {
    my ($z, $n) = @_;
    my ($basename, $stdoutDir, $jobId) = (File::Basename::basename($n), $z->stdoutDir(), FREUtil::jobID());
    return "$stdoutDir/run/$basename.o$jobId";
  }

  sub createDirectory($$$)
  # ------ arguments: $fre $directory $verbose
  # ------ create a directory 
  {
    my ($fre, $d, $v) = @_;
    if (-d $d)
    {
      if (-w $d)
      {
        return 1;
      }
      else
      {
        $fre->out(0, "The directory '$d' exists, but it's not writable");
	return 0;
      }
    }
    elsif ($d =~ m/^\/work/)
    {
      unless (FREUtil::execute('ac-work', "mkdir -p $d"))
      {
        $fre->out(2, "createDir: $d");
	return 1;
      }
      else
      {
        $fre->out(0, "The directory '$d' can't be created");
	return 0;
      }
    }
    elsif ($d =~ m/^\/archive/)
    {
      unless (FREUtil::execute('ac-arch', "mkdir -p $d"))
      {
        $fre->out(2, "createDir: $d");
	return 1;
      }
      else
      {
        $fre->out(0, "The directory '$d' can't be created");
	return 0;
      }
    }
    else
    {
      return FREUtil::createDir($d, $v);
    }
  }

  sub getTemplate($$)
  # ------ arguments: $fre $filename
  # ------ returns a script template from the site directory
  # ------ return ($sript, $status)
  {
    my ($fre, $n) = @_;
    my $pathname = $fre->siteDir() . '/' . $n;
    if (open my $templateHandle, '<', $pathname)
    {
      $/ = undef;
      my $s = <$templateHandle>;
      $s =~ s/^# .*$//mg;
      $s =~ s/\n{2,}/\n\n/sg;
      close $templateHandle;
      return ($s, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(0, "The main runscript template '$pathname' isn't found");
      return (0, FREDefaults::STATUS_FRE_RUN_NO_TEMPLATE);
    }
  }

  sub execName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my ($value, $exp) = $z->extractExecutable();
    if ($value)
    {
      return $value;
    }
    else
    {
      my ($execDir, $name) = ($exp->execDir(), $exp->name());
      return "$execDir/fms_$name.x";
    }
  }

  sub init($%)
  # ------ arguments: $exp %options
  # ------ return ($sript, $status)
  {

    my ($z, %o) = @_;
    my ($fre, $expName) = ($z->fre(), $z->name());
    
    my ($s, $status) = frerun::getTemplate($fre, frerun::RUNSCRIPT_TEMPLATE_MAIN);
    if ($s)
    {

      $s =~ s/set name/set -r name = $expName/;

      my $absPath = $fre->configFileAbsPathName();
      $s =~ s/set rtsxml/set -r rtsxml = $absPath/;

      my $freCommandsHomeDir = FRE::home();
      $s =~ s/set freCommandsHomeDir/set -r freCommandsHomeDir = $freCommandsHomeDir/;

      my $workDir = $z->workDir();
      $s =~ s/set workDir/set -r workDir = $workDir/;

      my $ptmpDir = $z->ptmpDir();
      $s =~ s/set ptmpDir/set ptmpDir = $ptmpDir/;

      my $archiveDir = $z->archiveDir();
      $s =~ s/set archiveDir/set -r archiveDir = $archiveDir/;

      my $execName = frerun::execName($z);
      $s =~ s/set executable/set -r executable = $execName/;

      if (-f $execName and -x $execName)
      {
	$fre->out(2, "Using executable '$execName'...");
      }
      else
      {
	$fre->out(1, "Your executable '$execName' doesn't exist or has wrong permissions");
      }

      my $flagLogging = ($o{logging}) ? 'On' : 'Off';
      $s =~ s/set flagLogging/set -r flagLogging$flagLogging/;

      my $flagOutputType = ($o{extend}) ? 'Extend' : (($o{overwrite}) ? 'Overwrite' : (($o{unique}) ? 'Unique' : 'Initial'));
      $s =~ s/set flagOutputType/set -r flagOutputType$flagOutputType/;

      my $flagOutputFormat = (FRETargets::containsHDF5($fre->target())) ? 'HDF5' : '64Bit';
      $s =~ s/set flagOutputFormat/set -r flagOutputFormat$flagOutputFormat/;

      my $postProcessCombine = $z->extractValue('postProcess/@combine');
      my $flagOutputCombineType;

      if (!$postProcessCombine or $postProcessCombine eq 'online')
      {
	$flagOutputCombineType = 'Online';
      }
      elsif ($o{regression})
      {
	$flagOutputCombineType = 'Online';  
	$fre->out(1, "Wrong history combine type '$postProcessCombine' - ignored...");
      }
      elsif ($postProcessCombine eq 'offline' and !$o{unique})
      {
	$flagOutputCombineType = 'Offline';
      }
      elsif ($postProcessCombine eq 'offline' and $o{unique})
      {
	$flagOutputCombineType = 'Online';
	$fre->out(1, "Offline history combining can't be used for dual runs - using online combining...");
      }
      elsif ($postProcessCombine eq 'staged')
      {
	$flagOutputCombineType = 'Staged';
      }
      elsif ($postProcessCombine eq 'bySegment')
      {
	$flagOutputCombineType = 'BySegment';
      }
      else
      {
	$flagOutputCombineType = 'Online';
	$fre->out(1, "Wrong history combine type '$postProcessCombine' - ignored...");
      }

      my $flagOutputCombine = ($o{'combine-history'}) ? 'On' : 'Off';
      if ($flagOutputCombine eq 'Off' and !$o{regression})
      {
	$flagOutputCombine = 'On';
	$fre->out(1, "You can use the --nocombine-history option for regression tests only - ignored...");
      }

      if ($flagOutputCombine eq 'On')
      {
	if ($flagOutputCombineType eq 'Online')
	{
	  $fre->out(2, "Using online history combining...");
	}
	elsif ($flagOutputCombineType eq 'Offline')
	{
	  $fre->out(2, "Using offline history combining (by frepp)...");
	}
	elsif ($flagOutputCombineType eq 'Staged')
	{
	  $fre->out(2, "Using staged history combining (by frusavehist)...");
	}
	elsif ($flagOutputCombineType eq 'BySegment')
	{
	  $fre->out(2, "Using history combining by segment (by frusavehist)...");
	}
      }
      else
      {
	$fre->out(2, "History won't be combined...");
      }

      $s =~ s/set flagOutputCombineType/set -r flagOutputCombineType$flagOutputCombineType/;
      $s =~ s/set flagOutputCombine/set -r flagOutputCombine$flagOutputCombine/;

      my $flagOutputArchive = ($o{archive}) ? 'On' : 'Off';
      if ($flagOutputArchive eq 'Off')
      {
	if ($o{regression})
	{
          $fre->out(2, "The model output will be kept in the disk cache only...");
	}
	else
	{
          $flagOutputArchive = 'On';
          $fre->out(1, "You can use the --noarchive option for regression tests only - ignored...");
	}
      }
      $s =~ s/set flagOutputArchive/set -r flagOutputArchive$flagOutputArchive/;

      my $flagOutputPostProcess = (!$o{regression} && !$o{unique}) ? "On" : "Off";
      $s =~ s/set flagOutputPostProcess/set -r flagOutputPostProcess$flagOutputPostProcess/;

      my $flagTransferAscii = ($o{'transfer-ascii'}) ? 'On' : 'Off';
      $s =~ s/set flagTransferAscii/set -r flagTransferAscii$flagTransferAscii/;

      my $flagTransferRestart = ($o{'transfer-restart'}) ? 'On' : 'Off';
      $s =~ s/set flagTransferRestart/set -r flagTransferRestart$flagTransferRestart/;

      my @ppRefineDiagScriptNames = $z->extractPPRefineDiagScripts();
      my $ppRefineDiagScriptNamesString = join(' ', @ppRefineDiagScriptNames);
      $s =~ s/set ppRefineDiagScriptNames/set -r ppRefineDiagScriptNames = ( $ppRefineDiagScriptNamesString )/;
      
      my $getFmsData = $fre->getFmsData() || '$freCommandsHomeDir/bin/get_fms_data';
      my $fmsRelease = $fre->fmsRelease();
      if ($fmsRelease)
      {
	$s =~ s/set getFmsData/set -r getFmsData = ( $getFmsData -r $fmsRelease )/;
      }
      else
      {
	$s =~ s/set getFmsData/set -r getFmsData = $getFmsData/;
      }

      return ($s, FREDefaults::STATUS_OK);

    }
    else
    {
    
      return (0, $status);
      
    }

  }

  sub prepareInputFile($$$)
  # ------ arguments: $exp $source $target
  # ------ internal helper to setup an input file
  # ------ return ($sript, $status)
  {

    my ($z, $s, $t) = @_;
    my $fre= $z->fre();

    if (File::Spec->file_name_is_absolute($s))
    {

      if (!File::Spec->file_name_is_absolute($t))
      {

	my $csh = '';

        my $sName = substr($s, 1);
	my $sArchiveFlag = FREUtil::fileIsArchive($s);
	$sName = FREUtil::fileArchiveExtensionStrip($sName) if $sArchiveFlag;

	my ($tFileName, $tDirName) = File::Basename::fileparse($t);
	my $tDirectoryFlag = ($tDirName ne './');
	
	if ($sArchiveFlag and $tDirectoryFlag and !$tFileName)
	{
	  $csh .= 'hsmget ' . $sName . '/\* && \\' . "\n";
          $csh .= 'if (! -d $workDir/' . $tDirName . ') mkdir -p $workDir/' . $tDirName . ' && \\' . "\n";
	  $csh .= 'ls $hsmDir/' . $sName . '/* | xargs ln -f -t $workDir/' . $tDirName . "\n";
	}
	elsif ($sArchiveFlag and $tFileName)
	{
	  $fre->out(0, "The source archive '$s' can't be linked to the non-directory target '$t'");
	  return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
	}
	elsif (!$sArchiveFlag and ($tDirectoryFlag or $tFileName))
	{
	  $csh .= 'hsmget ' . $sName . ' && \\' . "\n";
          $csh .= 'if (! -d $workDir/' . $tDirName . ') mkdir -p $workDir/' . $tDirName . ' && \\' . "\n" if $tDirectoryFlag;
	  $csh .= 'ln -f $hsmDir/' . $sName . ' $workDir/' . $tDirName . (($tFileName) ? $tFileName : '.') . "\n";
	}
	else
	{
	  $fre->out(0, "The target pathname is empty");
	  return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
	}

	if ($csh)
	{
	  $csh .= 'if ( $status != 0 ) then' . "\n";
	  $csh .= '  set dataFilesNotOK = ( $dataFilesNotOK ' . $s . ' )' . "\n";
	  $csh .= 'endif' . "\n";
	}

	return ($csh, FREDefaults::STATUS_OK);
	  
      }
      else
      {
	$fre->out(0, "The target pathname '$t' isn't relative");
	return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
      }
    }
    else
    {
      $fre->out(0, "The source pathname '$s' isn't absolute");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

  }

  sub setInputVariableFile($$$)
  # ------ arguments: $script $exp $variableName
  # ------ internal helper to setup an input file, defined via a shell variable
  {

    my ($s, $z, $n) = @_;
    my ($fre, $fileName) = ($z->fre(), $z->extractVariableFile($n));

    if ($fileName)
    {
      $fre->out(2, "name=$n value=$fileName");
      $s =~ s/set $n/set $n = $fileName/;
    }
    else
    {
      $fre->out(1, "Variable $n has no value");
      $s =~ s/set $n/set $n = ''/;
    }

    return $s;

  }

  sub setInputInitialConditions($$)
  # ------ arguments: $script $exp
  {
    my ($s, $z) = @_;
    return frerun::setInputVariableFile($s, $z, 'initCond');
  }

  sub setInputGridSpecification($$)
  # ------ arguments: $script $exp
  {
    my ($s, $z) = @_;
    return frerun::setInputVariableFile($s, $z, 'gridSpec');
  }

  sub setInputDatasets($$)
  # ------ arguments: $script $exp
  # ------ return ($sript, $status)
  {

    my ($s, $z) = @_;
    my ($fre, @results) = ($z->fre(), $z->extractDatasets());
    my $dataSets;
    my $csh;

    while (scalar(@results) > 0)
    {
      my $source = shift @results;
      my $target = shift @results;
      if ($source =~ m/\//)
      {
	my ($cshSnippet, $status) = frerun::prepareInputFile($z, $source, $target);
	if ($cshSnippet)
	{
          $csh .= $cshSnippet . "\n";
	}
	else
	{
	  $fre->out(0, "The pathname '$source' can't be setup in the runscript");
	  return (0, $status);
	}
      }
      else
      {
        $dataSets .= ' ' . $source;
      }
    }

    if ($dataSets)
    {
      $fre->out(1, "The usage of 'get_fms_data' datasets is deprecated - please list your input files explicitly in the XML file");
      $s =~ s/#fmsDataSets_from_xml/get_fms_data$dataSets/;
    }
    else
    {
      $s =~ s/#fmsDataSets_from_xml//;
    }
    
    $s =~ s/#dataFiles_from_xml/$csh/;

    return ($s, FREDefaults::STATUS_OK);

  }

  sub setShellCommands($$)
  # ------ arguments: $script $exp
  {
  
    my ($s, $z) = @_;

    my %adjustment =
    (
      init	=> ['if ( $irun == 1 && $ireload == 1 ) then'."\n", "\n".'endif'."\n"],
      postInit	=> ['if ( $irun != 1 || $ireload != 1 ) then'."\n", "\n".'endif'."\n"]
    );
    
    my $expand = sub($$)
    {
      my ($k, $v) = @_;
      my $prefix = frerun::PRAGMA_PREFIX;
      my $placeholder = qr/^[ \t]*$prefix[ \t]+$k[ \t]*$/m;
      chomp ($v);
      $s =~ s/$placeholder/$v/;
    };

    $expand->(frerun::PRAGMA_SETUP_PLATFORM_CSH, $z->fre()->platformValue('csh'));
    $expand->(frerun::PRAGMA_EXPERIMENT_RUNTIME_CSH, $z->extractShellCommands('runtime/csh'));
    $expand->(frerun::PRAGMA_EXPERIMENT_INPUT_CSH_INIT, $z->extractShellCommands('input/csh[not(@type="always") and not(@type="postInit")]', %adjustment));
    $expand->(frerun::PRAGMA_EXPERIMENT_INPUT_CSH_ALWAYS_OR_POSTINIT, $z->extractShellCommands('input/csh[@type="always" or @type="postInit"]', %adjustment));
    $expand->(frerun::PRAGMA_EXPERIMENT_POSTPROCESS_CSH, $z->extractShellCommands('postProcess/csh'));
    
    return $s;
    
  }

  sub calendarType($)
  # ------ arguments: $refToHash
  {
    my $r = shift;
    my $calendarType;
    foreach my $key (sort keys %{$r})
    {
      my $value = $r->{$key};
      $value =~ s/^\s*!.*$//mg;
      if ($value =~ m/calendar\s*=\s*(?:'(.*)'|"(.*)")/m)
      {
        $calendarType = $1;
	last;
      }
    }
    return $calendarType;
  }

  sub baseDate($)
  # ------ arguments: $namelist
  {
    my $l = shift;
    my $baseDate = ($l =~ m/current_date\s*=\s*(\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+)/s) ? $1 : '0,0,0,0,0,0';
    $baseDate =~ s/,/ /g;
    return $baseDate;
  }

  sub setTables($$$)
  # ------ arguments: $script $exp $namelist
  # ------ return ($sript, $status)
  {
  
    my ($s, $z, $l) = @_;
    my $fre = $z->fre();
    $l =~ s/^\s*!.*$//mg;
    
    $fre->out(2, "Extracting tables...");

    # --------------------------------------------------------------------- dataTable
    
    my $dataTable = $z->extractTable('dataTable');
    if ($dataTable != -1)
    {
      $dataTable = "cat >> data_table <<EOF\n$dataTable\nEOF\n" if $dataTable;
      $s =~ s/#dataTable_from_xml/$dataTable/;
    }
    else
    {
      $fre->out(0, "A problem with the data table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------------- fieldTable

    my $fieldTable = $z->extractTable('fieldTable');
    if ($fieldTable != -1)
    {
      if ($l)
      {
	if ($fieldTable !~ /^\s*"TRACER"\s*,\s*"atmos_mod"\s*,\s*"sphum".*/im)
	{
          $fieldTable .= '# added by FRE: sphum must be present in atmos' . "\n";
	  $fieldTable .= ' "TRACER", "atmos_mod",    "sphum"' . "\n";
	  $fieldTable .= '           "longname",     "specific humidity"' . "\n";
	  $fieldTable .= '           "units",        "kg/kg" /'. "\n";
	}
	if ($fieldTable !~ /^\s*"TRACER"\s*,\s*"land_mod"\s*,\s*"sphum".*/im)
	{
          $fieldTable .= '# added by FRE: sphum must be present on land' . "\n";
	  $fieldTable .= ' "TRACER", "land_mod",     "sphum"' . "\n";
	  $fieldTable .= '           "longname",     "specific humidity"' . "\n";
	  $fieldTable .= '           "units",        "kg/kg" /' . "\n";
	}
      }
      $fieldTable = "cat >> field_table <<EOF\n$fieldTable\nEOF\n" if $fieldTable; 
      $s =~ s/#fieldTable_from_xml/$fieldTable/;
    }
    else
    {
      $fre->out(0, "A problem with the field table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------------------- diagTable
    
    my $diagTable = $z->extractTable('diagTable');
    if ($diagTable != -1)
    {
      my $baseDate = frerun::baseDate($l);
      $s =~ s/set baseDate/set -r baseDate = '$baseDate'/;
      $diagTable =~ s/^\s*\$baseDate\s*$/$baseDate/m;
      $diagTable = "cat >> diag_table <<EOF\n$diagTable\nEOF\n" if $diagTable; 
      $s =~ s/#diagTable_from_xml/$diagTable/;
    }
    else
    {
      $fre->out(0, "A problem with the diagnostic table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # ------------------------------------------------------------------------ tracerTreeTable
    
    my $tracerTreeTable = $z->extractTable('tracerTreeTable');
    if ($tracerTreeTable != -1)
    {
      $tracerTreeTable = "cat >> ocean_tracer_tree <<EOF\n$tracerTreeTable\nEOF\n" if $tracerTreeTable;
      $s =~ s/#tracerTreeTable_from_xml/$tracerTreeTable/;
    }
    else
    {
      $fre->out(0, "A problem with the tracer tree table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------- tracerTreeInit
    
    my $tracerTreeInit = $z->extractTable('tracerTreeInit');
    if ($tracerTreeInit != -1)
    {
      $tracerTreeInit = "cat >> ocean_tracer_tree_init <<EOF\n$tracerTreeInit\nEOF\n" if $tracerTreeInit;
      $s =~ s/#tracerTreeInit_from_xml/$tracerTreeInit/;
    }
    else
    {
      $fre->out(0, "A problem with the tracer tree initialization");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # ------------------- normal return
    
    return ($s, FREDefaults::STATUS_OK);

  }

  sub extractRegressionTimingParameters($$)
  # ------ arguments: $exp $runNode
  {

    my ($z, $n) = @_;

    # -------------------------------------------- extract parameter values

    my $ml = $z->nodeValue($n, '@months') || '0';
    my $dl = $z->nodeValue($n, '@days') || '0';
    my $hl = $z->nodeValue($n, '@hours');

    # ------------------------------------------------ adjust months/days/hours lists 

    my @ma = split(' ', $ml);
    my @da = split(' ', $dl);
    my @ha = split(' ', $hl);

    my $nr = (@ma gt @da) ? ((@ma gt @ha) ? @ma : @ha) : ((@da gt @ha) ? @da : @ha);

    while (@ma < $nr) {push(@ma, '0');}
    while (@da < $nr) {push(@da, '0');}
    while (@ha < $nr) {push(@ha, '0');}

    $ml = join(' ', @ma);
    $dl = join(' ', @da);
    $hl = join(' ', @ha) if $hl;
    
    # ------------------------ return three lists
    
    return ($ml, $dl, $hl); 

  }

  sub setRegressionParameters($$$$$$%)
  # ------ arguments: $script $exp $runNode $monthslist $dayslist $hourslist %options
  # ------ return ($sript, $extension, $status)
  {

    my ($s, $z, $n, $m, $d, $h, %o) = @_;

    my ($fre, $stdoutDir) = ($z->fre(), $z->stdoutDir() . '/run');
    if (frerun::createDirectory($fre, $stdoutDir, $o{verbose}))
    {

      # -------------------------------------------- extract parameter values

      my $np = $z->nodeValue($n, '@npes');
      my $rt = $z->nodeValue($n, '@runTimePerJob');

      # ------------------------------------------------------------ set parameters in the script

      my $nr = scalar(split(' ', $m));

      $s =~ s/set stdoutDir/set -r stdoutDir = $stdoutDir/;
      $s =~ s/set flagRunType/set -r flagRunTypeRegression/;
      $s =~ s/set npes/set -r npes = $np/;
      $s =~ s/set segmentsPerSimulation/set -r segmentsPerSimulation = $nr/;
      $s =~ s/set segmentsPerJob/set -r segmentsPerJob = $nr/;
      $s =~ s/set jobsPerSimulation/set -r jobsPerSimulation = 1/;
      $s =~ s/set monthslist/set -r monthslist = ( $m )/;
      $s =~ s/set dayslist/set -r dayslist = ( $d )/;
      $s =~ s/set combineFreq/set -r combineFreq = $nr/;

      if ($h)
      {
	$s =~ s/( *)(set -r dayslist = .+)/$1$2\n$1set -r hourslist = ( $h )/;
	$s =~ s/( *)(set days = .+)/$1$2\n$1set hours = \$hourslist[\$irun]/;
	$s =~ s/time_stamp -bf digital/time_stamp -bhf digital/;
	$s =~ s/time_stamp -ef digital/time_stamp -ehf digital/;
      } 

      # ----------------------------------------------------- set scheduler options

      $s = FRETemplate::setSchedulerOptions($s, $z, $np, $rt, $rt, $stdoutDir, %o);

      # ---------------------------------------------- generate extension string

      my $m0 = (split(' ', $m))[0];
      my $d0 = (split(' ', $d))[0];
      my $h0 = (split(' ', $h))[0];

      my $x =
      (
	($h)
	?
	$nr . 'x' . $m0 . 'm' . $d0 . 'd' . $h0 . 'h_' . $np . 'pe'
	:
	$nr . 'x' . $m0 . 'm' . $d0 . 'd_' . $np . 'pe'
      );

      # ----------------------------------------- return result

      return ($s, $x, FREDefaults::STATUS_OK);

    }
    else
    {
      $fre->out(0, "Unable to create the stdout directory '$stdoutDir'!");
      return (0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }    

  }
  
  sub setProductionParameters($$%)
  # ------ arguments: $script $exp %options
  # ------ return ($sript, $extension, $status)
  {

    my ($s, $z, %o) = @_;
    my ($fre, $stdoutDir) = ($z->fre(), $z->stdoutDir() . '/run');

    if (frerun::createDirectory($fre, $stdoutDir, $o{verbose}))
    {
      # --------------------------------------- extract timing parameters
      my $np	     = $z->extractValue('runtime/production/@npes');
      my $simTime    = $z->extractValue('runtime/production/@simTime');
      my $simUnits   = $z->extractValue('runtime/production/@units');
      my $simRunTime = $z->extractValue('runtime/production/@runTime') || $fre->runTime($np);
      my $segTime    = $z->extractValue('runtime/production/segment/@simTime');
      my $segUnits   = $z->extractValue('runtime/production/segment/@units');
      my $segRunTime = $z->extractValue('runtime/production/segment/@runTime');
      # ------------------------------------------------------ check and adjust simulation/segment model time
      if ($np > 0)
      {
        my $patternUnits = qr/^(?:years|year|months|month)$/;
	if (($simTime > 0) and ($simUnits =~ m/$patternUnits/))
	{
          if (($segTime > 0) and ($segUnits =~ m/$patternUnits/))
	  {
	    my $patternYears = qr/^(?:years|year)$/;
	    $simTime *= 12 if $simUnits =~ m/$patternYears/;
	    $segTime *= 12 if $segUnits =~ m/$patternYears/;
	    if ($segTime <= $simTime)
	    {
	      my $patternRunTime = qr/^\d\d:\d\d:\d\d$/;
	      if ($simRunTime =~ m/$patternRunTime/)
	      {
		if ($segRunTime =~ m/$patternRunTime/)
		{
		  my ($simRunTimeMinutes, $segRunTimeMinutes) = (FREUtil::makeminutes($simRunTime), FREUtil::makeminutes($segRunTime));
		  if ($segRunTimeMinutes <= $simRunTimeMinutes)
		  {
		    # ---------------------------------------------------------------------------- print original values
		    $fre->out(2, "simTime = $simTime months, segTime = $segTime months");
		    $fre->out(2, "simRunTimeMin = $simRunTimeMinutes minutes, segRunTimeMin = $segRunTimeMinutes minutes");
		    # --------------------------------------------------------------------------------- calculate major timing parameters
		    my $segPerSim = POSIX::ceil($simTime / $segTime);
		    $fre->out(2, "segPerSim ($segPerSim) = simTime ($simTime) / segTime ($segTime) (rounded up)");
		    my $segPerJob = POSIX::floor($simRunTimeMinutes / $segRunTimeMinutes);
		    $fre->out(2, "segPerJob ($segPerJob) = simRunTimeMin ($simRunTimeMinutes) / segRunTimeMin ($segRunTimeMinutes) (rounded down)");
		    my $jobPerSim = POSIX::ceil($segPerSim / $segPerJob);  
		    $fre->out(2, "jobPerSim ($jobPerSim) = segPerSim ($segPerSim) / segPerJob ($segPerJob) (rounded up)");
		    # ------------------------------------------------------------------------------------------------ create months/days lists
		    my @ma = ();
		    while (@ma < $segPerJob) {push(@ma, $segTime);}
		    my $ml = join(' ', @ma);
		    my @da = (); 
		    while (@da < $segPerJob) {push(@da, '0');}
		    my $dl = join(' ', @da);
		    # ----------------------------------------------------------------------------------------------- calculate combining frequency 
		    my $combineFreq = 1;
		    if ($segTime < 12 and 12 <= $simTime)
		    {
		      if (12 % $segTime == 0)
		      {
        		$combineFreq = 12 / $segTime;
		      }
		      else
		      {
        		$fre->out(1, "The segment length ($segTime months) is not divisor of 12 - the postprocessor will combine output only");
        		$combineFreq = $segTime;
		      }
		    }
		    elsif (12 > $simTime)
		    {
		      $fre->out(1, "The production run length ($simTime months) < 1 year - the postprocessor will combine output only");
		    }
		    elsif ($segTime % 12 != 0)
		    {
		      $fre->out(1, "The segment length ($segTime months) is not divisible by 12 - the postprocessor will combine output only");
		    }
		    # ------------------------------------------------------------------------------------------ set parameters in the script
		    $s =~ s/set stdoutDir/set -r stdoutDir = $stdoutDir/;
		    $s =~ s/set flagRunType/set -r flagRunTypeProduction/;
		    $s =~ s/set npes/set -r npes = $np/;
		    $s =~ s/set segmentsPerSimulation/set -r segmentsPerSimulation = $segPerSim/;
		    $s =~ s/set segmentsPerJob/set -r segmentsPerJob = $segPerJob/;
		    $s =~ s/set jobsPerSimulation/set -r jobsPerSimulation = $jobPerSim/;
		    $s =~ s/set monthslist/set -r monthslist = ( $ml )/;
		    $s =~ s/set dayslist/set -r dayslist = ( $dl )/;
		    $s =~ s/set combineFreq/set -r combineFreq = $combineFreq/;
		    # ----------------------------------------------------------------------------------- set scheduler options
		    $s = FRETemplate::setSchedulerOptions($s, $z, $np, $simRunTime, $segRunTime, $stdoutDir, %o);
		    # ------------------------------------------------------------------------------- normal return
		    return ($s, '', FREDefaults::STATUS_OK);
		  }
		  else
		  {
		    $fre->out(0, "The segment running time '$segRunTimeMinutes' must not exceed the maximum job running time allowed '$simRunTimeMinutes'");
		    return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
		  }
		}
		else
		{
        	  $fre->out(0, "Segment running time '$segRunTime' must be nonempty and have the HH:MM:SS format");
		  return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
		}
	      }
	      else
	      {
        	$fre->out(0, "Simulation running time '$simRunTime' must be noempty and have the HH:MM:SS format");
		return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	      }
	    }
	    else
	    {
	      $fre->out(0, "The segment time '$segTime' must not exceed the simulation time '$simTime'");
	      return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	    }
	  }
	  else
	  {
            $fre->out(0, "Segment time '$segTime' must be nonempty and have one of (years|year|months|month) units defined");
	    return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	  }
	}
	else
	{
          $fre->out(0, "Simulation time '$simTime' must be nonempty and have one of (years|year|months|month) units defined");
	  return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	}
      }
      else
      {
        $fre->out(0, "Number of processors must be a positive integer");
	return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
      }      
    }
    else
    {
      $fre->out(0, "Unable to create the stdout directory '$stdoutDir'!");
      return (0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }

  }
  
  sub setRegressionOutputDirectory($$$%)
  # ------ arguments: $script $exp $extension %options
  # ------ setups output directory via FREUtil::execute helper and writes its name in the script
  # ------ if the directory exists and the "unique" option is on, then appends a number to the directory/extension
  # ------ if the directory exists and the "overwrite" option is on, then removes and recreates the directory
  # ------ return ($script, $extension, $status)
  {

    my ($s, $z, $x, %o) = @_;
    
    my ($fre, $od, $host, $res) = ($z->fre(), $z->archiveDir() . '/' . $x, 'ac-arch', 1);

    $fre->out(2, "Creating output directories for regression tests...");

    if (FREUtil::execute($host, "test -d $od -a -w $od") == 0)
    {
      if ($o{unique})
      {
        my $i = 1;
        while (-d "$od$i") {$i++;}
        $od .= "$i";
        $x .= "$i";
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      elsif ($o{overwrite})
      {
        $res = FREUtil::execute($host, "rm -rf $od/ascii $od/restart $od/history; mkdir -p $od/ascii");
      }
      elsif (FREUtil::execute($host, "test -d $od/ascii -a -w $od/ascii"))
      {
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      else
      {
        $fre->out(0, "Output directory '$od/ascii' exists, so you must specify either --overwrite or --unique");
	return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
      }
    }
    else
    {
      $res = FREUtil::execute($host, "mkdir -p $od/ascii");
    }

    if ($res == 0)
    {
      $fre->out(2, "Created output directory $od/ascii");
      $s =~ s/set outputDir/set outputDir = $od/;
      return ($s, $x, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(0, "Unable to create the output directory '$od/ascii'!");
      return (0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }

  }

  sub setProductionOutputDirectory($$$%)
  # ------ arguments: $script $exp $extension %options
  # ------ setups output directory via FREUtil::execute helper and writes its name in the script
  # ------ if the directory exists and the "unique" option is on, then appends a number to the directory/extension
  # ------ if the directory exists and the "overwrite" option is on, then removes and recreates the directory
  # ------ return ($script, $extension, $status)
  {

    my ($s, $z, $x, %o) = @_;
    
    my ($fre, $od, $host, $res) = ($z->fre(), $z->archiveDir(), 'ac-arch', 1);
    
    $fre->out(2, "Creating output directories for production run...");

    if (FREUtil::execute($host, "test -d $od -a -w $od") == 0)
    {
      if ($o{unique})
      {
        $fre->out(2, "Performing dual production run, no post-processing for this run");
	$s = FRETemplate::setSchedulerDualRuns($s, $z);
        my $i = 1;
        while ( -d "$od/$i" ) {$i++;}
        $od .= "/$i";
        $x .= "__$i";
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      elsif ($o{overwrite})
      {
        $res = FREUtil::execute($host, "rm -rf $od/ascii $od/restart $od/history $od/postProcess $od/analysis; mkdir -p $od/ascii");
      }
      elsif ($o{extend})
      {
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      elsif (FREUtil::execute($host, "test -d $od/ascii -a -w $od/ascii"))
      {
        $res = FREUtil::execute($host, "mkdir -p $od/ascii");
      }
      else
      {
        $fre->out(0, "Output directory '$od/ascii' exists, so you must specify --extend, --overwrite or --unique");
	return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
      } 
    }
    else
    {
      $res = FREUtil::execute($host, "mkdir -p $od/ascii");
    }
    
    if ($res == 0)
    {
      $fre->out(2, "Created output directory $od/ascii");
      $s =~ s/set outputDir/set outputDir = $od/;
      return ($s, $x, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(0, "Unable to create the output directory '$od/ascii'!");
      return (0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }
    
  }
  
  sub namelistsAsString($)
  # ------ arguments: $refToNameListsHash
  {
    my $r = shift;
    my $nmlString = '';
    foreach my $key (sort(keys(%{$r})))
    {
      next unless $key;
      my $content = $r->{$key};
      $nmlString .= '<namelist name="' . $key . '">' . "\n";
      $nmlString .= $content . "\n";
      $nmlString .= '</namelist>' . "\n";
    }
    return $nmlString;
  }
  
  sub checkNamelists($$)
  # ------ arguments: $exp $refToNameListsHash
  {
    my ($z, $r) = @_;
    my $fre = $z->fre();
    my $targetListRepro = FRETargets::containsRepro($fre->target());
    if (exists($r->{xgrid_nml}))
    {
      my @xgridNml = split(/\n/, $r->{xgrid_nml});
      my $nmlRepro = (scalar(grep(/make_exchange_reproduce.+true/i, @xgridNml)) > 0);
      if ($nmlRepro and !$targetListRepro)
      {
        $fre->out(1, "The 'make_exchange_reproduce' is .TRUE. in the 'xgrid_nml' namelist, which contradicts with absence of 'repro' in your targets");
      }
      elsif (!$nmlRepro and $targetListRepro)
      {
        $fre->out(1, "The 'make_exchange_reproduce' is absent or isn't .TRUE. in the 'xgrid_nml' namelist, which contradicts with 'repro' in your targets");
      }
    }
    elsif ($targetListRepro)
    {
      $fre->out(1, "The 'xgrid_nml' namelist isn't found, which contradicts with 'repro' in your targets");
    }
  }
  
  sub extractOverrideParams($$$)
  # ------ arguments: $exp $runNode $refToNamelistsHash 
  {

    my ($z, $n, $r) = @_;
    my $fre = $z->fre();

    my $res = $z->nodeValue($n, '@overrideParams');
    $res .= ';' if ($res and $res !~ /.*;$/);

    my $atmos_layout = $z->nodeValue($n, '@atmos_layout');
    if ($atmos_layout)
    {
      $res .= "bgrid_core_driver_nml:layout=$atmos_layout;" if $r->{bgrid_core_driver_nml};
      $res .= "fv_core_nml:layout=$atmos_layout;" if $r->{fv_core_nml};
      $fre->out
      (
        1,
	"Usage of 'atmos_layout' is deprecated; instead, use",
	"<run overrideParams=\"fv_core_nml:layout=$atmos_layout\" ...>",
	"or <run overrideParams=\"bgrid_core_driver_nml:layout=$atmos_layout\" ...>"
      );
    }

    my $zetac_layout = $z->nodeValue($n, '@zetac_layout');
    if ($zetac_layout)
    {
      $res .= "zetac_layout_nml:layout=$zetac_layout;";
      $fre->out
      (
        1,
	"Usage of 'zetac_layout' is deprecated; instead, use",
	"<run overrideParams=\"zetac_layout_nml:layout=$zetac_layout;namelist:var=val;...\" ...>"
      );
    }

    my $ice_layout = $z->nodeValue($n, '@ice_layout');
    if ($ice_layout)
    {
      $res .= "ice_model_nml:layout=$ice_layout;";
      $fre->out
      (
        1,
	"Usage of 'ice_layout' is deprecated; instead, use",
	"<run overrideParams=\"ice_model_nml:layout=$ice_layout;namelist:var=val;...\" ...>"
      );
    }

    my $ocean_layout = $z->nodeValue($n, '@ocean_layout');
    if ($ocean_layout)
    {
      $res .= "ocean_model_nml:layout=$ocean_layout;";
      $fre->out
      (
        1,
	"Usage of 'ocean_layout' is deprecated; instead, use",
	"<run overrideParams=\"ocean_model_nml:layout=$ocean_layout;namelist:var=val;...\" ...>"
      );
    }

    my $land_layout = $z->nodeValue($n, '@land_layout');
    if ($land_layout)
    {
      $res .= "land_model_nml:layout=$land_layout;";
      $fre->out
      (
        1,
	"Usage of 'land_layout' is deprecated; instead, use",
	"<run overrideParams=\"land_model_nml:layout=$land_layout;namelist:var=val;...\" ...>"
      );
    }
    
    return $res;

  }

  sub overrideRegressionNamelists($$$%)
  # ------ arguments: $exp $runNode $hourslist %namelistsHash
  # ------ return overridden namelists hash
  {

    my ($z, $n, $h, %l) = @_;
    my $fre = $z->fre();
    
    frerun::checkNamelists($z, \%l);

    if ($h)
    {
      my $hoursNml = $l{coupler_nml};
      unless ($hoursNml =~ /.*hours\s*=\s*(\$hours)\s*(.*)/)
      {
        $hoursNml =~ s/( *)(days *=)/$1hours = \$hours,\n$1$2/;
        $fre->out(2, "Adding hours to coupler_nml...\n$hoursNml\n");
        $l{coupler_nml} = $hoursNml;
      }
    }

    my $nmlOverrides = frerun::extractOverrideParams($z, $n, \%l);
    my @nmls = split(/;/, $nmlOverrides);

    foreach my $nml (@nmls)
    {

      my ($namelist, $var, $val) = split(/[:=]/, $nml);
      $namelist =~ s/\s*//g;
      $var =~ s/\s*//g;
      unless ($namelist and $var) {$fre->out(1, "Got an empty namelist in overrideParams"); next;}

      $fre->out(2, "overrideParams from xml: $namelist:$var=$val");

      if (exists($l{$namelist}))
      {
        $fre->out(2, "original namelist:  $namelist\n$l{$namelist}");
        if ($l{$namelist} =~ /\b($var\s*=\s*)(\S.*)(([,\n]\s*\w+\s*=\s*.*)*)/i)
	{
          $l{$namelist} =~ s/\b($var\s*=\s*)(\S.*)(([,\n]\s*\w+\s*=\s*.*)*)/$1$val$3/i;
        }
	else
	{
          $l{$namelist} =~ s/^(\s*)/$1$var = $val,\n$1/;
        }
      }
      else
      {
        $l{$namelist} = "	$var = $val";
      }

      $fre->out(2, "overridden namelist: $namelist\n$l{$namelist}");

    }

    return %l;

  }

  sub overrideProductionNamelists($%)
  # ------ arguments: $exp %namelistsHash
  # ------ return overridden namelists hash
  {

    my ($z, %l) = @_;

    my $setLayout = sub($$)
    {
      my ($n, $v) = @_;
      if (exists($l{$n}))
      {
	if ($l{$n} =~ /\b(layout\s*=\s*)(\d+|\$\w+)\s*,\s*(\d+|\$\w+)\b(.*)/i)
	{
          $l{$n} =~ s/\b(layout\s*=\s*)(\d+|\$\w+)\s*,\s*(\d+|\$\w+)\b(.*)/$1$v$4/i;
	}
	else
	{ 
          $l{$n} =~ s/^(\s*)/$1layout = $v,\n$1/;
	}
      }
      else
      {
	$l{$n} = "	layout = $v";
      }
    };

    frerun::checkNamelists($z, \%l);

    my $atmos_layout = $z->extractValue('runtime/production/peLayout/@atmos');
    $setLayout->('bgrid_core_driver_nml', $atmos_layout) if $atmos_layout;
    $setLayout->('fv_core_nml', $atmos_layout) if $atmos_layout;

    my $zetac_layout = $z->extractValue('runtime/production/peLayout/@zetac');
    $setLayout->('zetac_layout_nml', $zetac_layout) if $zetac_layout;

    my $ice_layout = $z->extractValue('runtime/production/peLayout/@ice');
    $setLayout->('ice_model_nml', $ice_layout) if $ice_layout;

    my $ocean_layout = $z->extractValue('runtime/production/peLayout/@ocean');
    $setLayout->('ocean_model_nml', $ocean_layout) if $ocean_layout;

    my $land_layout = $z->extractValue('runtime/production/peLayout/@land');
    $setLayout->('land_model_nml', $land_layout) if $land_layout;

    return %l;

  }

  sub setNamelists($%)
  # ------ arguments: $script %namelistsHash
  # ------ returns script, updated from namelists
  {

    my ($s, %l) = @_;
    
    my $calendarType = frerun::calendarType(\%l);
    my $timeStampFormat = ($calendarType and ($calendarType ne 'no_calendar')) ? 'digital' : 'days';
    $s =~ s/set timeStampFormat/set -r timeStampFormat = $timeStampFormat/;

    my $nmlString = "cat > input.nml <<EOF\n";
    foreach my $key (sort(keys(%l)))
    {
      next unless $key;
      my $content = $l{$key};
      $nmlString .= " \&$key\n$content\n\/\n\n";
    }
    $nmlString .= "EOF\n";

    $s =~ s/#namelists_from_xml/$nmlString/;
    return $s;

  }

  sub setMPI($$$%)
  # ------ arguments: $script $exp $runNode %options
  {

    my ($s, $z, $n, %o) = @_;
    my $fre = $z->fre();

    my $histx = ($n) ? $z->nodeValue($n, '@histx') : '';
    if ($histx)
    {
      if ($o{regression})
      {
	my $siteIsGFDL = ($fre->property('FRE.site') eq FREDefaults::SiteGFDL());
	unless ($siteIsGFDL)
	{
	  $fre->out(1, "histx can only be used at GFDL on the Altix platform.  Not using histx...");
	  $histx = '';
	}
      }
      else
      {
        $fre->out(1, "histx can only be used for regression runs.  Not using histx...");
	$histx = '';
      }
    }

    my $csh = '';
    
    if ($o{target} =~ m/debug/ or $o{debug} eq 'totalview')
    {
      $csh .= 'setenv TRAP_FPE overfl=trace,exit;divzero=trace,exit;invalid=trace,exit' . "\n";
    }

    if ($ENV{MPIRUN_EXEC})
    {
      $fre->out(2, "Using your environment variable MPIRUN_EXEC: $ENV{MPIRUN_EXEC}");
      $csh .= $ENV{MPIRUN_EXEC};
    }
    elsif ($o{debug} eq 'totalview')
    {
      $fre->out(2, "Will launch TotalView...");
      $csh .= 'foreach i ( $executable:h/Makefile* )' . "\n";
      $csh .= '  make localize -f $i' . "\n";
      $csh .= 'end' . "\n";
      $csh .= 'totalview mpirun -a -np $npes'; 
    }
    elsif ($o{debug} eq 'setup')
    {
      $fre->out(2, "Will exit before the mpirun call...");
      $csh .= "\n";
      $csh .= 'exit 1' . "\n\n";
      $csh .= '/usr/bin/time -p mpirun -np $npes';
    }
    elsif ($histx)
    {
      $fre->out(2, "Will use histx profiling tool...");
      $csh .= 'source /opt/sgi/histx/setup.csh' . "\n";
      $csh .= '/usr/bin/time -p mpirun -np $npes `which histx` -o hi ' . $histx;
    }
    else
    {
      $csh .= '/usr/bin/time -p mpirun -np $npes';
    }

    $csh .= ' $executable:t |& tee fms.out';

    $fre->out(2, "Running executable with:\n$csh");

    $s =~ s/#parlib_run_from_xml/$csh/;
    return $s;

  }
  
  sub outputScriptInputDir($$)
  # ------ arguments: $fre $exp
  {
    my ($fre, $z) = @_;
    my $ptmpTempPattern = $fre->property('FRE.directory.ptmp.temp.pattern');
    return ($z->ptmpDir() =~ m/$ptmpTempPattern/m) ? $fre->property('FRE.directory.ptmp.aux') : '';
  }
  
  sub outputScriptJobId($$)
  # ------ arguments: $fre $string
  # ------ return $jobId
  {
    my ($fre, $s) = @_;
    my $qsubOutputPattern = $fre->property('FRE.scheduler.qsub.output.pattern');
    return ($s =~ m/$qsubOutputPattern/m) ? $1 : '';
  }
  
  sub outputScriptOption($$$)
  # ------ arguments: $fre $name $value
  {
    my ($fre, $n, $v) = @_;
    my $optionString = $fre->property($n);
    $optionString =~ s/\$/$v/;
    return $optionString;
  }

  sub outputScriptExecuteOrSubmit($$$%)
  # ------ arguments: $script $exp $pathname %options
  # ------ write $script to the $pathname file, chmod, and optionally execute or submit
  # ------ return ($script, $status)
  {
    my ($s, $z, $n, %o) = @_;
    my $fre = $z->fre();
    my ($basename, $directory) = File::Basename::fileparse($n);
    if (frerun::createDirectory($fre, $directory, $o{verbose}))
    {
      if (open my $scriptHandle, '>', $n)
      {
	print {$scriptHandle} $s;
	close $scriptHandle;
	if (chmod 0755, $n)
	{
	  if ($o{execute})
	  {
	    my $out = frerun::stdoutName($z, $n);
            my $directory = File::Basename::dirname($out);
	    if (frerun::createDirectory($fre, $directory, $o{verbose}))
	    {
	      my $res = system("$n 2>&1 | tee $out");
	      if ($res == 0)
	      {
		return ($s, FREDefaults::STATUS_OK);
	      }
	      else
	      {
        	$fre->out(0, "The runscript '$n' failed! ($res)", "Please see the logfile '$out'...");
		return (0, FREDefaults::STATUS_FRE_RUN_EXECUTION_PROBLEM);
	      }
	    }
	    else
	    {
	      $fre->out(0, "Unable to create the stdout directory '$directory'!");
	      return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	    }
	  }
	  elsif ($o{submit}) 
	  {
	    $fre->out(2, "Executing 'qsub $n'...");
	    my $qsubMsg = qx(qsub $n);
	    print "$qsubMsg";
	    return ($s, FREDefaults::STATUS_OK);
	  }
	  elsif ($o{'submit-staged'})
	  {
	    my $inputDir = frerun::outputScriptInputDir($fre, $z);
            my $coresPerNode = $fre->property('FRE.machine.coresPerNode');
	    my $optionNpes = frerun::outputScriptOption($fre, 'FRE.scheduler.option.npes', POSIX::ceil($o{npes} / $coresPerNode) * $coresPerNode);
	    my $optionTime = frerun::outputScriptOption($fre, 'FRE.scheduler.option.time', $o{walltime} * 60);
	    my $optionName = frerun::outputScriptOption($fre, 'FRE.scheduler.option.name', "${basename}_input");
	    my $qsubInputCommand = "qsub $optionName $optionNpes $optionTime -v FRE_STAGE=INPUT,FRE_INPUT_DIR=$inputDir $n";
	    $fre->out(2, "Executing '$qsubInputCommand'...");
	    my $qsubInputMsg = qx($qsubInputCommand);
	    print "$qsubInputMsg";
	    my $jobId = frerun::outputScriptJobId($fre, $qsubInputMsg);
	    if ($jobId)
	    {
	      my $optionDependsOn = frerun::outputScriptOption($fre, 'FRE.scheduler.option.dependsOn', $jobId);
	      my $qsubRunCommand = "qsub $optionDependsOn -v FRE_STAGE=RUN,FRE_INPUT_DIR=$inputDir $n";
	      $fre->out(2, "Executing '$qsubRunCommand'...");
	      my $qsubRunMsg = qx($qsubRunCommand);
	      print "$qsubRunMsg";
	      return ($s, FREDefaults::STATUS_OK);
	    }
	    else
	    {
	      $fre->out(0, "Unable to submit the input data staging job for '$basename'");
	      return ($s, FREDefaults::STATUS_FRE_RUN_EXECUTION_PROBLEM);
	    }
	  }
	  else
	  {
	    print "TO SUBMIT => qsub $n\n";
	    return ($s, FREDefaults::STATUS_OK);
	  }
	}
	else
	{
          $fre->out(0, "Unable to change the script '$n' permissions!");
	  return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	}
      }
      else
      {
	$fre->out(0, "Unable to save the script '$n'!");
	return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
      }
    }
    else
    {
      $fre->out(0, "Unable to create the scripts directory '$directory'!");
      return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }
  }
  
  sub outputRegressionScript($$$%)
  # ------ arguments: $script $exp $extension %options
  {
    my ($s, $z, $x, %o) = @_;
    my $scriptName = frerun::regressionRunScriptName($z, $x);
    $s =~ s/set scriptName/set -r scriptName = $scriptName/;
    return frerun::outputScriptExecuteOrSubmit($s, $z, $scriptName, %o);
  }

  sub outputProductionScript($$$%)
  # ------ arguments: $script $exp $extension %options
  {
    my ($s, $z, $x, %o) = @_;
    my $scriptName = frerun::productionRunScriptName($z, $x);
    $s =~ s/set scriptName/set -r scriptName = $scriptName/;
    return frerun::outputScriptExecuteOrSubmit($s, $z, $scriptName, %o);
  }
  
  sub skipExp($)
  # ------ arguments: $exp 
  {
    my $z = shift;
    my ($expName, $fre) = ($z->name(), $z->fre());
    $fre->out(0, "Skipping the experiment '$expName'...");
  }

}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

  my %opt =
  (
    'archive'		=> 1,
    'combine-history'	=> 1,
    'logging'		=> 1,
    'npes'		=> frerun::NPES_DEFAULT,
    'walltime'		=> frerun::WALLTIME_DEFAULT,
    'platform'		=> FREDefaults::Platform(),
    'target'		=> FREDefaults::Target(),
    'xmlfile'		=> FREDefaults::XMLFile()
  );

  Getopt::Long::GetOptions(\%opt, frerun::OPTLIST) or (print frerun::Usage() and exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM);
  if ($opt{Version}) {print frerun::VERSION,"\n" and exit FREDefaults::STATUS_OK;}
  if ($opt{help}) {print frerun::Help() and exit FREDefaults::STATUS_OK;}
  
  if ($opt{extend} + $opt{overwrite} + $opt{unique} > 1)
  {
    FREMsg::out($opt{verbose}, 0, "Options --extend, --overwrite and --unique are mutually exclusive - only one of them can be present");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }

  if (scalar(@ARGV) == 0)
  {
    FREMsg::out($opt{verbose}, 0, "At least one experiment name is needed on the command line");
    exit FREDefaults::STATUS_COMMAND_NO_EXPERIMENTS;
  }

  my $fre = FRE->new('frerun', %opt) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;

  my @exps = ();
  foreach my $expName (@ARGV)
  {
    my $exp = FREExperiment->new($fre, $expName) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    push @exps, $exp;
  }

  my $status = FREDefaults::STATUS_OK;
  
  foreach my $exp (@exps)
  {

    # --------------------------------- set the experiment name
    
    my $expName = $exp->name();
    $fre->setCurrentExperimentName($expName);
    $fre->out(2, "Setting up experiment '$expName'...");

    # ---------------------------------------------------------------- process the experiment
    
    my %nml = $exp->extractNamelists();
    if (!exists($nml{-1}))
    {
      if ($opt{namelist})
      {
	if ($opt{regression})
	{
          # --------------------------------------------------------------- regression namelists output
	  my @regLabels = ($opt{regression} eq 'suite') ? frerun::REGRESSION_SUITE : $opt{regression};
	  foreach my $regLabel (@regLabels)
	  {
            $fre->out(2, "Extracting namelists for the regression test '$regLabel'...");
	    my $x = 'regression[@label="' . $regLabel . '" or @name="' . $regLabel . '"]';
	    my @regNodes = $exp->extractNodes('runtime', $x);
	    if (scalar(@regNodes) == 1)
	    {
	      my @runNodes = $exp->extractNodes('runtime/' . $x, 'run');
	      if (scalar(@runNodes) > 0)
	      {
		for (my $i = 0; $i < scalar(@runNodes); $i++)
		{
		  my $runNode = $runNodes[$i];
		  my ($mlist, $dlist, $hlist) = frerun::extractRegressionTimingParameters($exp, $runNode);
		  my %nmlOverridden = frerun::overrideRegressionNamelists($exp, $runNode, $hlist, %nml);
		  print frerun::namelistsAsString(\%nmlOverridden), "\n";
		}
              }
	      else
	      {
		$fre->out(2, "The regression test '$regLabel' doesn't have any runs for the experiment '$expName'");
		#frerun::skipExp($exp) if scalar(@exps) > 1;
		#$status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
		#last; 
	      }
	    }
	    elsif (scalar(@regNodes) > 1)
	    {
	      $fre->out(0, "The regression test '$regLabel' is defined more than once for the experiment '$expName'");
	      frerun::skipExp($exp) if scalar(@exps) > 1;
	      $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
	      last; 
	    }
	    else
	    {
	      $fre->out(2, "The regression test '$regLabel' doesn't exist for the experiment '$expName'");
	      #frerun::skipExp($exp) if scalar(@exps) > 1;
	      #$status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
	      #last; 
	    }
	  }
	}
	else
	{
          # ------------------------------------------------- production namelists output
          $fre->out(2, "Extracting namelists for the experiment '$expName'...");
          my %nmlOverridden = frerun::overrideProductionNamelists($exp, %nml);
	  print frerun::namelistsAsString(\%nmlOverridden), "\n";
	}
      }
      else
      {
	# ------------------------------ initialize the script, setup various common parameters
	(my $runScript, $status) = frerun::init($exp, %opt);
	if ($runScript)
	{
	  ($runScript, $status) = frerun::setInputDatasets($runScript, $exp);
	  if ($runScript)
	  {
	    ($runScript, $status) = frerun::setTables($runScript, $exp, $nml{coupler_nml});
	    if ($runScript)
	    {

	      $runScript = frerun::setInputInitialConditions($runScript, $exp);
	      $runScript = frerun::setInputGridSpecification($runScript, $exp);
 	      $runScript = frerun::setShellCommands($runScript, $exp);
	      $runScript = FRETemplate::setVersionInfo($runScript, $exp, $0, %opt);	    

	      if ($opt{regression})
	      {
                # --------------------------------------------------------------- regression runscripts creation
		my @regLabels = ($opt{regression} eq 'suite') ? frerun::REGRESSION_SUITE : $opt{regression};
		foreach my $regLabel (@regLabels)
		{
        	  $fre->out(2, "Creating scripts for the regression test '$regLabel'...");
		  my $x = 'regression[@label="' . $regLabel . '" or @name="' . $regLabel . '"]';
		  my @regNodes = $exp->extractNodes('runtime', $x);
		  if (scalar(@regNodes) == 1)
		  {
		    my @runNodes = $exp->extractNodes('runtime/' . $x, 'run');
		    if (scalar(@runNodes) > 0)
		    {
		      for (my $i = 0; $i < scalar(@runNodes); $i++)
		      {
		        my $runNode = $runNodes[$i];
			my ($mlist, $dlist, $hlist) = frerun::extractRegressionTimingParameters($exp, $runNode);
        		(my $rtScript, my $extension, $status) = frerun::setRegressionParameters($runScript, $exp, $runNode, $mlist, $dlist, $hlist, %opt);
        		if ($rtScript)
			{
			  ($rtScript, $extension, $status) = frerun::setRegressionOutputDirectory($rtScript, $exp, $extension, %opt);
        		  if ($rtScript)
			  {
			    my %nmlOverridden = frerun::overrideRegressionNamelists($exp, $runNode, $hlist, %nml);
        		    $rtScript = frerun::setNamelists($rtScript, %nmlOverridden);
			    $rtScript = frerun::setMPI($rtScript, $exp, $runNode, %opt);
        		    ($rtScript, $status) = frerun::outputRegressionScript($rtScript, $exp, $extension, %opt);
        		    if ($rtScript)
			    {
		              $fre->out(2, "The runscript for the run #$i in the regression test '$regLabel' for the experiment '$expName' has been created successfully");
			    }
			    else
			    {
		              $fre->out(0, "Unable to create (or run) a runscript for the run #$i in the regression test '$regLabel' for the experiment '$expName'");
		              frerun::skipExp($exp) if scalar(@exps) > 1;
			      $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
			      last;
			    }
			  }
			  else
			  {
		            $fre->out(0, "Unable to setup output directories for the run #$i in the regression test '$regLabel' for the experiment '$expName'");
		            frerun::skipExp($exp) if scalar(@exps) > 1;
			    $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
			    last;
			  }
			}
			else
			{
			  $fre->out(0, "Unable to setup timing parameters for the run #$i in the regression test '$regLabel' for the experiment '$expName'");
		          frerun::skipExp($exp) if scalar(@exps) > 1;
			  $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
			  last;
			}
        	      }
		    }
		    else
		    {
		      $fre->out(2, "The regression test '$regLabel' doesn't have any runs for the experiment '$expName'");
		      #frerun::skipExp($exp) if scalar(@exps) > 1;
		      #$status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
		      #last;
		    }
		  }
		  elsif (scalar(@regNodes) > 1)
		  {
		    $fre->out(0, "The regression test '$regLabel' is defined more than once for the experiment '$expName'");
		    frerun::skipExp($exp) if scalar(@exps) > 1;
		    $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
		    last;
		  }
		  else
		  {
		    $fre->out(2, "The regression test '$regLabel' doesn't exist for the experiment '$expName'");
		    #frerun::skipExp($exp) if scalar(@exps) > 1;
		    #$status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
		    #last;
		  }
		}
	      }
	      else
	      {
	        # ----------------------------------------------------------------- production runscript creation
      	        $fre->out(2, "Creating a runcript for the experiment '$expName'...");
		($runScript, my $extension, $status) = frerun::setProductionParameters($runScript, $exp, %opt);
		if ($runScript)
		{
		  ($runScript, $extension, $status) = frerun::setProductionOutputDirectory($runScript, $exp, $extension, %opt);
		  if ($runScript)
		  {
		    my %nmlOverridden = frerun::overrideProductionNamelists($exp, %nml);
		    $runScript = frerun::setNamelists($runScript, %nmlOverridden);
		    $runScript = frerun::setMPI($runScript, $exp, '', %opt);
		    ($runScript, $status) = frerun::outputProductionScript($runScript, $exp, $extension, %opt);
		    if ($runScript)
		    {
		      $fre->out(2, "The runscript for the experiment '$expName' has been created successfully");
		    }
		    else
		    {
		      $fre->out(0, "Unable to create (or run) a runscript for the experiment '$expName'");
		      frerun::skipExp($exp) if scalar(@exps) > 1;
		    }
		  }
		  else
		  {
		    $fre->out(0, "Unable to setup output directories for the experiment '$expName'");
		    frerun::skipExp($exp) if scalar(@exps) > 1;
		  }
		}
		else
		{
		  $fre->out(0, "Unable to setup timing parameters for the experiment '$expName'");
		  frerun::skipExp($exp) if scalar(@exps) > 1;
		}
	      }

	    }
	    else
	    {
              $fre->out(0, "Unable to setup tables for the experiment '$expName'");
	      frerun::skipExp($exp) if scalar(@exps) > 1;
	    }
	  }
	  else
	  {
            $fre->out(0, "Unable to setup input data for the experiment '$expName'");
	    frerun::skipExp($exp) if scalar(@exps) > 1;
	  }
	}
	else
	{
          $fre->out(0, "Unable to initialize the experiment '$expName'");
	  frerun::skipExp($exp) if scalar(@exps) > 1;
	}
      }
    }
    else
    {
      $fre->out(0, "Unable to extract namelists for the experiment '$expName'");
      frerun::skipExp($exp) if scalar(@exps) > 1;
      $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    }
    
    # ------------------------------------ unset the experiment name
    
    $fre->unsetCurrentExperimentName();

  }
  
  exit $status;

}
