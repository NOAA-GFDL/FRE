#!/usr/bin/env perl
# -*- cperl -*-
#
# $Id: frerun,v 18.0.2.81.4.3 2014/11/18 23:31:23 arl Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to Create a Script to Run a Model
# ------------------------------------------------------------------------------
# arl    Ver  18.00  Merged revision 17.0.4.21 onto trunk           March 10
# afy -------------- Branch 18.0.2 -------------------------------- March 10
# afy    Ver   1.00  Modify Help subroutine (list targets)          March 10
# afy    Ver   1.01  Add --archive option                           March 10
# afy    Ver   1.02  Modify init (set flagArchive)                  March 10
# afy    Ver   1.03  Modify init (no staged combining for reg.)     March 10
# afy    Ver   2.00  Modify Help subroutine again (list targets)    April 10
# afy    Ver   2.01  Modify Usage subroutine (reorder, attributes)  April 10
# afy    Ver   2.02  Add shorter option names                       April 10
# afy    Ver   2.03  Add option --validate                          April 10
# afy    Ver   2.04  Check for experiment names separately          April 10
# afy    Ver   2.05  Modify init (don't set FREROOT)                April 10
# afy    Ver   2.06  Modify init (set flagOutputType)               April 10
# afy    Ver   2.07  Modify init (set flagOutputPostProcess)        April 10
# afy    Ver   2.08  Modify setProductionOutputDirectory (no frepp) April 10
# afy    Ver   2.09  Modify outputRegressionScript (no frepp)       April 10
# afy    Ver   2.10  Modify init (offline + unique => online)       April 10
# afy    Ver   2.11  Add option --execute                           April 10
# afy    Ver   3.00  Remove option --build                          May 10
# afy    Ver   3.01  Add (modified) execName subroutine             May 10
# afy    Ver   3.02  Modify init (don't set siteDir/flagRemake)     May 10
# afy    Ver   3.03  Modify init (set freCommandsHomeDir)           May 10
# afy    Ver   3.04  Add baseDate subroutine                        May 10
# afy    Ver   3.05  Modify setTables subroutine (use setBaseDate)  May 10
# afy    Ver   4.00  Modify init (use new FRE.pm)                   May 10
# afy    Ver   5.00  Add --target option alias 't'                  June 10
# afy    Ver   6.00  Use new FREDefaults.pm to return status        June 10
# afy    Ver   6.01  Force if/elsif/else tree design                June 10
# afy    Ver   6.02  Modify setProductionParameters subroutine      June 10
# afy    Ver   6.03  Modify outputScriptExecuteOrSubmit subroutine  June 10
# afy    Ver   6.04  Add pathname-returning subroutines             June 10
# afy    Ver   6.05  Standardize skipExp subroutine                 June 10
# afy    Ver   6.06  Modify init (default getFmsData)               June 10
# afy    Ver   6.07  Add calendarType subroutine                    June 10
# afy    Ver   6.08  Modify setNamelists (set timeStampFormat)      June 10
# afy    Ver   7.00  Add option --submit-staged	                    June 10
# afy    Ver   7.01  Add option --npes (for staging only)           June 10
# afy    Ver   7.02  Add option --walltime (for staging only)       June 10
# afy    Ver   7.03  Modify init (change ptmpDir/hsmDir settings)   June 10
# afy    Ver   7.04  Modify outputScriptExecuteOrSubmit (staging)   June 10
# afy    Ver   8.00  Modify outputScriptInputDir (use properties)   June 10
# afy    Ver   8.01  Modify outputScriptJobId (use properties)      June 10
# afy    Ver   9.00  Modify setMPI (use new FREDefaults.pm)         July 10
# afy    Ver  10.00  Weaken errors processing for suites            July 10
# afy    Ver  11.00  Add processRegressionRun subroutine            August 10
# afy    Ver  11.01  Add processRegression subroutine               August 10
# afy    Ver  11.02  Add processRegressionSuite subroutine          August 10
# afy    Ver  11.03  Add processProduction subroutine               August 10
# afy    Ver  11.04  Restructure the main loop using added subs     August 10
# afy    Ver  11.05  Add option --dual                              August 10
# afy    Ver  12.00  Modify init (more history combining types)     August 10
# afy    Ver  13.00  Modify init (history combining type checkup)   August 10
# afy    Ver  13.01  Cosmetics in messages                          August 10
# afy    Ver  13.02  Modify option --dual (alias 'du' => 'D')       August 10
# afy    Ver  13.03  Modify option --execute (alias 'e' => 'E')     August 10
# afy    Ver  13.04  Modify option --extend (alias 'ext' => 'e')    August 10
# afy    Ver  13.05  Modify option --overwrite (add alias 'o')      August 10
# afy    Ver  13.06  Modify option --unique (add alias 'u')         August 10
# afy    Ver  13.07  Modify option --namelist (add alias 'N')       August 10
# afy    Ver  13.08  Modify option --npes (add alias 'n')           August 10
# afy    Ver  14.00  Reconfigure Getopt::Long (no 'auto_abbrev')    August 10
# afy    Ver  14.01  Merge two options --transfer-* into one        August 10
# afy    Ver  14.02  Modify option --submit (allow 'staged' value)  August 10
# afy    Ver  14.03  Remove option --submit-staged                  August 10
# afy    Ver  14.04  Add single-letter aliases to all the options   August 10
# afy    Ver  14.05  Add option --check                             August 10
# afy    Ver  14.06  Use new module FRETemplate (new set* subs)     August 10
# afy    Ver  14.07  Modify setMPI (pass the ./$executable:t)       August 10
# afy    Ver  15.00  Correction for the --dual option               August 10
# afy    Ver  16.00  Modify option --transfer (negatable)           August 10
# afy    Ver  16.01  Revive option --submit-staged                  August 10
# afy    Ver  16.02  Modify option --submit (don't allow values)    August 10
# afy    Ver  16.03  Modify option --validate (no aliases)          August 10
# afy    Ver  16.04  Modify option --version (low case)             August 10
# afy    Ver  16.05  Default option --dual from a property          August 10
# afy    Ver  16.06  Default option --transfer from a property      August 10
# afy    Ver  17.00  Modify outputScriptExecuteOrSubmit (no qsub)   September 10
# afy    Ver  17.01  Use new module FRETemplate                     September 10
# afy    Ver  18.00  Use new module FRETemplate (setScheduler*)     September 10
# afy    Ver  18.01  Modify set*Parameters (no stdoutDir)           September 10
# afy    Ver  18.02  Modify outputScriptJobId (property name)       September 10
# afy    Ver  18.03  Modify outputScripExecuteOrSubmit (stdoutDir)  September 10
# afy    Ver  18.04  Remove output*Script subroutines               September 10
# afy    Ver  18.05  Modify processRegressionRun (set all names)    September 10
# afy    Ver  18.06  Modify processProduction (set all names)       September 10
# afy    Ver  19.00  Rename option --npes => --ncores               September 10
# afy    Ver  19.01  Modify outputScriptExecuteOrSubmit (ncores)    September 10
# afy    Ver  20.00  Modify outputScriptExecuteOrSubmit (staging)   September 10
# afy    Ver  21.00  Modify outputScriptJobId (add parameter)       September 10
# afy    Ver  21.01  Modify outputScriptJobId (generic pattern)     September 10
# afy    Ver  22.00  Add option --partition                         September 10
# afy    Ver  23.00  Simplify staged submitting (no FRE_INPUT_DIR)  October 10
# afy    Ver  23.01  Add option --submit-chained                    October 10
# afy    Ver  23.02  Modify init (add partitions/queues setup)      October 10
# afy    Ver  23.00  Modify outputScriptExecuteOrSubmit (names)     October 10
# afy    Ver  24.00  Add option --output-staging                    October 10
# afy    Ver  24.01  Assign 'platform' settable constant            October 10
# afy    Ver  25.00  Assign 'target' settable constant              October 10
# afy    Ver  26.00  Rethink the option --output-staging            November 10
# afy    Ver  26.01  Rename flag*CombineType => flag*StagingType    November 10
# afy    Ver  26.02  Rename flag*Combine => flag*CombineHistory     November 10
# afy    Ver  27.00  Properties for --ncores/walltime defaults      November 10
# afy    Ver  28.00  Use new FREMsg module (symbolic level names)   December 10
# afy    Ver  28.01  Add productionParametersExist subroutine       December 10
# afy    Ver  28.02  Modify init (fileSender/outputStager times)    December 10
# afy    Ver  28.03  Modify init (mail mode)                        December 10
# afy    Ver  29.00  Modify init (add moduleInitDir setting)        December 10
# afy    Ver  30.00  Remove option --logging                        January 11
# afy    Ver  30.01  Modify init (corrections in messages)          January 11
# afy    Ver  30.02  Modify setMPI (property to request histx)      January 11
# afy    Ver  30.03  Modify outputScriptExecuteOrSubmit (checks)    January 11
# afy    Ver  31.00  Verify option --partition values               February 11
# afy    Ver  31.01  Add option --queue                             February 11
# afy    Ver  31.02  Use new FRETemplate module (setScheduler*)     February 11
# afy    Ver  31.03  Use new FREUtil module (createDir)             February 11
# afy    Ver  31.04  Modify init (renamed properties)               February 11
# afy    Ver  31.05  Modify outputScriptJobId (remove mode)         February 11
# afy    Ver  31.06  Simplify all the grep calls                    February 11
# afy    Ver  32.00  Fix partitions/queues checkup (again)          March 11
# afy    Ver  33.00  Remove option --debug                          March 11
# afy    Ver  33.01  Use new FRE (propertyParameterized)            March 11
# afy    Ver  33.02  Use new FRETemplate (setAlias)                 March 11
# afy    Ver  33.03  Add check for 'FRE.tool.frerun.enabled'        March 11
# afy    Ver  33.04  Modify createDirectory (no remoting)           March 11
# afy    Ver  33.05  Modify set*OutputDirectory (no remoting)       March 11
# afy    Ver  33.06  Modify setMPI (use default property)           March 11
# afy    Ver  33.07  Remove outputScriptOption subroutine           March 11
# afy    Ver  34.00  Modify init (more scheduling parameters)       May 11
# afy    Ver  34.01  Modify option --output-staging checkup         May 11
# afy    Ver  34.00  Modify init (add pp scheduling parameters)     May 11
# afy    Ver  34.01  Modify option --archive checkup                May 11
# afy    Ver  35.00  Remove option --validate                       May 11
# afy    Ver  35.01  Improve output staging types checkup/control   May 11
# afy    Ver  35.02  Modify init (add stateDir setting)             May 11
# afy    Ver  36.00  Modify setProductionParameters (no extension)  May 11
# afy    Ver  36.01  Modify set*Directories (stateDir/outputDir)    May 11
# afy    Ver  37.00  Modify init (roll the project back)            June 11
# afy    Ver  38.00  Modify init (split outstager settings)         June 11
# afy    Ver  39.00  Modify init (add ppPreparer settings)          June 11
# afy    Ver  40.00  Modify setNamelists (save them unexpanded)     June 11
# afy    Ver  40.01  Add option --output-hashing                    June 11
# afy    Ver  41.00  Rename option --output-hashing => --checksum   June 11
# afy    Ver  42.00  Modify override*Namelists (fix checkNamelists) July 11
# afy    Ver  42.01  Use new module FREUtil (optionValuesListParse) July 11
# afy    Ver  42.02  Unify all the grep calls                       July 11
# afy    Ver  42.03  Add more option values checks                  July 11
# afy    Ver  42.04  Add option --compress                          July 11
# afy    Ver  42.05  Add option --output-cache                      July 11
# afy    Ver  42.06  Add option --argfiles                          July 11
# afy    Ver  43.00  Rename --output-cache => --cache-history       July 11
# afy    Ver  44.00  Remove option --argfiles                       August 11
# afy    Ver  44.01  Rename input stager properties                 August 11
# afy    Ver  44.02  Modify setRegressionParameters (bug fixes)     August 11
# afy    Ver  44.03  Modify overrideRegressionNamelists (no hours)  August 11
# afy    Ver  44.04  Add set*TimeStampOptions subroutines           August 11
# afy    Ver  44.05  Update the script using references             August 11
# afy    Ver  45.00  Use new module FRE.pm (init)                   September 11
# afy    Ver  46.00  Improve the option --output-staging processing September 11
# afy    Ver  46.01  Rename template flags 'Transfer' => 'Xfer'     September 11
# afy    Ver  46.02  Rename 'combineFreq' => 'segmentsPerPPCall'    September 11
# afy    Ver  46.03  Clarify the 'segmentsPerPPCall' calculation    September 11
# afy    Ver  46.04  Output staging - add check for the archiveDir  September 11
# afy    Ver  46.05  Online output staging - force no transfer      September 11
# afy    Ver  46.06  Don't set the pp.preparer constants            September 11
# afy    Ver  47.00  Add option --remote-user                       October 11
# afy    Ver  47.01  Call frelist to get remote dirs                October 11
# afy    Ver  47.02  Call frelist to get remote platform <csh>      October 11
# afy    Ver  47.03  Replace 'moduleInitDir' => 'modulesHomeDir'    October 11
# afy    Ver  47.04  Improve the option --transfer checkup          October 11
# afy    Ver  47.05  Fix platform/target setting in the runscript   October 11
# afy    Ver  47.06  Switch to stdoutDir before submitting          October 11
# afy    Ver  48.00  Set the 'userRemote' constant in the template  October 11
# afy    Ver  49.00  Modify 'init' (quote all the remote settings)  October 11
# afy    Ver  50.00  Modify 'init' (set 'freModuleFilesDir')        November 11
# afy    Ver  51.00  More complete and simple options checkup       November 11
# afy    Ver  51.01  Use 'FREUtil::listUnique' to remove dupes      November 11
# afy    Ver  52.00  Use new module FREExperiment (executable)      November 11
# afy    Ver  52.01  Modify init (more executable checks)           November 11
# afy    Ver  53.00  Modify getRemoteDirs (show FATAL only)         December 11
# afy    Ver  53.01  Modify getRemotePlatformCsh (show FATAL only)  December 11
# afy    Ver  53.02  Add outRemoteErrors (using new FREMsg.pm)      December 11
# afy    Ver  54.00  Remove outRemoteErrors subroutine              January 12
# afy    Ver  54.01  Simplify getRemoteDirs (no tcsh needed)        January 12
# afy    Ver  54.02  Simplify getRemotePlatformCsh (no tcsh needed) January 12
# afy    Ver  55.00  Modify setProductionDirectories (no dualing)   January 12
# afy    Ver  55.01  Modify process*Run (pass 'dual-names' flag)    January 12
# afy    Ver  55.02  Set 'dual-names' for dual production runs      January 12
# afy    Ver  56.00  Add option --free                              January 12
# afy    Ver  56.01  Add option --project                           January 12
# afy    Ver  57.00  Messages improving (for remote platform)       January 12
# afy    Ver  58.00  Reverse default for the option --free          January 12
# afy    Ver  59.00  Add the option --free dependency on property   January 12
# afy    Ver  60.00  Modify Usage (remove ASCII escapes)            February 12
# afy    Ver  60.01  Modify init (relax archive placement)          February 12
# afy    Ver  60.02  Modify outputScriptExecuteOrSubmit (delay)     February 12
# afy    Ver  61.00  Split stdoutDir setup using stdoutTmpDir       February 12
# afy    Ver  61.01  Modify init (stdoutDir, finisher)              February 12
# afy    Ver  62.00  Modify outputScriptStartTime (today => now)    April 12
# afy    Ver  63.00  Cosmetics in messages                          April 12
# afy    Ver  64.00  Add 'namelists' package                        April 12
# afy    Ver  64.01  Use new 'FRETemplates' module                  April 12
# afy    Ver  64.02  Add 'MPISizeParameters' subroutine             April 12
# afy    Ver  64.03  Modify 'setMPI' subroutine                     April 12
# afy    Ver  64.04  Use 'FRE.option.free.default' for freeing      April 12
# afy    Ver  65.00  Modify 'init' (set two more constants)         June 12
# afy    Ver  66.00  Modify 'init' (set remote dir/version)         June 12
# afy    Ver  67.00  Remove option --namelist                       June 12
# afy    Ver  67.01  Use new FRENamelists module (totally new)      June 12
# afy    Ver  67.02  Use new FREExperiment module (many changes)    June 12
# afy    Ver  67.03  Replace 'setRegressionParameters'              June 12
# afy    Ver  67.04  Replace 'setProductionParameters'              June 12
# afy    Ver  67.05  Move 'extractOverrideParams' out               June 12
# afy    Ver  67.06  Move 'overrideRegressionNamelists' out         June 12
# afy    Ver  67.07  Move 'overrideProductionNamelists' out         June 12
# afy    Ver  67.08  Move 'MPISizeParameters' out                   June 12
# afy    Ver  67.09  Modify 'setMPI' (use new FREExperiment.pm)     June 12
# afy    Ver  67.10  Modify 'outputScriptExecuteOrSubmit' (dual)    June 12
# afy    Ver  67.11  Remove 'processRegressionRun'                  June 12
# afy    Ver  67.12  Remove 'processRegressionSuite'                June 12
# afy    Ver  67.13  Modify 'processRegression' (use extract*Info)  June 12
# afy    Ver  67.14  Modify 'processProduction' (use extract*Info)  June 12
# afy    Ver  67.15  Use new FREExperiment (run as key)             June 12
# afy    Ver  68.00  Move 'prepareInputFile' out                    July 12
# afy    Ver  68.01  Move 'setInputDatasets' out                    July 12
# afy    Ver  68.02  Move 'checkNamelists' out                      July 12
# afy    Ver  68.03  Move 'setNamelists' out                        July 12
# afy    Ver  68.04  Modify 'setTables' (simplifications)           July 12
# afy    Ver  68.05  Modify 'process*' (call moved-out subroutines) July 12
# afy    Ver  68.06  Modify 'setTables' (standard return)           July 12
# afy    Ver  68.07  Modify 'outputScriptExecuteOrSubmit'           July 12
# afy    Ver  68.08  Use new module FRETemplate ('fre' argument)    July 12
# afy    Ver  69.00  Modify init (env-dependent modulefiles dir)    July 12
# afy    Ver  70.00  Modify init (rename envvar)                    July 12
# afy    Ver  71.00  Modify setMPI (support serial runs)            August 12
# afy    Ver  72.00  Modify init (set '*Init' constants)            October 12
# afy    Ver  72.01  Modify init (set '*Retries' constants)         October 12
# afy    Ver  72.02  Check --submit-{chained,staged} options        October 12
# afy    Ver  72.03  Refactor options cache handling                October 12
# vb     Ver  73.00  Process --submit-staged as --submit-chained    October 12
# afy    Ver  73.01  Allow --nocombine-history for production       October 12
# afy    Ver  74.00  Modify init (set 'flagVerbosity')              November 12
# afy    Ver  75.00  Add option --windfall                          December 12
# afy    Ver  75.01  Modify init (set windfall-dependent vars)      December 12
# afy    Ver  75.02  Use new FRETemplate (account, dualFlag)        December 12
# afy    Ver  76.00  Modify 'outputScriptExecuteOrSubmit'           January 13
# afy    Ver  77.00  Modify 'setMPI' (generics)                     February 13
# afy    Ver  78.00  Modify 'setMPI' (fix separator placing)        March 13
# afy    Ver  79.00  Modify 'init' (redesign ppStarter settings)    March 13
# afy    Ver  80.00  Modify setMPI (fix couplerless models)         April 12
# afy    Ver  81.00  Modify setMPI (use new FRETemplate.pm)         April 12
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2013
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use Cwd();
use Date::Manip();
use File::Basename();
use File::Spec();
use Getopt::Long( ':config', 'no_ignore_case', 'no_auto_abbrev' );
use List::Util();
use POSIX();

use FRE();
use FREDefaults();
use FREExperiment();
use FREMsg();
use FRENamelists();
use FREPlatforms();
use FRETargets();
use FRETemplate();
use FREUtil();
use Email::Valid;

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////// Global constants //
# //////////////////////////////////////////////////////////////////////////////

{

    package frerun;

    use constant VERSION => '$Id: frerun,v 18.0.2.81.4.3 2014/11/18 23:31:23 arl Exp $';

    use constant OPTLIST => (
        'archive|a!',             'check|c',
        'checksum|C',             'cache-history|H',
        'combine-history|M!',     'compress|z=s',
        'ht!',                    'mppnccombine-opts=s',
        'nc4-compress-history|Z', 'dual|D!',
        'extend|e',               'free|f!',
        'novalidate',             'output-staging|O=s',
        'overwrite|o',            'project|A=s',
        'regression|r=s',         'remote-user|R=s',
        'submit-chained|S',       'submit-staged',
        'transfer|T!',            'unique|u',
                                  'execute|E',
        'help|h',                 'ncores|n=i',
        'cluster|=s',             'platform|p=s',
        'qos|q=s',                'submit|s',
        'target|t=s',             'version|V',
        'verbose|v+',             'walltime|w=i',
        'xmlfile|x=s',            'mail-list=s',
        'force-pp'
    );

    use constant RUNSCRIPT_TEMPLATE_MAIN => 'runscript.template.main';

    use constant OUTPUT_COMPRESSION_TYPES => ( 'ascii', 'restart', 'history' );

    use constant NCORES_DEFAULT   => 2;
    use constant WALLTIME_DEFAULT => 30;

}

# //////////////////////////////////////////////////////////////////////////////
# ///////////////////////////////////////////////////////////////// Utilities //
# //////////////////////////////////////////////////////////////////////////////

{

    package frerun;

    my $self = File::Basename::basename($0);

    sub Usage()

        # ------ arguments: none
    {
        my $cwd = Cwd::getcwd();
        my $xml = FREDefaults::XMLFile();
        my $tgt = FREDefaults::Target();
        return (
            "\n",
            "  Usage: $self -p|--platform platform [options] experiment [experiment2 ...]\n\n",
            "  Options:\n\n",
            "   -a,        --archive                   save the model output in the archive (negatable, default is on)\n",
            "   -H,        --cache-history             cache history files at a post-processing site (instead of putting them into archive)\n",
            "   -c,        --check                     check the model output with the main model run (which makes sense for unique runs only)\n",
            "   -C,        --checksum                  compute checking sums for all the output data archives to enable their verification\n",
            "   -M,        --combine-history           combine history files after each segment run (negatable, default is on)\n",
            "   -z STRING, --compress=STRING           compress model output of type STRING (list of 'ascii', 'restart', 'history' or 'all')\n",
            "   -Z,        --nc4-compress-history      compress history files using Netcdf4 compression, deflation=2 and shuffle\n",
            "   -D,        --dual                      create a pair of runscripts - the main one and the dual one (negatable, default depends on site)\n",
            "   -e,        --extend                    extend default run of existing experiment\n",
            "   -f,        --free                      free working directory in the end of run (negatable, default depends on site)\n",
            "   -O STRING, --output-staging=STRING     type of output data staging (possible values depend on site)\n",
            "   -o,        --overwrite                 overwrite the main run of existing experiment\n",
            "   -A STRING, --project=STRING            project account STRING to charge model running time to\n",
            "   -r STRING, --regression=STRING         run in regression test mode STRING with minimal output processing\n",
            "   -R STRING, --remote-user=STRING        use the remote user STRING for the model output transfer to a post-processing site\n",
            "   -S,        --submit-chained            submit all the created scripts as input data staging jobs, submitting run jobs at their end\n",
            "   -T,        --transfer                  transfer all the model output back to a post-processing site (negatable, default depends on site)\n",
            "   -u,        --unique                    create a new unique run of existing experiment\n",
            "   -E,        --execute                   execute all the created scripts in the current session\n",
            "   -h,        --help                      print help message and exit\n",
            "   -n NUM,    --ncores=NUM                number of processor cores to use for input data staging (default depends on site)\n",
            "   -p STRING, --platform=STRING           hardware and software platform STRING (required)\n",
            "   -q STRING, --qos=STRING                quality-of-service STRING to pass to scheduler for model runs\n",
            "   -s,        --submit                    submit all the created scripts as batch jobs\n",
            "   -t STRING, --target=STRING             use compilation directives, targeted by STRING (default is '$tgt')\n",
            "   -V,        --version                   print the tool version and exit\n",
            "   -v,        --verbose                   get verbose messages (repeat the option to increase verbosity level)\n",
            "   -w NUM,    --walltime=NUM              maximum wall time (in minutes) to use for input data staging (default depends on site)\n",
            "   -x FILE,   --xmlfile=FILE              experiment suite XML configuration FILE (default is '$cwd/$xml')\n",
            "              --cluster=STRING            cluster STRING to use for model runs\n",
            "              --mail-list=STRING          email the comma-separated STRING list of emails rather than \$USER\@noaa.gov\n",
            "              --force-pp                  run the postprocesser starter even for regression or unique runs\n",
            "  The platform and at least one experiment from the FILE must be listed as an argument.\n\n"
        );
    } ## end sub Usage

    sub Help()

        # ------ arguments: none
    {
        my @usage = frerun::Usage();
        my $tgts  = join( "', '", FRETargets::all() );
        my $tgst  = join( "', '", FRETargets::starters() );
        return (
            "\n",
            "   Synopsis: $self creates a tcsh script to run FRE experiment(s).\n",
            "@usage",
            "   Use --noarchive to disallow saving model output into archive (valid for regression tests only).\n",
            "      The (unpacked) model output will be kept in the disk cache (ptmp) only.\n",
            "   Use --nocombine-history to disallow combining history files (valid for regression tests only).\n",
            "      This option is on by default, so history files will be combined after each segment run.\n",
            "   Use --overwrite, --extend or --unique to manipulate the experiment output directory.\n",
            "      You can completely overwrite the output directory, you can extend the run of the same experiment,\n",
            "      or you can create another unique instance of the output directory for the same experiment.\n",
            "   Use --dual to automatically create a pair of runscripts - the main one and the dual one.\n",
            "      The dual runscript is functionally identical to runscripts with --unique and --check options enabled,\n",
            "      it will keep the model output in a separate directory and compare it with the data from the main model run.\n",
            "      The --dual option is recognized for production runs only.\n",
            "   Use --regression to run a regression test instead of the <production> run.\n",
            "      Regression tests have minimal treatment of output files.\n",
            "      This option value can be a single regression test label, or a list of them, separated by comma.\n",
            "      Any number of regression tests can be requested. The keyword 'all' requests all of them,\n",
            "      The keyword 'suite' requests all available regression runs, labeled by 'basic', 'restarts' or 'scaling'.\n",
            "   Use --submit-chained to automatically submit all the created scripts in the chaining mode.\n",
            "      The script is submitted with parameters, which allow it to perform input data staging,\n",
            "      to submit the normal run script (provided that the input data staging was successful), and then exit.\n",
            "      This makes sense, when the input data staging script and the normal run script have to be executed\n",
            "      in different computing environments (different access to filesystems, etc).\n",
            "   Use --platform to pick a platform for experiment(s).\n",
            "      The <platform> node in the experiment suite configuration file is used\n",
            "      to set platform-specific data and instructions.\n",
            "   Use --target to define compilation and linkage directives for experiment(s).\n",
            "      Predefined targets refer to groups of directives, existing in the 'mkmf' template file.\n",
            "      Possible predefined targets are: '$tgts'.\n",
            "      Any number of targets from this list can be used here, and you can also add your own target (but not more than one).\n",
            "      Targets '$tgst' are mutually exclusive - not more than one of them is allowed in the target list.\n",
            "      Your own target should refer to a <compile> node with the corresponding value of its 'target' attribute.\n",
            "      Multiple targets are separated by comma or dash. All the directives, referred by multiple targets, are merged.\n",
            "   Use --execute to run the created script right away.\n",
            "      If the target platform is not where $self is being run, do not specify --execute.\n",
            "      Submit as a batch job or run by hand on the right platform.\n",
            "   Use --submit to automatically submit all the created scripts as batch jobs.\n\n"
        );
    } ## end sub Help

    sub regressionRunScriptName($$)

        # ------ arguments: $exp $extension
    {
        my ( $z, $x ) = @_;
        my ( $expName, $scriptsDir ) = ( $z->name(), $z->scriptsDir() );
        return "$scriptsDir/run/${expName}_$x";
    }

    sub productionRunScriptName($$)

        # ------ arguments: $exp $extension
    {
        my ( $z, $x ) = @_;
        my ( $expName, $scriptsDir ) = ( $z->name(), $z->scriptsDir() );
        return "$scriptsDir/run/$expName$x";
    }

    sub stdoutMainDir($)

        # ------ arguments: $exp
    {
        my $z         = shift;
        my $stdoutDir = $z->stdoutDir();
        return "$stdoutDir/run";
    }

    sub stdoutName($$)

        # ------ arguments: $exp $scriptName
    {
        my ( $z, $n ) = @_;
        my ( $basename, $stdoutTmpDir, $jobId )
            = ( File::Basename::basename($n), $z->stdoutTmpDir(), FREUtil::jobID() );
        return "$stdoutTmpDir/run/$basename.o$jobId";
    }

    sub createDirectory($$)

        # ------ arguments: $fre $directory
        # ------ create a directory
    {
        my ( $fre, $d ) = @_;
        if ( -d $d ) {
            if ( -w $d ) {
                return 1;
            }
            else {
                $fre->out( FREMsg::FATAL, "The directory '$d' exists, but it's not writable" );
                return 0;
            }
        }
        else {
            return FREUtil::createDir($d);
        }
    }

    sub getTemplate($$)

        # ------ arguments: $fre $filename
        # ------ returns a script template from the site directory
        # ------ return ($sript, $status)
    {
        my ( $fre, $n ) = @_;
        my $pathname = $fre->siteDir() . '/' . $n;
        if ( open my $templateHandle, '<', $pathname ) {
            $/ = undef;
            my $s = <$templateHandle>;
            $s =~ s/^# ?$//mg;
            $s =~ s/^# .*$//mg;
            $s =~ s/\n{2,}/\n\n/sg;
            close $templateHandle;
            return ( $s, FREDefaults::STATUS_OK );
        }
        else {
            $fre->out( FREMsg::FATAL, "The main runscript template '$pathname' isn't found" );
            return ( 0, FREDefaults::STATUS_FRE_RUN_NO_TEMPLATE );
        }
    }

    sub execName($)

        # ------ arguments: $exp
    {
        my $z = shift;
        my ( $value, $exp ) = $z->extractExecutable();
        if ($value) {
            return $value;
        }
        elsif ($exp) {
            return $exp->executable();
        }
        else {
            return undef;
        }
    }

    sub getRemoteDirs($$$)

        # ------ arguments: $exp $platform $user
    {
        my ( $z, $p, $u ) = @_;
        my ( $fre,    $expName ) = ( $z->fre(),      $z->name() );
        my ( $target, $xmlfile ) = ( $fre->target(), $fre->configFileAbsPathName() );
        my $cmd
            = "frelist --xmlfile=$xmlfile --platform=$p --target=$target --novalidate --directory=stdout,stmp,archive,include $expName";
        $cmd .= " --remote-user=$u" if $u;
        my $res = qx($cmd);
        if ( $? == 0 ) {
            my @res = ();
            foreach my $dir ( split( /\n/, $res ) ) {
                $dir =~ s/^\w+: //;
                push @res, $dir;
            }
            return @res;
        }
        else {
            return ();
        }
    } ## end sub getRemoteDirs($$$)

    sub getRemotePlatformCsh($$)

        # ------ arguments: $exp $platform
    {
        my ( $z, $p ) = @_;
        my $fre = $z->fre();
        my ( $target, $xmlfile ) = ( $fre->target(), $fre->configFileAbsPathName() );
        my $cmd
            = "frelist --xmlfile=$xmlfile --platform=$p --target=$target --novalidate --platform-csh";
        my $res = qx($cmd);
        if ( $? == 0 ) {
            $res =~ s/^\s*//mg;
            $res =~ s/ +/ /mg;
            $res =~ s/\$/\\\$/mg;
            $res =~ s/\t+/\t/mg;
            $res =~ s/\n+/\n/sg;
            $res =~ s/(?: |\t)/+/sg;
            $res =~ s/\n/:/sg;
            $res = $z->placeholdersExpand($res);
            return $res;
        }
        else {
            return '';
        }
    } ## end sub getRemotePlatformCsh($$)

    sub getRemoteProject($$)

        # ------ arguments: $exp $platform
    {
        my ( $z, $p ) = @_;
        my ( $fre,    $expName ) = ( $z->fre(),      $z->name() );
        my ( $target, $xmlfile ) = ( $fre->target(), $fre->configFileAbsPathName() );
        my $cmd
            = "frelist --xmlfile=$xmlfile --platform=$p --target=$target --novalidate --get-project $expName";
        my $res = qx($cmd);
        chomp $res;
        if ( $? == 0 ) {
            $res =~ s/\s*//g;
            if ( $res ) {
                return $res;
            }
            else {
                return '';
            }
        }
        else {
            return '';
        }
    }

    sub init($%)

        # ------ arguments: $exp %options
        # ------ return ($sript, $status)
    {

        my ( $z, %o ) = @_;
        my $fre = $z->fre();

        my ( $s, $status ) = frerun::getTemplate( $fre, frerun::RUNSCRIPT_TEMPLATE_MAIN );
        if ($s) {

            # ------------------------------------- executable

            my $execName = frerun::execName($z);
            if ($execName) {
                if ( -f $execName ) {
                    if ( -x $execName ) {
                        $fre->out( FREMsg::NOTE, "Using executable '$execName'..." );
                    }
                    else {
                        $fre->out( FREMsg::FATAL,
                            "Your executable '$execName' exists, but you don't have permissions to run it"
                        );
                        return ( 0, FREDefaults::STATUS_FS_PERMISSION_PROBLEM );
                    }
                }
                else {
                    $fre->out( FREMsg::WARNING, "Your executable '$execName' doesn't exist" );
                }
            }
            else {
                $fre->out( FREMsg::FATAL, "Can't determine the executable pathname" );
                return ( 0, FREDefaults::STATUS_FRE_GENERIC_PROBLEM );
            }

# ------------------------------------------------------------------------ output data staging and transfer

            my @flagOutputStagingTypes       = split( /;/, $fre->property('FRE.output.staging') );
            my $flagOutputStagingTypeDefault = $flagOutputStagingTypes[0];
            my $flagOutputStagingType        = $o{'output-staging'}
                || $z->extractValue('postProcess/@combine');
            my $flagOutputTransfer = ( $o{transfer} ) ? 'On' : 'Off';

            if ($flagOutputStagingType) {
                if ( scalar( grep( $_ eq $flagOutputStagingType, @flagOutputStagingTypes ) ) > 0 ) {
                    $fre->out( FREMsg::NOTE,
                        "The '$flagOutputStagingType' output staging type will be used..." );
                }
                else {
                    $fre->out( FREMsg::WARNING,
                        "The '$flagOutputStagingType' output staging type isn't supported at this site - using the '$flagOutputStagingTypeDefault' one..."
                    );
                    $flagOutputStagingType = $flagOutputStagingTypeDefault;
                }
            }
            else {
                $fre->out( FREMsg::WARNING,
                    "The output staging type isn't defined - using the '$flagOutputStagingTypeDefault' one..."
                );
                $flagOutputStagingType = $flagOutputStagingTypeDefault;
            }

            my $roots
                = $fre->property(
                "FRE.output.staging.$flagOutputStagingType.transfer$flagOutputTransfer.archive.roots"
                );
            if ($roots) {
                my ( $archiveDir, $rootsForMatch ) = ( $z->archiveDir(), $roots );
                $rootsForMatch =~ s/\$/\\\$/g;
                if (scalar( grep( "$archiveDir/" =~ m/^$_\//, split( ';', $rootsForMatch ) ) )
                    == 0 ) {
                    my ( $msg, @roots ) = ( '', split( ';', $roots ) );
                    if ( scalar(@roots) > 1 ) {
                        my $rootsForOut = join( ', ', @roots );
                        $msg = "one of ($rootsForOut) filesystems";
                    }
                    else {
                        $msg = "the '$roots[0]' filesystem";
                    }
                    my $flagOutputTransferMsg
                        = ( $flagOutputTransfer eq 'On' ) ? '--transfer' : '--notransfer';
                    $fre->out( FREMsg::FATAL,
                        "Combination of options --output-staging=$flagOutputStagingType and $flagOutputTransferMsg requires the archive directory to be on $msg"
                    );
                    return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                }
            } ## end if ($roots)
            else {
                $fre->out( FREMsg::FATAL,
                    "The 'FRE.output.staging.$flagOutputStagingType.transfer$flagOutputTransfer.archive.roots' external property is absent or empty!!!"
                );
                return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
            }

            if ( $flagOutputTransfer eq 'On' ) {
                if ( scalar(@flagOutputStagingTypes) == 1 or $flagOutputStagingType ne 'online' ) {
                    $fre->out( FREMsg::NOTE,
                        "The model output will be transferred to the post-processing site..." );
                }
                else {
                    $flagOutputTransfer = 'Off';
                    $fre->out( FREMsg::WARNING,
                        "You can use the --transfer option only when the staging type isn't online - ignored..."
                    );
                }
            }

# --------------------------------------------------------------------------------------- history combining

            my $flagOutputCombineHistory = ( $o{'combine-history'} ) ? 'On' : 'Off';
            if ( $flagOutputCombineHistory eq 'Off' ) {
                $fre->out( FREMsg::NOTE, "The history won't be combined..." );
            }

# ---------------------------------------------------------------------------------------- combiner options

            # For information about combiner flags, see the combiner help menu with `mppncombine -h'

            my $mppnccombineOptsDefault = "'-64 -h 16384 -m'";
            my $mppnccombineOptsRestart = $mppnccombineOptsDefault;
            my $mppnccombineOptsHistory = $mppnccombineOptsDefault;

# If hidden combiner string specified by --mppnccombine-opts flag found, use it. (This overrides any default behavior)
            if ( exists $o{'mppnccombine-opts'} ) {
                $mppnccombineOptsHistory = "'$o{'mppnccombine-opts'}'";
            }

# If combiner compression flag present, use a default compression setting of deflation level 2 and shuffling turned on
            elsif ( exists $o{'nc4-compress-history'} ) {
                $mppnccombineOptsHistory = "'-n4 -d 2 -s -h 16384 -m'";
            }

 # -------------------------------------------------------------------------------- output archiving

            my $flagOutputArchive = ( $o{archive} ) ? 'On' : 'Off';
            if ( $flagOutputArchive eq 'Off' ) {
                if ( $o{regression} ) {
                    $fre->out( FREMsg::NOTE,
                        "The model output will be kept in the disk cache only..." );
                }
                else {
                    $flagOutputArchive = 'On';
                    $fre->out( FREMsg::WARNING,
                        "You can use the --noarchive option for regression tests only - ignored..."
                    );
                }
            }

# ------------------------------------------------------------------------------ output post-processing

            my $flagOutputPostProcess = ( !$o{regression} && !$o{unique} ) ? 'On' : $o{'force-pp'} ? 'On' : 'Off';

# ------------------------------------------------------------------------- getFmsData and its parameters

            my @getFmsData = ( $fre->getFmsData() || '$freCommandsHomeDir/bin/get_fms_data' );
            my $fmsRelease = $fre->fmsRelease();
            push @getFmsData, ( '-r', $fmsRelease ) if $fmsRelease;

# -------------------------------------------------------------------------- remote directories for transfer

            my ( $remotePlatform, $remoteUser, @remoteDirs ) = ( '', '', '', '', '' );
            if ( $flagOutputTransfer eq 'On' ) {
                ( $remotePlatform, $remoteUser )
                    = ( FREPlatforms::siteReplace( $fre->platform(), 'gfdl' ), $o{'remote-user'} );
                @remoteDirs = frerun::getRemoteDirs( $z, $remotePlatform, $remoteUser );
                if ( scalar(@remoteDirs) > 0 ) {
                    $fre->out( FREMsg::NOTE,
                        "Remote directories to be used:",
                        "stdout  = $remoteDirs[0]",
                        "stmp    = $remoteDirs[1]",
                        "archive = $remoteDirs[2]",
                        "include = $remoteDirs[3]"
                    );
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "Unable to determine remote directories - please check your platform '$remotePlatform'"
                    );
                    return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                }
            } ## end if ( $flagOutputTransfer...)

# --------------------------------------------------------------------- various remote settings for post-processing

            my ( $remoteModuleFilesDir, $remoteVersion, $remotePlatformCsh, $remoteProject ) = ( '', '', '', '', '' );
            if ( $flagOutputTransfer eq 'On' && $flagOutputPostProcess eq 'On' ) {
                $remoteModuleFilesDir = $fre->property('FRE.tool.modules.use.remote');
                $remotePlatformCsh = frerun::getRemotePlatformCsh( $z, $remotePlatform );
                if ($remotePlatformCsh) {
                    $fre->out( FREMsg::NOTE,
                        "Remote platform csh to be used - '$remotePlatformCsh'" );
                    $remotePlatformCsh =~ m|fre/([\w-]+)|;
                    $remoteVersion = $1 if $1;
                    if ($remoteVersion) {
                        $fre->out( FREMsg::NOTE, "Remote FRE version - $remoteVersion" );
                    }
                    else {
                        $fre->out( FREMsg::NOTE, "Unable to determine remote FRE version" );
                    }
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "Unable to determine remote platform csh - please check your platform '$remotePlatform'"
                    );
                    return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                }
                $remoteProject = frerun::getRemoteProject($z, $remotePlatform);
                if ($remoteProject) {
                    $fre->out( FREMsg::NOTE, "Remote project - $remoteProject" );
                }
                else {
                    $remoteProject = $fre->project();
                    $fre->out( FREMsg::NOTE, "Remote project not found; using $remoteProject" );
                }
            } ## end if ( $flagOutputTransfer...)

# ------------------------------------------------------------------------ verify include directory
            my ( $includeDir, $includeDirRemote ) = ( $z->includeDir, $remoteDirs[3] );
            if ( !-e $includeDir ) {
                $fre->out( FREMsg::NOTE, sprintf "Include directory '$includeDir' doesn't exist" );
                $includeDir = $includeDirRemote = "";
            }
            elsif ( -d $includeDir ) {
                chomp( my $du = `du -smL $includeDir 2> /dev/null` );
                my $size = ( split ' ', $du )[0];
                if ( $size <= 300 ) {
                    $fre->out( FREMsg::NOTE, "Size of include directory '$includeDir': $size MB" );
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "Size of include directory '$includeDir' ($size MB) exceeds 300MB limit; please reduce the directory's size"
                    );
                    return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                }
            }
            else {
                $fre->out( FREMsg::FATAL,
                    sprintf "Include directory '$includeDir' exists, but isn't a directory" );
                return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
            }

# ------------------------------------------------------------------------ verify transfer capability if needed
            if ( $flagOutputTransfer eq 'On' and $fre->property('FRE.tool.gcp.precheck') ) {
                FREMsg::out( 1, FREMsg::NOTE, '' );
                FREMsg::out( 1, FREMsg::NOTE,
                    'This site requires verifying transfer capability to remote site; checking now...',
                );
                my $cmd = 'gcp --auth';
                $fre->out(FREMsg::NOTE, $cmd);
                system $cmd;
                if ( $? == 0 ) {
                    FREMsg::out( 1, FREMsg::NOTE, '' );
                    FREMsg::out( 1, FREMsg::NOTE, 'Verified transfer certificates to remote site!' );
                }
                else {
                    FREMsg::out( 1, FREMsg::NOTE, 'Transfer certificates must be updated.',
                        'Please answer any prompts and renew certificates as instructed.' );
                    my $cmd = "gcp --auth $ENV{FRE_SYSTEM_SITE}: gfdl:";
                    $fre->out(FREMsg::NOTE, $cmd);
                    system $cmd;
                    if ( $? == 0 ) {
                        FREMsg::out( 1, FREMsg::NOTE, 'Successfully updated transfer certificates!' );
                    }
                    else {
                        $fre->out(FREMsg::WARNING, '');
                        $fre->out(FREMsg::WARNING, 'Transfer certificates not updated; transfer jobs may fail!' );
                        $fre->out(FREMsg::WARNING, '');
                    }
                    sleep 2;
                }
            }
            else {
                $fre->out( FREMsg::NOTE, "No need to verify transfer capability to remote site." )
            }

# ------------------------------------------------------------------------- setting constants/variables

            FRETemplate::setFlag( $fre, \$s, 'flagRunType',
                ( $o{regression} ) ? 'Regression' : 'Production' );
            FRETemplate::setFlag( $fre, \$s, 'flagCheckSum',     ( $o{checksum} ) ? 'On' : 'Off' );
            FRETemplate::setFlag( $fre, \$s, 'flagWorkDirClean', ( $o{free} )     ? 'On' : 'Off' );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputType',
                ( $o{extend} )
                ? 'Extend'
                : ( ( $o{overwrite} ) ? 'Overwrite' : ( ( $o{unique} ) ? 'Unique' : 'Initial' ) ) );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputFormat',
                ( FRETargets::containsHDF5( $fre->target() ) ) ? 'HDF5' : '64Bit' );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputStagingType',
                ucfirst $flagOutputStagingType );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputCacheHistory',
                ( $o{'cache-history'} ) ? 'On' : 'Off' );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputCombineHistory',
                $flagOutputCombineHistory );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputCompressAscii',
                ( $o{compress} =~ m/ascii/ ) ? 'On' : 'Off' );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputCompressRestart',
                ( $o{compress} =~ m/restart/ ) ? 'On' : 'Off' );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputCompressHistory',
                ( $o{compress} =~ m/history/ ) ? 'On' : 'Off' );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputArchive',     $flagOutputArchive );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputPostProcess', $flagOutputPostProcess );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputXfer',        $flagOutputTransfer );
            FRETemplate::setFlag( $fre, \$s, 'flagOutputCheck', ( $o{check} )   ? 'On' : 'Off' );
            FRETemplate::setFlag( $fre, \$s, 'flagVerbosity',   ( $o{verbose} ) ? 'On' : 'Off' );

            FRETemplate::setVariable( $fre, \$s, 'modulesHomeDir',
                $fre->property('FRE.tool.modules.home') );
            FRETemplate::setVariable( $fre, \$s, 'freCommandsModuleFilesDir',
                $ENV{FRE_SYSTEM_MODULEFILES_DIR} || $fre->property('FRE.tool.modules.use') );
            FRETemplate::setVariable( $fre, \$s, 'freCommandsVersion', $ENV{FRE_COMMANDS_VERSION} );

            FRETemplate::setVariable( $fre, \$s, 'project', $fre->project() );
            FRETemplate::setVariable( $fre, \$s, 'projectRemote', "'$remoteProject'" );
            FRETemplate::setVariable( $fre, \$s, 'clusterInit', $o{cluster} );

            FRETemplate::setVariable( $fre, \$s, 'platform',   $fre->platform() );
            FRETemplate::setVariable( $fre, \$s, 'target',     $fre->target() );
            FRETemplate::setVariable( $fre, \$s, 'name',       $z->name() );
            FRETemplate::setVariable( $fre, \$s, 'rtsxml',     $fre->configFileAbsPathName() );
            FRETemplate::setVariable( $fre, \$s, 'stdoutDir',  frerun::stdoutMainDir($z) );
            FRETemplate::setVariable( $fre, \$s, 'workDir',    $z->workDir() );
            FRETemplate::setVariable( $fre, \$s, 'ptmpDir',    $z->ptmpDir() );
            FRETemplate::setVariable( $fre, \$s, 'archiveDir', $z->archiveDir() );
            FRETemplate::setVariable( $fre, \$s, 'executable', $execName );
            FRETemplate::setVariable( $fre, \$s, 'mailMode',   $fre->mailMode() );
            FRETemplate::setVariable( $fre, \$s, 'mailList',   $fre->{mailList} );
            FRETemplate::setVariable( $fre, \$s, 'includeDir', $includeDir );

            FRETemplate::setVariable( $fre, \$s, 'platformRemote',   "'$remotePlatform'" );
            FRETemplate::setVariable( $fre, \$s, 'userRemote',       "'$remoteUser'" );
            FRETemplate::setVariable( $fre, \$s, 'stdoutDirRemote',  "'$remoteDirs[0]'" );
            FRETemplate::setVariable( $fre, \$s, 'stmpDirRemote',    "'$remoteDirs[1]'" );
            FRETemplate::setVariable( $fre, \$s, 'archiveDirRemote', "'$remoteDirs[2]'" );
            FRETemplate::setVariable( $fre, \$s, 'includeDirRemote', $includeDirRemote );
            FRETemplate::setVariable( $fre, \$s, 'freCommandsModuleFilesDirRemote',
                "'$remoteModuleFilesDir'" );
            FRETemplate::setVariable( $fre, \$s, 'freCommandsVersionRemote', "'$remoteVersion'" );
            FRETemplate::setVariable( $fre, \$s, 'envRemote', "'$remotePlatformCsh'" );

            FRETemplate::setVariable( $fre, \$s, 'outputStagerSaveCluster',
                $fre->property('FRE.scheduler.outputStager.save.cluster') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerSavePartition',
                $fre->property('FRE.scheduler.outputStager.save.partition') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerSaveCoreSpec',
                $fre->property('FRE.scheduler.outputStager.save.coreSpec') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerSaveRuntimeAscii',
                       $fre->property('FRE.scheduler.outputStager.save.runtime.ascii')
                    || $fre->property('FRE.scheduler.runtime.max') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerSaveRuntimeRestart',
                       $fre->property('FRE.scheduler.outputStager.save.runtime.restart')
                    || $fre->property('FRE.scheduler.runtime.max') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerSaveRuntimeHistory',
                       $fre->property('FRE.scheduler.outputStager.save.runtime.history')
                    || $fre->property('FRE.scheduler.runtime.max') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerSaveRetries',
                $fre->property('FRE.scheduler.outputStager.save.retries') );

            FRETemplate::setVariable( $fre, \$s, 'outputStagerXferCluster',
                $fre->property('FRE.scheduler.outputStager.transfer.cluster') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerXferPartition',
                $fre->property('FRE.scheduler.outputStager.transfer.partition') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerXferCoreSpec',
                $fre->property('FRE.scheduler.outputStager.transfer.coreSpec') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerXferRuntimeAscii',
                       $fre->property('FRE.scheduler.outputStager.transfer.runtime.ascii')
                    || $fre->property('FRE.scheduler.runtime.max') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerXferRuntimeRestart',
                       $fre->property('FRE.scheduler.outputStager.transfer.runtime.restart')
                    || $fre->property('FRE.scheduler.runtime.max') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerXferRuntimeHistory',
                       $fre->property('FRE.scheduler.outputStager.transfer.runtime.history')
                    || $fre->property('FRE.scheduler.runtime.max') );
            FRETemplate::setVariable( $fre, \$s, 'outputStagerXferRetries',
                $fre->property('FRE.scheduler.outputStager.transfer.retries') );

            FRETemplate::setVariable( $fre, \$s, 'workDirCleanerPartition',
                $fre->property('FRE.scheduler.workDirCleaner.partition') );
            FRETemplate::setVariable( $fre, \$s, 'workDirCleanerCoreSpec',
                $fre->property('FRE.scheduler.workDirCleaner.coreSpec') );
            FRETemplate::setVariable( $fre, \$s, 'workDirCleanerRuntime',
                       $fre->property('FRE.scheduler.workDirCleaner.runtime')
                    || $fre->property('FRE.scheduler.runtime.max') );

            FRETemplate::setVariable( $fre, \$s, 'finisherPartition',
                $fre->property('FRE.scheduler.finisher.partition') );
            FRETemplate::setVariable( $fre, \$s, 'finisherCoreSpec',
                $fre->property('FRE.scheduler.finisher.coreSpec') );
            FRETemplate::setVariable( $fre, \$s, 'finisherRuntime',
                       $fre->property('FRE.scheduler.finisher.runtime')
                    || $fre->property('FRE.scheduler.runtime.max') );

            FRETemplate::setVariable( $fre, \$s, 'ppStarterCluster',
                $fre->property('FRE.scheduler.ppStarter.cluster') );
            FRETemplate::setVariable( $fre, \$s, 'ppStarterPartition',
                $fre->property('FRE.scheduler.ppStarter.partition') );
            FRETemplate::setVariable( $fre, \$s, 'ppStarterCoreSpec',
                $fre->property('FRE.scheduler.ppStarter.coreSpec') );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterCombineOffLargeOffConstraint',
                $fre->property('FRE.scheduler.ppStarter.combineOff.largeOff.constraint')
            );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterCombineOffLargeOffRuntime',
                $fre->property('FRE.scheduler.ppStarter.combineOff.largeOff.runtime')
            );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterCombineOffLargeOnConstraint',
                $fre->property('FRE.scheduler.ppStarter.combineOff.largeOn.constraint')
            );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterCombineOffLargeOnRuntime',
                $fre->property('FRE.scheduler.ppStarter.combineOff.largeOn.runtime')
            );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterCombineOnLargeOffConstraint',
                $fre->property('FRE.scheduler.ppStarter.combineOn.largeOff.constraint')
            );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterCombineOnLargeOffRuntime',
                $fre->property('FRE.scheduler.ppStarter.combineOn.largeOff.runtime')
            );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterCombineOnLargeOnConstraint',
                $fre->property('FRE.scheduler.ppStarter.combineOn.largeOn.constraint')
            );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterCombineOnLargeOnRuntime',
                $fre->property('FRE.scheduler.ppStarter.combineOn.largeOn.runtime')
            );
            FRETemplate::setVariable(
                $fre, \$s,
                'ppStarterHistorySizeThreshold',
                $fre->property('FRE.scheduler.ppStarter.historySize.threshold')
            );

            FRETemplate::setList( $fre, \$s, 'ppRefineDiagScriptNames',
                $z->extractPPRefineDiagScripts() );
            FRETemplate::setList( $fre, \$s, 'getFmsData', @getFmsData );

            FRETemplate::setVariable( $fre, \$s, 'mppnccombineOptsRestart',
                $mppnccombineOptsRestart );
            FRETemplate::setVariable( $fre, \$s, 'mppnccombineOptsHistory',
                $mppnccombineOptsHistory );

            FRETemplate::setVariable( $fre, \$s, 'FreCommandsSrcDir',
                $z->extractExecutable()->srcDir() );
            FRETemplate::setVariable( $fre, \$s, 'FreCommandsBldDir',
                $z->extractExecutable()->execDir() );

            # ------------------------------------------ normal return

            return ( $s, FREDefaults::STATUS_OK );

        } ## end if ($s)
        else {

            return ( 0, $status );

        }

    } ## end sub init($%)

    sub setInputVariableFile($$$)

        # ------ arguments: $refToScript $exp $variableName
        # ------ internal helper to setup an input file, defined via a shell variable
    {
        my ( $r, $z, $n ) = @_;
        my ( $fre, $fileName ) = ( $z->fre(), $z->extractVariableFile($n) );
        if ($fileName) {
            $fre->out( FREMsg::NOTE, "name='$n' value='$fileName'" );
            FRETemplate::setVariable( $fre, $r, $n, $fileName );
        }
        else {
            $fre->out( FREMsg::WARNING, "Variable '$n' has no value" );
            FRETemplate::setVariable( $fre, $r, $n, "''" );
        }
    }

    sub setInputInitialConditions($$)

        # ------ arguments: $refToScript $exp
    {
        my ( $r, $z ) = @_;
        frerun::setInputVariableFile( $r, $z, 'initCond' );
    }

    sub setInputGridSpecification($$)

        # ------ arguments: $refToScript $exp
    {
        my ( $r, $z ) = @_;
        frerun::setInputVariableFile( $r, $z, 'gridSpec' );
    }

    sub setAllShellCommands($$)

        # ------ arguments: $refToScript $exp
    {

        my ( $r, $z ) = @_;
        my $fre = $z->fre();

        my %adjustment = (
            init     => [ 'if ( $currentSeg == 1 ) then' . "\n", "\n" . 'endif' . "\n" ],
            postInit => [ 'if ( $currentSeg != 1 ) then' . "\n", "\n" . 'endif' . "\n" ]
        );

        FRETemplate::setShellCommands( $fre, $r, 'platformCsh',
            $fre->default_platform_csh . $fre->platformValue('csh') );
        FRETemplate::setShellCommands( $fre, $r, 'NiNaCplatformCsh',
            FREPlatforms::getPlatformSpecificNiNaCLoadCommands() );
        FRETemplate::setShellCommands( $fre, $r, 'expRuntimeCsh',
            $z->extractShellCommands('runtime/csh') );
        FRETemplate::setShellCommands(
            $fre, $r,
            'expInputCshInit',
            $z->extractShellCommands(
                'input/csh[not(@type="always") and not(@type="postInit")]', %adjustment
            )
        );
        FRETemplate::setShellCommands(
            $fre, $r,
            'expInputCshAlwaysOrNotInit',
            $z->extractShellCommands(
                'input/csh[@type="always" or @type="postInit"]', %adjustment
            )
        );
        FRETemplate::setShellCommands( $fre, $r, 'expPostProcessCsh',
            $z->extractShellCommands('postProcess/csh') );

    } ## end sub setAllShellCommands($$)

    sub calendarType($)

        # ------ arguments: $namelistsHandle
    {
        my $h      = shift;
        my $result = 'no_calendar';
        foreach my $name ( 'coupler_nml', 'main_nml', 'ocean_solo_nml', 'standalone_rad_nml' ) {
            my $value = $h->namelistDoubleQuotedStringGet( $name, 'calendar' )
                || $h->namelistSingleQuotedStringGet( $name, 'calendar' );
            if ($value) {
                $result = $value;
                last;
            }
        }
        return $result;
    }

    sub baseDate($)

        # ------ arguments: $namelistsHandle
    {
        my $h = shift;
        my $baseDate = $h->namelistDateGet( 'coupler_nml', 'current_date' ) || '0,0,0,0,0,0';
        $baseDate =~ s/,/ /g;
        return $baseDate;
    }

    sub setTables($$$)

        # ------ arguments: $refToScript $exp $namelistsHandle
    {

        my ( $r, $z, $h ) = @_;
        my $fre = $z->fre();

        $fre->out( FREMsg::NOTE, "Extracting tables..." );

        # -------------------------------------------------------------- diagTable

        if ( defined( my $diagTable = $z->extractTable('diagTable') ) ) {
            my $baseDate = frerun::baseDate($h);
            FRETemplate::setVariable( $fre, $r, 'baseDate', "'$baseDate'" );
            $diagTable =~ s/^\s*\$baseDate\s*$/$baseDate/m;
            FRETemplate::setTable( $fre, $r, 'diag_table', $diagTable );
        }
        else {
            $fre->out( FREMsg::FATAL, "A problem with the diagnostic table" );
            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
        }

        # -------------------------------------------------------------------------- fieldTable

        if ( defined( my $fieldTable = $z->extractTable('fieldTable') ) ) {
            if ( $h->namelistGet('coupler_nml') ) {

                # Adding a new line character just in case ...
                $fieldTable .= "\n";
                if ( $fieldTable !~ /^\s*"TRACER"\s*,\s*"atmos_mod"\s*,\s*"sphum".*/im ) {
                    $fieldTable .= '# added by FRE: sphum must be present in atmos' . "\n";
                    $fieldTable .= ' "TRACER", "atmos_mod",    "sphum"' . "\n";
                    $fieldTable .= '           "longname",     "specific humidity"' . "\n";
                    $fieldTable .= '           "units",        "kg/kg" /' . "\n";
                }
                if ( $fieldTable !~ /^\s*"TRACER"\s*,\s*"land_mod"\s*,\s*"sphum".*/im ) {
                    $fieldTable .= '# added by FRE: sphum must be present on land' . "\n";
                    $fieldTable .= ' "TRACER", "land_mod",     "sphum"' . "\n";
                    $fieldTable .= '           "longname",     "specific humidity"' . "\n";
                    $fieldTable .= '           "units",        "kg/kg" /' . "\n";
                }
            }
            FRETemplate::setTable( $fre, $r, 'field_table', $fieldTable );
        } ## end if ( defined( my $fieldTable...))
        else {
            $fre->out( FREMsg::FATAL, "A problem with the field table" );
            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
        }

        # -------------------------------------------------------------------------------- dataTable

        if ( defined( my $dataTable = $z->extractTable('dataTable') ) ) {
            FRETemplate::setTable( $fre, $r, 'data_table', $dataTable );
        }
        else {
            $fre->out( FREMsg::FATAL, "A problem with the data table" );
            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
        }

        # ------------------------------------------------------------------------ tracerTreeTable

        if ( defined( my $tracerTreeTable = $z->extractTable('tracerTreeTable') ) ) {
            FRETemplate::setTable( $fre, $r, 'ocean_tracer_tree', $tracerTreeTable );
        }
        else {
            $fre->out( FREMsg::FATAL, "A problem with the tracer tree table" );
            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
        }

        # -------------------------------------------------------------------- tracerTreeInit

        if ( defined( my $tracerTreeInit = $z->extractTable('tracerTreeInit') ) ) {
            FRETemplate::setTable( $fre, $r, 'ocean_tracer_tree_init', $tracerTreeInit );
        }
        else {
            $fre->out( FREMsg::FATAL, "A problem with the tracer tree initialization" );
            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
        }

        # ------------------------------- normal return

        return ( 1, FREDefaults::STATUS_OK );

    } ## end sub setTables($$$)

    sub setRegressionTimingParameters($$$$$$)

        # ------ arguments: $refToScript $exp $refToInfo $cluster $qos $dualFlag
    {

        my ( $r, $z, $i, $c, $q, $f ) = @_;
        my ( $expName, $fre ) = ( $z->name(), $z->fre() );

        # -------------------------------------------- extract timing parameters
        my @ma = split( ' ', $i->{months} );
        my @da = split( ' ', $i->{days} );
        my @ha = split( ' ', $i->{hours} );
        my $rt = $i->{runTimeMinutes};

 # ------------------------------------------------------------- set timing parameters in the script
        FRETemplate::setVariable( $fre, $r, 'segmentsPerSimulation', scalar(@ma) );
        FRETemplate::setVariable( $fre, $r, 'segmentsPerPPCall',     0 );
        FRETemplate::setVariable( $fre, $r, 'segmentsPerJob',        scalar(@ma) );
        FRETemplate::setVariable( $fre, $r, 'jobsPerSimulation',     1 );
        FRETemplate::setList( $fre, $r, 'monthslist', @ma );
        FRETemplate::setList( $fre, $r, 'dayslist',   @da );
        FRETemplate::setList( $fre, $r, 'hourslist',  @ha );

        # -------------------------------------------------------------- set scheduler resources
        FRETemplate::setSchedulerResources( $fre, $r, 'run', undef, $rt, $c, $q, $f );
    } ## end sub setRegressionTimingParameters($$$$$$)

    sub setProductionTimingParameters($$$$$$)

        # ------ arguments: $refToScript $exp $refToInfo $cluster $qos $dualFlag
    {
        my ( $r, $z, $i, $c, $q, $f ) = @_;
        my ( $expName, $fre ) = ( $z->name(), $z->fre() );

        # -------------------------------------------- extract timing parameters
        my $simTime    = $i->{simTimeMonths};
        my $simRunTime = $i->{simRunTimeMinutes};
        my $segTime    = $i->{segTimeMonths};
        my $segRunTime = $i->{segRunTimeMinutes};

# ---------------------------------------------------------------------------- print original values
        $fre->out( FREMsg::NOTE, "simTime = $simTime months, segTime = $segTime months" );
        $fre->out( FREMsg::NOTE,
            "simRunTime = $simRunTime minutes, segRunTime = $segRunTime minutes" );

# --------------------------------------------------------------------------------- calculate major timing parameters
        my $segPerSim = POSIX::ceil( $simTime / $segTime );
        $fre->out( FREMsg::NOTE,
            "segPerSim ($segPerSim) = simTime ($simTime) / segTime ($segTime) (rounded up)" );
        my $segPerJob = POSIX::floor( $simRunTime / $segRunTime );
        $fre->out( FREMsg::NOTE,
            "segPerJob ($segPerJob) = simRunTime ($simRunTime) / segRunTime ($segRunTime) (rounded down)"
        );
        my $jobPerSim = POSIX::ceil( $segPerSim / $segPerJob );
        $fre->out( FREMsg::NOTE,
            "jobPerSim ($jobPerSim) = segPerSim ($segPerSim) / segPerJob ($segPerJob) (rounded up)"
        );

# ------------------------------------------------------------------------------------------------ create months/days lists
        my @ma = ($segTime) x $segPerJob;
        my @da = ('0') x $segPerJob;
        my @ha = ('0') x $segPerJob;

# ------------------------------------------------------------------------ calculate the segments number per post-processor call
        my $segmentsPerPPCall = 0;
        if ( $simTime >= 12 ) {
            if ( 12 % $segTime == 0 ) {
                $segmentsPerPPCall = 12 / $segTime;
            }
            else {
                $fre->out( FREMsg::WARNING,
                    "The segment length ($segTime months) is not a divisor of 12 - the postprocessor won't be called"
                );
            }
        }
        else {
            $fre->out( FREMsg::WARNING,
                "The production run length ($simTime months) < 1 year - the postprocessor won't be called"
            );
        }

# ------------------------------------------------------------------------------ set timing parameters in the script
        FRETemplate::setVariable( $fre, $r, 'segmentsPerSimulation', $segPerSim );
        FRETemplate::setVariable( $fre, $r, 'segmentsPerPPCall',     $segmentsPerPPCall );
        FRETemplate::setVariable( $fre, $r, 'segmentsPerJob',        $segPerJob );
        FRETemplate::setVariable( $fre, $r, 'jobsPerSimulation',     $jobPerSim );
        FRETemplate::setList( $fre, $r, 'monthslist', @ma );
        FRETemplate::setList( $fre, $r, 'dayslist',   @da );
        FRETemplate::setList( $fre, $r, 'hourslist',  @ha );

     # --------------------------------------------------------------------- set scheduler resources
        FRETemplate::setSchedulerResources( $fre, $r, 'run', undef, $simRunTime, $c, $q, $f );
    } ## end sub setProductionTimingParameters($$$$$$)

    sub setRegressionDirectories($$$%)

# ------ arguments: $script $exp $extension %options
# ------ setups state and output directories and writes them in the script
# ------ if the state directory exists and the "unique" option is on, then appends a number to the $extension
# ------ if the state directory exists and the "overwrite" option is on, then removes both directories and recreates the state one
# ------ return ($script, $extension, $status)
    {

        my ( $s, $z, $x, %o ) = @_;

        my ( $fre, $sd, $od, $res )
            = ( $z->fre(), $z->stateDir() . "/$x", $z->archiveDir() . "/$x", '' );

        if ( -d $sd ) {
            if ( -w $sd ) {
                if ( $o{unique} ) {
                    {
                        my $i = 1;
                        while ( -d "$sd$i" ) { $i++; }
                        $sd .= $i;
                        $od .= $i;
                        $x  .= $i;
                    }
                    $res = FREUtil::createDir("$sd/run");
                }
                elsif ( $o{overwrite} ) {
                    qx(rm -rf $sd/run $od/ascii $od/restart $od/history);
                    $res = FREUtil::createDir("$sd/run");
                }
                elsif ( -d "$sd/run" ) {
                    $fre->out( FREMsg::FATAL,
                        "The state directory '$sd/run' exists, so you must specify either --overwrite or --unique"
                    );
                    return ( 0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM );
                }
                else {
                    $res = FREUtil::createDir("$sd/run");
                }
            } ## end if ( -w $sd )
            else {
                $fre->out( FREMsg::FATAL, "The state directory '$sd' is not writable" );
            }
        } ## end if ( -d $sd )
        else {
            $res = FREUtil::createDir("$sd/run");
        }

        if ($res) {
            $fre->out( FREMsg::NOTE,
                "The state directory '$sd/run' has been created successfully" );
            FRETemplate::setVariable( $fre, \$s, 'stateDir',  "$sd/run" );
            FRETemplate::setVariable( $fre, \$s, 'outputDir', $od );
            return ( $s, $x, FREDefaults::STATUS_OK );
        }
        else {
            $fre->out( FREMsg::FATAL, "Unable to create the state directory '$sd/$x/run'" );
            return ( 0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
        }

    } ## end sub setRegressionDirectories($$$%)

    sub setProductionDirectories($$%)

# ------ arguments: $script $exp %options
# ------ setups state and output directories and writes them in the script
# ------ if the state directory exists and the "unique" option is on, then returns non-empty extension
# ------ if the state directory exists and the "overwrite" option is on, then removes both directories and recreates the state one
# ------ return ($script, $extension, $status)
    {

        my ( $s, $z, %o ) = @_;

        my ( $fre, $sd, $od, $x, $res ) = ( $z->fre(), $z->stateDir(), $z->archiveDir(), '', '' );

        if ( -d $sd ) {
            if ( -w $sd ) {
                if ( $o{unique} ) {
                    $fre->out( FREMsg::NOTE,
                        "Performing unique production run, no post-processing for this run" );
                    {
                        my $i = 1;
                        while ( -d "$sd/$i" ) { $i++; }
                        $sd .= "/$i";
                        $od .= "/$i";
                        $x = "__$i";
                    }
                    $res = FREUtil::createDir("$sd/run");
                }
                elsif ( $o{overwrite} ) {
                    qx(rm -rf $sd/run $od/ascii $od/restart $od/history $od/postProcess $od/analysis);
                    $res = FREUtil::createDir("$sd/run");
                }
                elsif ( $o{extend} ) {
                    $res = FREUtil::createDir("$sd/run");
                }
                elsif ( -d "$sd/run" ) {
                    $fre->out( FREMsg::FATAL,
                        "The state directory '$sd/run' exists, so you must specify --extend, --overwrite or --unique"
                    );
                    return ( 0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM );
                }
                else {
                    $res = FREUtil::createDir("$sd/run");
                }
            } ## end if ( -w $sd )
            else {
                $fre->out( FREMsg::FATAL, "The state directory '$sd' is not writable" );
            }
        } ## end if ( -d $sd )
        else {
            $res = FREUtil::createDir("$sd/run");
        }

        if ($res) {
            $fre->out( FREMsg::NOTE,
                "The state directory '$sd/run' has been created successfully" );
            FRETemplate::setVariable( $fre, \$s, 'stateDir',  "$sd/run" );
            FRETemplate::setVariable( $fre, \$s, 'outputDir', $od );
            return ( $s, $x, FREDefaults::STATUS_OK );
        }
        else {
            $fre->out( FREMsg::FATAL, "Unable to create the state directory '$sd/run'" );
            return ( 0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
        }

    } ## end sub setProductionDirectories($$%)

    sub setRegressionTimeStampOptions($$$)

        # ------ arguments: $refToScript $exp $refToInfo
        # ------ update timestamp options
    {
        my ( $r, $z, $i ) = @_;
        my $fre          = $z->fre();
        my $calendarType = frerun::calendarType( $i->{namelists} );
        my $timeStampOptions
            = ( $calendarType eq 'no_calendar' )
            ? '-f days'
            : ( ( $i->{hoursDefined} ) ? '-hf digital' : '-f digital' );
        FRETemplate::setList( $fre, $r, 'timeStampOptions', $timeStampOptions );
    }

    sub setProductionTimeStampOptions($$$)

        # ------ arguments: $refToScript $exp $refToInfo
        # ------ update timestamp options
    {
        my ( $r, $z, $i ) = @_;
        my $fre              = $z->fre();
        my $calendarType     = frerun::calendarType( $i->{namelists} );
        my $timeStampOptions = ( $calendarType eq 'no_calendar' ) ? '-f days' : '-f digital';
        FRETemplate::setList( $fre, $r, 'timeStampOptions', $timeStampOptions );
    }

    sub setMPI($$$)

        # ------ arguments: $refToScript $exp $refToMPIInfo
    {
        my ( $r, $z, $i ) = @_;
        my ( $fre, $coupler, $npes, $refNPes, $refNTds, $refNTdsRes )
            = ( $z->fre(), $i->{coupler}, $i->{npes}, $i->{npesList}, $i->{ntdsList}, $i->{ntdsResList} );
        FRETemplate::setSchedulerSize( $fre, $r, 'run', $coupler, $npes, $refNPes, $refNTds, $refNTdsRes );
        FRETemplate::setRunCommand( $fre, $r, $i );
    }

    sub outputScriptJobId($$)

        # ------ arguments: $fre $string
        # ------ return $jobId
    {
        my ( $fre, $s, $j ) = @_;
        my $submitOutputPattern = $fre->property('FRE.scheduler.submit.output.pattern');
        return ( $s =~ m/$submitOutputPattern/m ) ? $1 : '';
    }

    sub outputScriptStartTime($)

        # ------ arguments: $fre
        # ------ return start time option (for dual run)
    {
        my $fre = shift;
        if ( my $delay = $fre->property('FRE.scheduler.dual.delay') ) {
            return $fre->propertyParameterized( 'FRE.scheduler.option.startTime', 'now+' . $delay );
        }
        else {
            return '';
        }
    }

    sub outputScriptExecuteOrSubmit($$$$%)

        # ------ arguments: $refToScript $exp $scriptAbsName $stdoutAbsName %options
        # ------ write $script to the $scriptAbsName file, chmod, and optionally execute or submit
        # ------ return ($returnCode, $status)
    {
        my ( $r, $z, $n, $o, %o ) = @_;
        my $fre = $z->fre();
        my ( $stdoutMainDir, $stdoutTmpDir )
            = ( frerun::stdoutMainDir($z), File::Basename::dirname($o) );
        if ( frerun::createDirectory( $fre, $stdoutMainDir ) ) {
            if ( frerun::createDirectory( $fre, $stdoutTmpDir ) ) {
                my $scriptsDir = File::Basename::dirname($n);
                if ( frerun::createDirectory( $fre, $scriptsDir ) ) {
                    if ( open my $scriptHandle, '>', $n ) {
                        print {$scriptHandle} ${$r};
                        close $scriptHandle;
                        if ( chmod 0755, $n ) {
                            if ( $o{execute} ) {
                                my $res = system("$n 2>&1 | tee $o");
                                if ( $res == 0 ) {
                                    return ( 1, FREDefaults::STATUS_OK );
                                }
                                else {
                                    $fre->out( FREMsg::FATAL,
                                        "The runscript '$n' failed! ($res)",
                                        "Please see the logfile '$o'..."
                                    );
                                    return ( 0, FREDefaults::STATUS_FRE_RUN_EXECUTION_PROBLEM );
                                }
                            }
                            elsif ( $o{submit} ) {
                                if ( $fre->property('FRE.scheduler.enabled') ) {
                                    my $submitCommand
                                        = $fre->property('FRE.scheduler.submit.command');
                                    $submitCommand .= ' ' . frerun::outputScriptStartTime($fre)
                                        if $o{dual};
                                    $submitCommand .= ' ' . $n;
                                    $fre->out( FREMsg::NOTE, "Executing '$submitCommand'..." );
                                    my $currentDir = Cwd::getcwd();
                                    if ( chdir $stdoutTmpDir ) {
                                        print qx($submitCommand);
                                        chdir $currentDir;
                                        return ( 1, FREDefaults::STATUS_OK );
                                    }
                                    else {
                                        $fre->out( FREMsg::FATAL,
                                            "Unable to switch to the stdout directory '$stdoutTmpDir'"
                                        );
                                        return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                                    }
                                } ## end if ( $fre->property('FRE.scheduler.enabled'...))
                                else {
                                    $fre->out( FREMsg::WARNING,
                                        "The runscript '$n' can't be submitted as a batch job on this site"
                                    );
                                    return ( 1, FREDefaults::STATUS_OK );
                                }
                            } ## end elsif ( $o{submit} )
                            elsif ( $o{'submit-chained'} ) {
                                if ( $fre->property('FRE.scheduler.enabled') ) {
                                    my ( $submitChainCommand, $scriptBasename ) = (
                                        $fre->property('FRE.scheduler.submit.command'),
                                        File::Basename::basename($n)
                                    );
                                    $submitChainCommand .= ' '
                                        . FRETemplate::schedulerResourcesAsString( $fre,
                                        'inputStager', $o{ncores}, $o{walltime},
                                        undef, undef, undef );
                                    $submitChainCommand .= ' '
                                        . FRETemplate::schedulerNamesAsString( $fre,
                                        "$scriptBasename.input.stager",
                                        $stdoutMainDir );
                                    $submitChainCommand .= ' ' . frerun::outputScriptStartTime($fre)
                                        if $o{dual};
                                    $submitChainCommand .= ' ' . '--export=FRE_STAGE=CHAIN';
                                    $submitChainCommand .= ' ' . $n;
                                    $fre->out( FREMsg::NOTE, "Executing '$submitChainCommand'..." );
                                    my $currentDir = Cwd::getcwd();

                                    if ( chdir $stdoutTmpDir ) {
                                        print qx($submitChainCommand);
                                        chdir $currentDir;
                                        return ( 1, FREDefaults::STATUS_OK );
                                    }
                                    else {
                                        $fre->out( FREMsg::FATAL,
                                            "Unable to switch to the stdout directory '$stdoutTmpDir'"
                                        );
                                        return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                                    }
                                } ## end if ( $fre->property('FRE.scheduler.enabled'...))
                                else {
                                    $fre->out( FREMsg::WARNING,
                                        "The runscript '$n' can't be submitted as a batch job on this site"
                                    );
                                    return ( 1, FREDefaults::STATUS_OK );
                                }
                            } ## end elsif ( $o{'submit-chained'...})
                            else {
                                if ( $fre->property('FRE.scheduler.enabled') ) {
                                    my $submit = $fre->property('FRE.scheduler.submit.command');
                                    print "TO SUBMIT => $submit $n\n";
                                    return ( 1, FREDefaults::STATUS_OK );
                                }
                                else {
                                    print "The runscript '$n' is ready\n";
                                    return ( 1, FREDefaults::STATUS_OK );
                                }
                            }
                        } ## end if ( chmod 0755, $n )
                        else {
                            $fre->out( FREMsg::FATAL,
                                "Unable to change the script '$n' permissions" );
                            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                        }
                    } ## end if ( open my $scriptHandle...)
                    else {
                        $fre->out( FREMsg::FATAL, "Unable to save the script '$n'" );
                        return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                    }
                } ## end if ( frerun::createDirectory...)
                else {
                    $fre->out( FREMsg::FATAL, "Unable to create scripts directory '$scriptsDir'" );
                    return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
                }
            } ## end if ( frerun::createDirectory...)
            else {
                $fre->out( FREMsg::FATAL,
                    "Unable to create temporary stdout directory '$stdoutTmpDir'" );
                return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
            }
        } ## end if ( frerun::createDirectory...)
        else {
            $fre->out( FREMsg::FATAL, "Unable to create main stdout directory '$stdoutMainDir'" );
            return ( 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM );
        }
    } ## end sub outputScriptExecuteOrSubmit($$$$%)

    sub processRegression($$%)

        # ------ arguments: $exp $label %options
    {
        my ( $z, $l, %o ) = @_;
        my ( $expName, $fre ) = ( $z->name(), $z->fre() );
        $fre->out( FREMsg::NOTE, "Creating runscripts for the regression test '$l'..." );
        my ( $runScript, $status ) = frerun::init( $z, %o );
        if ($runScript) {
            my @dataSets = $z->extractDatasets();
            if ( FRETemplate::setInputDatasets( $fre, \$runScript, \@dataSets ) ) {
                frerun::setInputInitialConditions( \$runScript, $z );
                frerun::setInputGridSpecification( \$runScript, $z );
                frerun::setAllShellCommands( \$runScript, $z );
                FRETemplate::setVersionInfo( $fre, \$runScript, $0, $expName, %o );
                FRETemplate::setSchedulerAccount( $fre, \$runScript );
                if ( my $regInfo = $z->extractRegressionRunInfo( $l  ) ) {
                    my @runNos = keys %{$regInfo};
                    my ( $ok, $runsNmb ) = ( 1, scalar(@runNos) );
                    foreach my $runNo ( sort @runNos ) {
                        my $runInfo = $regInfo->{$runNo};
                        my $runInx = ( $runsNmb > 1 ) ? "[$runInfo->{number}]" : "";
                        $fre->out( FREMsg::NOTE,
                            "Creating a regression runscript '$l$runInx' for the experiment '$expName'..."
                        );
                        ( my $rtScript, my $extension, $status )
                            = frerun::setRegressionDirectories( $runScript, $z,
                            $runInfo->{postfix}, %o );
                        if ($rtScript) {
                            ( my $rc, $status )
                                = frerun::setTables( \$rtScript, $z, $runInfo->{namelists} );
                            if ($rc) {
                                frerun::setMPI( \$rtScript, $z, $runInfo->{mpiInfo} );
                                frerun::setRegressionTimeStampOptions( \$rtScript, $z, $runInfo );
                                frerun::setRegressionTimingParameters( \$rtScript, $z, $runInfo,
                                    $o{cluster}, $o{qos}, $o{dual} );
                                FRETemplate::setNamelists( $fre, \$rtScript,
                                    $runInfo->{namelists} );
                                my $scriptName = frerun::regressionRunScriptName( $z, $extension );
                                my $stdoutName = frerun::stdoutName( $z, $scriptName );
                                my $stdoutTmpDir = File::Basename::dirname($stdoutName);
                                FRETemplate::setVariable( $fre, \$rtScript, 'scriptName',
                                    $scriptName );
                                FRETemplate::setVariable( $fre, \$rtScript, 'stdoutTmpDir',
                                    $stdoutTmpDir );
                                FRETemplate::setSchedulerNames( $fre, \$rtScript,
                                    File::Basename::basename($scriptName),
                                    $stdoutTmpDir );
                                FRETemplate::setFlag( $fre, \$rtScript, 'flagOutputFillGrid',
                                    ( ! $o{'combine-history'} ? 'Off' :
                                      are_history_files_masked( $fre, $runInfo ) ? 'On' : 'Off' ) );
                                ( $rc, $status )
                                    = frerun::outputScriptExecuteOrSubmit( \$rtScript, $z,
                                    $scriptName, $stdoutName, %o );

                                if ($rc) {
                                    $fre->out( FREMsg::NOTE,
                                        "A regression runscript '$l$runInx' for the experiment '$expName' has been created successfully"
                                    );
                                }
                                else {
                                    $fre->out( FREMsg::FATAL,
                                        "Unable to create (or run) a regression runscript '$l$runInx' for the experiment '$expName'"
                                    );
                                    $ok = 0;
                                    last;
                                }
                            } ## end if ($rc)
                            else {
                                $fre->out( FREMsg::FATAL,
                                    "Unable to setup tables for regression runscript '$l$runInx' in the experiment '$expName'"
                                );
                                $ok = 0;
                                last;
                            }
                        } ## end if ($rtScript)
                        else {
                            $fre->out( FREMsg::FATAL,
                                "Unable to setup output directories for regression runscript '$l$runInx' in the experiment '$expName'"
                            );
                            $ok = 0;
                            last;
                        }
                    } ## end foreach my $runNo ( sort @runNos)
                    if ($ok) {
                        $fre->out( FREMsg::NOTE,
                            "Regression test '$l' in the experiment '$expName' has been processed successfully"
                        );
                        return ( 1, FREDefaults::STATUS_OK );
                    }
                    else {
                        $fre->out( FREMsg::FATAL,
                            "Unable to process regression test '$l' in the experiment '$expName'" );
                        return ( 0, $status );
                    }
                } ## end if ( my $regInfo = $z->...)
                else {
                    $fre->out( FREMsg::FATAL,
                        "Unable to extract parameters for the regression test '$l' in the experiment '$expName'"
                    );
                    return ( 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM );
                }
            } ## end if ( FRETemplate::setInputDatasets...)
            else {
                $fre->out( FREMsg::FATAL,
                    "Unable to setup input data for the experiment '$expName'" );
                return ( 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM );
            }
        } ## end if ($runScript)
        else {
            $fre->out( FREMsg::FATAL, "Unable to initialize the experiment '$expName'" );
            return ( 0, $status );
        }
    } ## end sub processRegression($$%)

    sub processProduction($%)

        # ------ arguments: $exp %options
    {
        my ( $z, %o ) = @_;
        my ( $expName, $fre ) = ( $z->name(), $z->fre() );
        $fre->out( FREMsg::NOTE, "Creating a runcript for the experiment '$expName'..." );
        my ( $runScript, $status ) = frerun::init( $z, %o );
        if ($runScript) {
            my @dataSets = $z->extractDatasets();
            if ( FRETemplate::setInputDatasets( $fre, \$runScript, \@dataSets ) ) {
                frerun::setInputInitialConditions( \$runScript, $z );
                frerun::setInputGridSpecification( \$runScript, $z );
                frerun::setAllShellCommands( \$runScript, $z );
                FRETemplate::setVersionInfo( $fre, \$runScript, $0, $expName, %o );
                FRETemplate::setSchedulerAccount( $fre, \$runScript );
                if ( my $prdInfo = $z->extractProductionRunInfo() ) {
                    ( $runScript, my $extension, $status )
                        = frerun::setProductionDirectories( $runScript, $z, %o );
                    if ($runScript) {
                        ( my $rc, $status )
                            = frerun::setTables( \$runScript, $z, $prdInfo->{namelists} );
                        if ($rc) {
                            frerun::setMPI( \$runScript, $z, $prdInfo->{mpiInfo} );
                            frerun::setProductionTimeStampOptions( \$runScript, $z, $prdInfo );
                            frerun::setProductionTimingParameters( \$runScript, $z, $prdInfo,
                                $o{cluster}, $o{qos}, $o{dual} );
                            FRETemplate::setNamelists( $fre, \$runScript, $prdInfo->{namelists} );
                            my $scriptName = frerun::productionRunScriptName( $z, $extension );
                            my $stdoutName = frerun::stdoutName( $z, $scriptName );
                            my $stdoutTmpDir = File::Basename::dirname($stdoutName);
                            FRETemplate::setVariable( $fre, \$runScript, 'scriptName',
                                $scriptName );
                            FRETemplate::setVariable( $fre, \$runScript, 'stdoutTmpDir',
                                $stdoutTmpDir );
                            FRETemplate::setSchedulerNames( $fre, \$runScript,
                                File::Basename::basename($scriptName),
                                $stdoutTmpDir );
                            FRETemplate::setFlag( $fre, \$runScript, 'flagOutputFillGrid',
                                ( ! $o{'combine-history'} ? 'Off' :
                                  are_history_files_masked( $fre, $prdInfo ) ? 'On' : 'Off' ) );
                            ( $rc, $status )
                                = frerun::outputScriptExecuteOrSubmit( \$runScript, $z, $scriptName,
                                $stdoutName, %o );

                            if ($rc) {
                                return ( 1, FREDefaults::STATUS_OK );
                            }
                            else {
                                $fre->out( FREMsg::FATAL,
                                    "Unable to create (or run) a runscript for the experiment '$expName'"
                                );
                                return ( 0, $status );
                            }
                        } ## end if ($rc)
                        else {
                            $fre->out( FREMsg::FATAL,
                                "Unable to setup tables for the experiment '$expName'" );
                            return ( 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM );
                        }
                    } ## end if ($runScript)
                    else {
                        $fre->out( FREMsg::FATAL,
                            "Unable to setup output directories for the experiment '$expName'" );
                        return ( 0, $status );
                    }
                } ## end if ( my $prdInfo = $z->...)
                else {
                    $fre->out( FREMsg::FATAL,
                        "Unable to extract production parameters for the experiment '$expName'" );
                    return ( 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM );
                }
            } ## end if ( FRETemplate::setInputDatasets...)
            else {
                $fre->out( FREMsg::FATAL,
                    "Unable to setup input data for the experiment '$expName'" );
                return ( 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM );
            }
        } ## end if ($runScript)
        else {
            $fre->out( FREMsg::FATAL, "Unable to initialize the experiment '$expName'" );
            return ( 0, $status );
        }
    } ## end sub processProduction($%)

    sub skipExp($)

        # ------ arguments: $exp
    {
        my $z = shift;
        my ( $expName, $fre ) = ( $z->name(), $z->fre() );
        $fre->out( FREMsg::FATAL, "Skipping the experiment '$expName'..." );
    }

    # are_history_files_masked -- tests whether history files contain masked grid info
    # Currently, only tests whether an ocean mask is used.
    sub are_history_files_masked($$)

        # ------ arguments: $fre, $runInfo
    {
        my ( $fre, $info ) = @_;
        my @components = split ';', $fre->property('FRE.mpi.component.names');
        my $ocean_index;
        for my $i ( 0 .. $#components ) {
            $ocean_index = $i if $components[$i] eq 'ocn';
        }

        # mask_table="MOM_mask_table" means no mask :)
        if ( my $ocean_mask = $info->{mpiInfo}->{maskTableList}->[$ocean_index] ) {
            return $ocean_mask eq 'MOM_mask_table' ? 0 : 1;
        }
        else {
            return 0;
        }
    }

}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

    my %opt = (
        'archive'         => 1,
        'combine-history' => 1,
        'target'          => FREDefaults::Target(),
        'xmlfile'         => FREDefaults::XMLFile()
    );

    Getopt::Long::GetOptions( \%opt, frerun::OPTLIST )
        or ( print frerun::Usage() and exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM );
    if ( $opt{version} ) { print frerun::VERSION, "\n" and exit FREDefaults::STATUS_OK; }
    if ( $opt{help} ) { print frerun::Help() and exit FREDefaults::STATUS_OK; }

    unless ( scalar(@ARGV) > 0 ) {
        my $self = File::Basename::basename($0);
        FREMsg::out(
            $opt{verbose}, FREMsg::FATAL,
            "At least one experiment name is needed on the command line",
            "Try '$self --help' for more information"
        );
        exit FREDefaults::STATUS_COMMAND_NO_EXPERIMENTS;
    }

    unless ( $opt{extend} + $opt{overwrite} + $opt{unique} <= 1 ) {
        FREMsg::out( $opt{verbose}, FREMsg::FATAL,
            "Options --extend, --overwrite and --unique are mutually exclusive - only one of them can be present"
        );
        exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }

    unless ( $opt{submit} + $opt{'submit-chained'} + $opt{'submit-staged'} <= 1 ) {
        FREMsg::out( $opt{verbose}, FREMsg::FATAL,
            "Options --submit, --submit-chained and --submit-staged are mutually exclusive - only one of them can be present"
        );
        exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }

    if ( exists( $opt{compress} ) ) {
        ( $opt{compress}, my @messages )
            = FREUtil::optionValuesListParse( 'compress', $opt{compress},
            frerun::OUTPUT_COMPRESSION_TYPES );
        unless ( scalar(@messages) == 0 ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL, @messages );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( exists $opt{'mppnccombine-opts'} and exists $opt{'nc4-compress-history'} ) {
        FREMsg::out( $opt{'verbose'}, FREMsg::FATAL,
            "Options --mppnccombine-opts and --nc4-compress-history are mutually exclusive - only one of them can be present"
        );
        exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }

    if ( exists( $opt{regression} ) ) {
        unless ( $opt{regression} && substr( $opt{regression}, 0, 1 ) ne '-' ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL,
                "The --regression option's value is missing" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( exists( $opt{'remote-user'} ) ) {
        unless ( $opt{'remote-user'} && substr( $opt{'remote-user'}, 0, 1 ) ne '-' ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL,
                "The --remote-user option's value is missing" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( exists( $opt{platform} ) ) {
        unless ( $opt{platform} && substr( $opt{platform}, 0, 1 ) ne '-' ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL, "The --platform option's value is missing" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( exists( $opt{target} ) ) {
        unless ( $opt{target} && substr( $opt{target}, 0, 1 ) ne '-' ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL, "The --target option's value is missing" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( exists( $opt{xmlfile} ) ) {
        unless ( $opt{xmlfile} && substr( $opt{xmlfile}, 0, 1 ) ne '-' ) {
            FREMsg::out( $opt{verbose}, FREMsg::FATAL, "The --xmlfile option's value is missing" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( $opt{check} and !$opt{unique} ) {
        FREMsg::out( $opt{verbose}, FREMsg::WARNING,
            "Option --check is allowed only when the option --unique is present, the --check option is ignored"
        );
        delete $opt{check};
    }

    if ( $opt{dual} and $opt{regression} ) {
        FREMsg::out( $opt{verbose}, FREMsg::WARNING,
            "Options --dual and --regression are incompatible, the --dual option is ignored" );
        delete $opt{dual};
    }

    if ( $opt{dual} and $opt{unique} ) {
        FREMsg::out( $opt{verbose}, FREMsg::WARNING,
            "Options --dual and --unique are incompatible, the --dual option is ignored" );
        delete $opt{dual};
    }

    if ( $opt{ht} ) {
        FREMsg::out( $opt{verbose}, FREMsg::FATAL, <<EOF
Option --ht has been removed. Hyperthreading is now specified in the <resources> tag,
with the other resource specifications, as hyperthread="yes|true|on"; e.g.

<resources jobWallclock="00:30:00">
    <atm ranks="30" threads="2" hyperthread="on"  layout="1,30" io_layout="1,3"/>
    <ocn ranks="30" threads="1" hyperthread="off" layout="1,30" io_layout="1,3"/>
    <lnd                                          layout="1,30" io_layout="1,3"/>
    <ice                                          layout="1,30" io_layout="1,3"/>
</resources>

For the above example, these shell variables will be set:

set -r npes = 60
set -r atm_ranks = 30
set -r atm_threads = 2
set -r atm_layout = 1,30
set -r atm_io_layout = 1,3
set -r atm_mask_table =
set -r atm_hyperthread = .true.
set -r ocn_ranks = 30
set -r ocn_threads = 1
set -r ocn_layout = 1,30
set -r ocn_io_layout = 1,3
set -r ocn_mask_table =
set -r ocn_hyperthread = .false.
set -r lnd_ranks =
set -r lnd_threads =
set -r lnd_layout = 1,30
set -r lnd_io_layout = 1,3
set -r lnd_mask_table =
set -r lnd_hyperthread = .false.
set -r ice_ranks =
set -r ice_threads =
set -r ice_layout = 1,30
set -r ice_io_layout = 1,3
set -r ice_mask_table =
set -r ice_hyperthread = .false.

If omitted, the default is off. Additionally, the behavior of hyperthreading
has changed since Bronx-(11-14); previously hyperthreading requested the same number of nodes
while doubling the threads passed to the namelists. To be more explicit,
it is up to the user to fully define the configuration and FRE will allocate
the proper resources for the given configuration.
EOF
        );
        exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }

    my $fre = FRE->new( 'frerun', %opt ) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;

    # check for FRE version mismatch between XML and current shell
    $fre->check_for_fre_version_mismatch;

    unless ( $fre->property('FRE.tool.frerun.enabled') ) {
        my $platformSite = $fre->platformSite();
        $fre->out( FREMsg::FATAL,
            "You are not supposed to call this tool on the '$platformSite' site" );
        exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    }

    if ( $opt{'submit-chained'} || $opt{'submit-staged'} ) {
        if ( $fre->property('FRE.input.staging.enabled') ) {
            if ( $opt{'submit-staged'} ) {
                delete $opt{'submit-staged'};
                $opt{'submit-chained'} = 1;
            }
        }
        else {
            $fre->out( FREMsg::WARNING, "Input staging is not supported on this site" );
            exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
        }
    }

    if ( scalar( my @types = split( /;/, $fre->property('FRE.output.staging') ) ) > 0 ) {
        my $typeDefault = $types[0];
        if ( exists( $opt{'output-staging'} ) ) {
            if ( $opt{'output-staging'} && substr( $opt{'output-staging'}, 0, 1 ) ne '-' ) {
                if ( scalar( grep( $_ eq $opt{'output-staging'}, @types ) ) > 0 ) {
                    $fre->out( FREMsg::NOTE,
                        "The '$opt{'output-staging'}' output staging type will be used" );
                }
                elsif ( scalar(@types) > 1 ) {
                    my $types = join( "', '", @types );
                    $fre->out( FREMsg::FATAL,
                        "The '$opt{'output-staging'}' output staging type isn't allowed",
                        "Allowed types are '$types', the default one is '$typeDefault'"
                    );
                    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "The '$opt{'output-staging'}' output staging type isn't allowed",
                        "Allowed type is '$typeDefault' only"
                    );
                    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
                }
            } ## end if ( $opt{'output-staging'...})
            else {
                $fre->out( FREMsg::FATAL, "The --output-staging option's value is missing" );
                exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
            }
        } ## end if ( exists( $opt{'output-staging'...}))
    } ## end if ( scalar( my @types...))
    else {
        $fre->out( FREMsg::FATAL, "The FRE output staging is configured incorrectly" );
        exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    }

    if ( scalar( my @clusters = split( /;/, $fre->property('FRE.scheduler.clusters') ) ) > 0 ) {
        my $clusterDefault = $clusters[0];
        if ( exists( $opt{cluster} ) ) {
            if ( $opt{cluster} && substr( $opt{cluster}, 0, 1 ) ne '-' ) {
                if ( scalar( grep( $_ eq $opt{cluster}, @clusters ) ) > 0 ) {
                    $fre->out( FREMsg::NOTE, "The '$opt{cluster}' cluster will be used" );
                }
                elsif ( scalar(@clusters) > 1 ) {
                    my $clusters = join( "', '", @clusters );
                    $fre->out( FREMsg::FATAL,
                        "The '$opt{cluster}' cluster isn't allowed",
                        "Allowed clusters are '$clusters', the default one is '$clusterDefault'"
                    );
                    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "The '$opt{cluster}' cluster isn't allowed",
                        "Allowed cluster is '$clusterDefault' only"
                    );
                    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
                }
            }
            else {
                $fre->out( FREMsg::FATAL, "The --cluster option's value is missing" );
                exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
            }
        }
        else {
            $fre->out( FREMsg::WARNING,
                "Option --cluster=$clusterDefault has been automatically added" );
            $opt{cluster} = $clusterDefault;
        }
    }
    elsif ( exists( $opt{cluster} ) ) {
        $fre->out( FREMsg::FATAL, "Option --cluster is not supported on this site" );
        exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }

    if (scalar(
            my @qos = split(
                /;/,
                $fre->property("FRE.scheduler.$opt{cluster}.qos")
                || $fre->property("FRE.scheduler.qos")
            )
        ) > 0
        ) {
        my $qosDefault = $qos[0];
        if ( exists( $opt{qos} ) ) {
            if ( $opt{qos} && substr( $opt{qos}, 0, 1 ) ne '-' ) {
                if ( scalar( grep( $_ eq $opt{qos}, @qos ) ) > 0 ) {
                    $fre->out( FREMsg::NOTE, "The qos '$opt{qos}' will be used" );
                }
                elsif ( scalar(@qos) > 1 ) {
                    my $qos = join( "', '", @qos );
                    $fre->out( FREMsg::FATAL,
                        "The '$opt{qos}' quality-of-service isn't allowed",
                        "Allowed qos classes are '$qos', the default one is '$qosDefault'"
                    );
                    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
                }
                else {
                    $fre->out( FREMsg::FATAL,
                        "The '$opt{qos}' quality-of-service isn't allowed",
                        "Allowed qos is '$qosDefault' only"
                    );
                    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
                }
            }
            else {
                $fre->out( FREMsg::FATAL, "The --qos option's value is missing" );
                exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
            }
        }
        else {
            $fre->out( FREMsg::WARNING,
                "Option --qos=$qosDefault has been automatically added" );
            $opt{qos} = $qosDefault;
        }
    }
    elsif ( exists( $opt{qos} ) ) {
        $fre->out( FREMsg::FATAL, "Option --qos is not supported on this site" );
        exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }

    if (    !exists( $opt{dual} )
        and !$opt{regression}
        and !$opt{unique}
        and $fre->property('FRE.option.dual.default') ) {
        $fre->out( FREMsg::WARNING, "Option --dual has been automatically added" );
        $opt{dual} = 1;
    }

    if ( $opt{transfer} and !$opt{archive} ) {
        $fre->out( FREMsg::WARNING,
            "Option --transfer is not allowed when the option --noarchive is present, the --transfer option is ignored"
        );
        delete $opt{transfer};
    }
    elsif ( $opt{transfer} and $opt{check} ) {
        $fre->out( FREMsg::WARNING,
            "Option --transfer is not allowed when the option --check is present, the --transfer option is ignored"
        );
        delete $opt{transfer};
    }
    elsif ( $opt{transfer}
        and scalar( split( /;/, $fre->property('FRE.output.staging') ) ) > 1
        and $opt{'output-staging'} eq 'online' ) {
        $fre->out( FREMsg::WARNING,
            "Option --transfer is not allowed when the option --output-staging=online is present, the --transfer option is ignored"
        );
        delete $opt{transfer};
    }
    elsif (
            !exists( $opt{transfer} )
        and $opt{archive}
        and !$opt{check}
        and ( scalar( split( /;/, $fre->property('FRE.output.staging') ) ) == 1
            or $opt{'output-staging'} ne 'online' )
        and $fre->property('FRE.option.transfer.default')
        ) {
        $fre->out( FREMsg::WARNING, "Option --transfer has been automatically added" );
        $opt{transfer} = 1;
    }

    if ( !exists( $opt{free} ) and $fre->property('FRE.option.free.default') ) {
        $fre->out( FREMsg::WARNING, "Option --free has been automatically added" );
        $opt{free} = 1;
    }

    {
        my $ncores
            = $opt{ncores}
            || $fre->property('FRE.scheduler.inputStager.coresPerJob.default')
            || frerun::NCORES_DEFAULT;
        $opt{ncores} = $ncores;
    }

    {
        my $walltime
            = $opt{walltime}
            || $fre->property('FRE.scheduler.inputStager.runtime.default')
            || frerun::WALLTIME_DEFAULT;
        $opt{walltime} = $walltime;
    }

    if ($opt{'mail-list'}) {
        for (split ',', $opt{'mail-list'}) {
            unless (Email::Valid->address($_)) {
                $fre->out( FREMsg::FATAL, "The email address '$_' specified in --mail-list isn't valid" );
                exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
            }
        }
        $fre->out( FREMsg::NOTE, "The email list '$opt{'mail-list'}' will be used FRE notifications instead of the default '\$USER\@noaa.gov'" );
    }

    # Is this a site that requires the remote-user option to be used on the command line?
    if ( $fre->property('FRE.option.remoteuser.required') and $opt{'transfer'} and not exists( $opt{'remote-user'} ) ) {
        FREMsg::out( $opt{verbose}, FREMsg::FATAL,
            "The --remote-user option is required on this site when transfers are enabled" );
        exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }

    my @exps = ();
    foreach my $expName ( FREUtil::listUnique(@ARGV) ) {
        my $exp = FREExperiment->new( $fre, $expName )
            or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
        push @exps, $exp;
    }

    my $status = FREDefaults::STATUS_OK;

    foreach my $exp (@exps) {

        # --------------------------------- set the experiment name

        my $expName = $exp->name();
        $fre->setCurrentExperimentName($expName);
        $fre->out( FREMsg::NOTE, "Setting up the experiment '$expName'..." );

        # ---------------------------------------------------------------- process the experiment

        if ( $opt{regression} ) {
            if ( my @labels = $exp->extractRegressionLabels( $opt{regression} ) ) {
                my $ok = 1;
                foreach my $label (@labels) {

     # ----------------------------------------------------------------- regression scripts creation
                    ( my $rc, $status ) = frerun::processRegression( $exp, $label, %opt );
                    if ($rc) {
                        $fre->out( FREMsg::NOTE,
                            "All the regression runs with label '$label' have been processed successfully"
                        );
                    }
                    else {
                        $fre->out( FREMsg::FATAL,
                            "Unable to process regression runs with label '$label'" );
                        $ok = 0;
                        last;
                    }
                }
                unless ($ok) {
                    $fre->out( FREMsg::FATAL,
                        "Unable to process all the requested regression tests" );
                    frerun::skipExp($exp) if scalar(@exps) > 1;
                }
            } ## end if ( my @labels = $exp...)
            else {
                $fre->out( FREMsg::FATAL, "Unable to select regression tests to process" );
                frerun::skipExp($exp) if scalar(@exps) > 1;
                $status = FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
            }
        } ## end if ( $opt{regression} )
        else {

   # ----------------------------------------------------------------- production runscript creation
            my $dualOn = $opt{dual};
            ( my $rc, $status ) = frerun::processProduction( $exp, ( %opt, 'dual' => 0 ) );
            if ($rc) {
                $fre->out( FREMsg::NOTE,
                    "A runscript for the experiment '$expName' has been created successfully" );
                if ($dualOn) {
                    ( my $rc, $status ) = frerun::processProduction(
                        $exp,
                        (   %opt,
                            'check'     => 1,
                            'extend'    => 0,
                            'overwrite' => 0,
                            'transfer'  => 0,
                            'unique'    => 1
                        )
                    );
                    if ($rc) {
                        $fre->out( FREMsg::NOTE,
                            "A dual runscript for the experiment '$expName' has been created successfully"
                        );
                    }
                    else {
                        $fre->out( FREMsg::FATAL,
                            "Unable to create a dual runscript for the experiment '$expName'" );
                        frerun::skipExp($exp) if scalar(@exps) > 1;
                    }
                } ## end if ($dualOn)
            } ## end if ($rc)
            else {
                $fre->out( FREMsg::FATAL,
                    "Unable to create a runscript for the experiment '$expName'" );
                frerun::skipExp($exp) if scalar(@exps) > 1;
            }
        } ## end else [ if ( $opt{regression} )]

        # ------------------------------------ unset the experiment name

        $fre->unsetCurrentExperimentName();

    } ## end foreach my $exp (@exps)

    # ------------------------ Call NiNaC on successful runscript creation if NiNaC module is loaded

    if (    $status == FREDefaults::STATUS_OK
        and exists( $ENV{'NiNaC_LVL'} )
        and $ENV{'NiNaC_LVL'} > 0 ) {

        # Ensure that the xml path is an absolute path
        my $xmlpath = File::Spec->rel2abs( $opt{'xmlfile'} );

        # Split the xml path into file name and directory path
        my $xmlfile = File::Basename::basename($xmlpath);
        my $xmldir  = File::Basename::dirname($xmlpath);

        # Get the xml dir signature
        system( $ENV{'NiNaC_XmlRx'}, $xmlfile, $xmldir );

        # Alert the user on NiNaC_XmlRx failure
        if ( $? != 0 ) {
            print STDERR "NiNaC Note: While NiNaC loaded attempt at NiNaC_XmlRx "
                . FREUtil::decodeChildStatus( $?, $! )
                . " : FRE continuing as normal.\n";
        }
    } ## end if ( $status == FREDefaults::STATUS_OK...)

    exit $status;

}
