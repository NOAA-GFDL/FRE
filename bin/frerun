#!/usr/bin/perl
# -*- cperl -*-
#
# $Id: frerun,v 18.0.2.63.2.3 2013/02/01 22:06:14 afy Exp $
# ------------------------------------------------------------------------------
# FMS/FRE Project: Program to Create a Script to Run a Model
# ------------------------------------------------------------------------------
# arl    Ver  18.00  Merged revision 17.0.4.21 onto trunk           March 10
# afy -------------- Branch 18.0.2 -------------------------------- March 10
# afy    Ver   1.00  Modify Help subroutine (list targets)          March 10
# afy    Ver   1.01  Add --archive option                           March 10
# afy    Ver   1.02  Modify init (set flagArchive)                  March 10
# afy    Ver   1.03  Modify init (no staged combining for reg.)     March 10
# afy    Ver   2.00  Modify Help subroutine again (list targets)    April 10
# afy    Ver   2.01  Modify Usage subroutine (reorder, attributes)  April 10
# afy    Ver   2.02  Add shorter option names                       April 10
# afy    Ver   2.03  Add option --validate                          April 10
# afy    Ver   2.04  Check for experiment names separately          April 10
# afy    Ver   2.05  Modify init (don't set FREROOT)                April 10
# afy    Ver   2.06  Modify init (set flagOutputType)               April 10
# afy    Ver   2.07  Modify init (set flagOutputPostProcess)        April 10
# afy    Ver   2.08  Modify setProductionOutputDirectory (no frepp) April 10
# afy    Ver   2.09  Modify outputRegressionScript (no frepp)       April 10
# afy    Ver   2.10  Modify init (offline + unique => online)       April 10
# afy    Ver   2.11  Add option --execute                           April 10
# afy    Ver   3.00  Remove option --build                          May 10
# afy    Ver   3.01  Add (modified) execName subroutine             May 10
# afy    Ver   3.02  Modify init (don't set siteDir/flagRemake)     May 10
# afy    Ver   3.03  Modify init (set freCommandsHomeDir)           May 10
# afy    Ver   3.04  Add baseDate subroutine                        May 10
# afy    Ver   3.05  Modify setTables subroutine (use setBaseDate)  May 10
# afy    Ver   4.00  Modify init (use new FRE.pm)                   May 10
# afy    Ver   5.00  Add --target option alias 't'                  June 10
# afy    Ver   6.00  Use new FREDefaults.pm to return status        June 10
# afy    Ver   6.01  Force if/elsif/else tree design                June 10
# afy    Ver   6.02  Modify setProductionParameters subroutine      June 10
# afy    Ver   6.03  Modify outputScriptExecuteOrSubmit subroutine  June 10
# afy    Ver   6.04  Add pathname-returning subroutines             June 10
# afy    Ver   6.05  Standardize skipExp subroutine                 June 10
# afy    Ver   6.06  Modify init (default getFmsData)               June 10
# afy    Ver   6.07  Add calendarType subroutine                    June 10
# afy    Ver   6.08  Modify setNamelists (set timeStampFormat)      June 10
# afy    Ver   7.00  Add option --submit-staged	                    June 10
# afy    Ver   7.01  Add option --npes (for staging only)           June 10
# afy    Ver   7.02  Add option --walltime (for staging only)       June 10
# afy    Ver   7.03  Modify init (change ptmpDir/hsmDir settings)   June 10
# afy    Ver   7.04  Modify outputScriptExecuteOrSubmit (staging)   June 10
# afy    Ver   8.00  Modify outputScriptInputDir (use properties)   June 10
# afy    Ver   8.01  Modify outputScriptJobId (use properties)      June 10
# afy    Ver   9.00  Modify setMPI (use new FREDefaults.pm)         July 10
# afy    Ver  10.00  Weaken errors processing for suites            July 10
# afy    Ver  11.00  Add processRegressionRun subroutine            August 10
# afy    Ver  11.01  Add processRegression subroutine               August 10
# afy    Ver  11.02  Add processRegressionSuite subroutine          August 10
# afy    Ver  11.03  Add processProduction subroutine               August 10
# afy    Ver  11.04  Restructure the main loop using added subs     August 10
# afy    Ver  11.05  Add option --dual                              August 10
# afy    Ver  12.00  Modify init (more history combining types)     August 10
# afy    Ver  13.00  Modify init (history combining type checkup)   August 10
# afy    Ver  13.01  Cosmetics in messages                          August 10
# afy    Ver  13.02  Modify option --dual (alias 'du' => 'D')       August 10
# afy    Ver  13.03  Modify option --execute (alias 'e' => 'E')     August 10
# afy    Ver  13.04  Modify option --extend (alias 'ext' => 'e')    August 10
# afy    Ver  13.05  Modify option --overwrite (add alias 'o')      August 10
# afy    Ver  13.06  Modify option --unique (add alias 'u')         August 10
# afy    Ver  13.07  Modify option --namelist (add alias 'N')       August 10
# afy    Ver  13.08  Modify option --npes (add alias 'n')           August 10
# afy    Ver  14.00  Reconfigure Getopt::Long (no 'auto_abbrev')    August 10
# afy    Ver  14.01  Merge two options --transfer-* into one        August 10
# afy    Ver  14.02  Modify option --submit (allow 'staged' value)  August 10
# afy    Ver  14.03  Remove option --submit-staged                  August 10
# afy    Ver  14.04  Add single-letter aliases to all the options   August 10
# afy    Ver  14.05  Add option --check                             August 10
# afy    Ver  14.06  Use new module FRETemplate (new set* subs)     August 10
# afy    Ver  14.07  Modify setMPI (pass the ./$executable:t)       August 10
# afy    Ver  15.00  Correction for the --dual option               August 10
# afy    Ver  16.00  Modify option --transfer (negatable)           August 10
# afy    Ver  16.01  Revive option --submit-staged                  August 10
# afy    Ver  16.02  Modify option --submit (don't allow values)    August 10
# afy    Ver  16.03  Modify option --validate (no aliases)          August 10
# afy    Ver  16.04  Modify option --version (low case)             August 10
# afy    Ver  16.05  Default option --dual from a property          August 10
# afy    Ver  16.06  Default option --transfer from a property      August 10
# afy    Ver  17.00  Modify outputScriptExecuteOrSubmit (no qsub)   September 10
# afy    Ver  17.01  Use new module FRETemplate                     September 10
# afy    Ver  18.00  Use new module FRETemplate (setScheduler*)     September 10
# afy    Ver  18.01  Modify set*Parameters (no stdoutDir)           September 10
# afy    Ver  18.02  Modify outputScriptJobId (property name)       September 10
# afy    Ver  18.03  Modify outputScripExecuteOrSubmit (stdoutDir)  September 10
# afy    Ver  18.04  Remove output*Script subroutines               September 10
# afy    Ver  18.05  Modify processRegressionRun (set all names)    September 10
# afy    Ver  18.06  Modify processProduction (set all names)       September 10
# afy    Ver  19.00  Rename option --npes => --ncores               September 10
# afy    Ver  19.01  Modify outputScriptExecuteOrSubmit (ncores)    September 10
# afy    Ver  20.00  Modify outputScriptExecuteOrSubmit (staging)   September 10
# afy    Ver  21.00  Modify outputScriptJobId (add parameter)       September 10
# afy    Ver  21.01  Modify outputScriptJobId (generic pattern)     September 10
# afy    Ver  22.00  Add option --partition                         September 10
# afy    Ver  23.00  Simplify staged submitting (no FRE_INPUT_DIR)  October 10
# afy    Ver  23.01  Add option --submit-chained                    October 10
# afy    Ver  23.02  Modify init (add partitions/queues setup)      October 10
# afy    Ver  23.00  Modify outputScriptExecuteOrSubmit (names)     October 10
# afy    Ver  24.00  Add option --output-staging                    October 10
# afy    Ver  24.01  Assign 'platform' settable constant            October 10
# afy    Ver  25.00  Assign 'target' settable constant              October 10
# afy    Ver  26.00  Rethink the option --output-staging            November 10
# afy    Ver  26.01  Rename flag*CombineType => flag*StagingType    November 10
# afy    Ver  26.02  Rename flag*Combine => flag*CombineHistory     November 10
# afy    Ver  27.00  Properties for --ncores/walltime defaults      November 10
# afy    Ver  28.00  Use new FREMsg module (symbolic level names)   December 10
# afy    Ver  28.01  Add productionParametersExist subroutine       December 10
# afy    Ver  28.02  Modify init (fileSender/outputStager times)    December 10
# afy    Ver  28.03  Modify init (mail mode)                        December 10
# afy    Ver  29.00  Modify init (add moduleInitDir setting)        December 10
# afy    Ver  30.00  Remove option --logging                        January 11
# afy    Ver  30.01  Modify init (corrections in messages)          January 11
# afy    Ver  30.02  Modify setMPI (property to request histx)      January 11
# afy    Ver  30.03  Modify outputScriptExecuteOrSubmit (checks)    January 11
# afy    Ver  31.00  Verify option --partition values               February 11
# afy    Ver  31.01  Add option --queue                             February 11
# afy    Ver  31.02  Use new FRETemplate module (setScheduler*)     February 11
# afy    Ver  31.03  Use new FREUtil module (createDir)             February 11
# afy    Ver  31.04  Modify init (renamed properties)               February 11
# afy    Ver  31.05  Modify outputScriptJobId (remove mode)         February 11
# afy    Ver  31.06  Simplify all the grep calls                    February 11
# afy    Ver  32.00  Fix partitions/queues checkup (again)          March 11
# afy    Ver  33.00  Remove option --debug                          March 11
# afy    Ver  33.01  Use new FRE (propertyParameterized)            March 11
# afy    Ver  33.02  Use new FRETemplate (setAlias)                 March 11
# afy    Ver  33.03  Add check for 'FRE.tool.frerun.enabled'        March 11
# afy    Ver  33.04  Modify createDirectory (no remoting)           March 11
# afy    Ver  33.05  Modify set*OutputDirectory (no remoting)       March 11
# afy    Ver  33.06  Modify setMPI (use default property)           March 11
# afy    Ver  33.07  Remove outputScriptOption subroutine           March 11
# afy    Ver  34.00  Modify init (more scheduling parameters)       May 11
# afy    Ver  34.01  Modify option --output-staging checkup         May 11
# afy    Ver  34.00  Modify init (add pp scheduling parameters)     May 11
# afy    Ver  34.01  Modify option --archive checkup                May 11
# afy    Ver  35.00  Remove option --validate                       May 11
# afy    Ver  35.01  Improve output staging types checkup/control   May 11
# afy    Ver  35.02  Modify init (add stateDir setting)             May 11
# afy    Ver  36.00  Modify setProductionParameters (no extension)  May 11
# afy    Ver  36.01  Modify set*Directories (stateDir/outputDir)    May 11
# afy    Ver  37.00  Modify init (roll the project back)            June 11
# afy    Ver  38.00  Modify init (split outstager settings)         June 11
# afy    Ver  39.00  Modify init (add ppPreparer settings)          June 11
# afy    Ver  40.00  Modify setNamelists (save them unexpanded)     June 11
# afy    Ver  40.01  Add option --output-hashing                    June 11
# afy    Ver  41.00  Rename option --output-hashing => --checksum   June 11
# afy    Ver  42.00  Modify override*Namelists (fix checkNamelists) July 11
# afy    Ver  42.01  Use new module FREUtil (optionValuesListParse) July 11
# afy    Ver  42.02  Unify all the grep calls                       July 11
# afy    Ver  42.03  Add more option values checks                  July 11
# afy    Ver  42.04  Add option --compress                          July 11
# afy    Ver  42.05  Add option --output-cache                      July 11
# afy    Ver  42.06  Add option --argfiles                          July 11
# afy    Ver  43.00  Rename --output-cache => --cache-history       July 11
# afy    Ver  44.00  Remove option --argfiles                       August 11
# afy    Ver  44.01  Rename input stager properties                 August 11
# afy    Ver  44.02  Modify setRegressionParameters (bug fixes)     August 11
# afy    Ver  44.03  Modify overrideRegressionNamelists (no hours)  August 11
# afy    Ver  44.04  Add set*TimeStampOptions subroutines           August 11
# afy    Ver  44.05  Update the script using references             August 11
# afy    Ver  45.00  Use new module FRE.pm (init)                   September 11
# afy    Ver  46.00  Improve the option --output-staging processing September 11
# afy    Ver  46.01  Rename template flags 'Transfer' => 'Xfer'     September 11
# afy    Ver  46.02  Rename 'combineFreq' => 'segmentsPerPPCall'    September 11
# afy    Ver  46.03  Clarify the 'segmentsPerPPCall' calculation    September 11
# afy    Ver  46.04  Output staging - add check for the archiveDir  September 11
# afy    Ver  46.05  Online output staging - force no transfer      September 11
# afy    Ver  46.06  Don't set the pp.preparer constants            September 11
# afy    Ver  47.00  Add option --remote-user                       October 11
# afy    Ver  47.01  Call frelist to get remote dirs                October 11
# afy    Ver  47.02  Call frelist to get remote platform <csh>      October 11
# afy    Ver  47.03  Replace 'moduleInitDir' => 'modulesHomeDir'    October 11
# afy    Ver  47.04  Improve the option --transfer checkup          October 11
# afy    Ver  47.05  Fix platform/target setting in the runscript   October 11
# afy    Ver  47.06  Switch to stdoutDir before submitting          October 11
# afy    Ver  48.00  Set the 'userRemote' constant in the template  October 11
# afy    Ver  49.00  Modify 'init' (quote all the remote settings)  October 11
# afy    Ver  50.00  Modify 'init' (set 'freModuleFilesDir')        November 11
# afy    Ver  51.00  More complete and simple options checkup       November 11
# afy    Ver  51.01  Use 'FREUtil::listUnique' to remove dupes      November 11
# afy    Ver  52.00  Use new module FREExperiment (executable)      November 11
# afy    Ver  52.01  Modify init (more executable checks)           November 11
# afy    Ver  53.00  Modify getRemoteDirs (show FATAL only)         December 11
# afy    Ver  53.01  Modify getRemotePlatformCsh (show FATAL only)  December 11
# afy    Ver  53.02  Add outRemoteErrors (using new FREMsg.pm)      December 11
# afy    Ver  54.00  Remove outRemoteErrors subroutine              January 12
# afy    Ver  54.01  Simplify getRemoteDirs (no tcsh needed)        January 12
# afy    Ver  54.02  Simplify getRemotePlatformCsh (no tcsh needed) January 12
# afy    Ver  55.00  Modify setProductionDirectories (no dualing)   January 12
# afy    Ver  55.01  Modify process*Run (pass 'dual-names' flag)    January 12
# afy    Ver  55.02  Set 'dual-names' for dual production runs      January 12
# afy    Ver  56.00  Add option --free                              January 12
# afy    Ver  56.01  Add option --project                           January 12
# afy    Ver  57.00  Messages improving (for remote platform)       January 12
# afy    Ver  58.00  Reverse default for the option --free          January 12
# afy    Ver  59.00  Add the option --free dependency on property   January 12
# afy    Ver  60.00  Modify Usage (remove ASCII escapes)            February 12
# afy    Ver  60.01  Modify init (relax archive placement)          February 12
# afy    Ver  60.02  Modify outputScriptExecuteOrSubmit (delay)     February 12
# afy    Ver  61.00  Split stdoutDir setup using stdoutTmpDir       February 12
# afy    Ver  61.01  Modify init (stdoutDir, finisher)              February 12
# afy    Ver  62.00  Modify outputScriptStartTime (today => now)    April 12
# afy    Ver  63.00  Cosmetics in messages                          April 12
# afy -------------- Branch 18.0.2.63.2 --------------------------- August 12
# afy    Ver   1.00  Modify outputScriptExecuteOrSubmit (dual fix)  August 12
# afy    Ver   2.00  Add option --windfall                          December 12
# afy    Ver   2.01  Modify init (set windfall-dependent vars)      December 12
# afy    Ver   2.02  Use new FRETemplate (account, dualFlag)        December 12
# afy    Ver   3.00  Modify 'outputScriptExecuteOrSubmit'           January 13
# ------------------------------------------------------------------------------
# Copyright (C) NOAA Geophysical Fluid Dynamics Laboratory, 2000-2013
# Designed and written by V. Balaji, Amy Langenhorst and Aleksey Yakovlev
#

use strict;

use Cwd();
use Date::Manip();
use File::Basename();
use File::Spec();
use Getopt::Long(':config', 'no_ignore_case', 'no_auto_abbrev');
use List::Util();
use POSIX();

use FRE();
use FREDefaults();
use FREExperiment();
use FREMsg();
use FRETargets();
use FRETemplate();
use FREUtil();

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////// Global constants //
# //////////////////////////////////////////////////////////////////////////////

{

  package frerun;

  use constant VERSION => '$Id: frerun,v 18.0.2.63.2.3 2013/02/01 22:06:14 afy Exp $';

  use constant OPTLIST =>
  (
    'archive|a!',
    'check|c',
    'checksum|C',
    'cache-history|H',
    'combine-history|M!',
    'compress|z=s',
    'dual|D!',
    'extend|e',
    'free|f!',
    'namelist|N',
    'output-staging|O=s',
    'overwrite|o',
    'project|A=s',
    'regression|r=s',
    'remote-user|R=s',
    'submit-chained|S',
    'submit-staged',
    'transfer|T!',
    'unique|u',
    'windfall|W',
    'execute|E',
    'help|h',
    'ncores|n=i',
    'partition|P=s',
    'platform|p=s',
    'queue|q=s',
    'submit|s',
    'target|t=s',
    'version|V',
    'verbose|v+',
    'walltime|w=i',
    'xmlfile|x=s'
  );
  
  use constant PRAGMA_PREFIX => '#FRE';
  use constant PRAGMA_SETUP_PLATFORM_CSH => 'setup-platform-csh';
  use constant PRAGMA_EXPERIMENT_RUNTIME_CSH => 'experiment-runtime-csh';
  use constant PRAGMA_EXPERIMENT_INPUT_CSH_INIT => 'experiment-input-csh-init';
  use constant PRAGMA_EXPERIMENT_INPUT_CSH_ALWAYS_OR_POSTINIT => 'experiment-input-csh-always-or-postinit';
  use constant PRAGMA_EXPERIMENT_POSTPROCESS_CSH => 'experiment-postprocess-csh';

  use constant RUNSCRIPT_TEMPLATE_MAIN => 'runscript.template.main';

  use constant REGRESSION_SUITE => ('basic', 'restarts', 'scaling');
  
  use constant OUTPUT_COMPRESSION_TYPES => ('ascii', 'restart', 'history');
  
  use constant NCORES_DEFAULT => 2;
  use constant WALLTIME_DEFAULT => 30;
  
}

# //////////////////////////////////////////////////////////////////////////////
# ///////////////////////////////////////////////////////////////// Utilities //
# //////////////////////////////////////////////////////////////////////////////

{

  package frerun;

  my $self = File::Basename::basename($0);

  sub Usage()
  # ------ arguments: none
  {
    my $cwd = Cwd::getcwd();
    my $xml = FREDefaults::XMLFile();
    my $pfm = FREDefaults::Platform();
    my $tgt = FREDefaults::Target();
    return
    (
      "\n",
      "  Usage: $self [option|experiment] ...\n\n",
      "  Options:\n\n",
      "   -a,        --archive                   save the model output in the archive (negatable, default is on)\n",
      "   -H,        --cache-history             cache history files at a post-processing site (instead of putting them into archive)\n",     
      "   -c,        --check                     check the model output with the main model run (which makes sense for unique runs only)\n",
      "   -C,        --checksum                  compute checking sums for all the output data archives to enable their verification\n",
      "   -M,        --combine-history           combine history files after each segment run (negatable, default is on)\n",
      "   -z STRING, --compress=STRING           compress model output of type STRING (list of 'ascii', 'restart', 'history' or 'all')\n",
      "   -D,        --dual                      create a pair of runscripts - the main one and the dual one (negatable, default depends on site)\n",
      "   -e,        --extend                    extend default run of existing experiment\n",
      "   -f,        --free                      free working directory in the end of run (negatable, default depends on site)\n", 
      "   -N,        --namelist                  print all the namelists with all substitutions and overrides\n",
      "   -O STRING, --output-staging=STRING     type of output data staging (possible values depend on site)\n",     
      "   -o,        --overwrite                 overwrite the main run of existing experiment\n",
      "   -A STRING, --project=STRING            project account STRING to charge model running time to\n",
      "   -r STRING, --regression=STRING         run in regression test mode STRING with minimal output processing\n",
      "   -R STRING, --remote-user=STRING        use the remote user STRING for the model output transfer to a post-processing site\n",
      "   -S,        --submit-chained            submit all the created scripts as input data staging jobs, submitting run jobs at their end\n",
      "              --submit-staged             submit all the created scripts as batch jobs with input data staging\n",
      "   -T,        --transfer                  transfer all the model output back to a post-processing site (negatable, default depends on site)\n",
      "   -u,        --unique                    create a new unique run of existing experiment\n", 
      "   -W,        --windfall                  don't charge model running time to the project (may not be supported)\n\n", 
      "   -E,        --execute                   execute all the created scripts in the current session\n", 
      "   -h,        --help                      print help message and exit\n",
      "   -n NUM,    --ncores=NUM                number of processor cores to use for input data staging (default depends on site)\n",
      "   -P STRING, --partition=STRING          partition STRING to use for model runs\n",
      "   -p STRING, --platform=STRING           hardware and software platform STRING (default is '$pfm')\n", 
      "   -q STRING, --queue=STRING              queue STRING to use for model runs\n",
      "   -s,        --submit                    submit all the created scripts as batch jobs\n",
      "   -t STRING, --target=STRING             use compilation directives, targeted by STRING (default is '$tgt')\n", 
      "   -V,        --version                   print the tool version and exit\n",
      "   -v,        --verbose                   get verbose messages (repeat the option to increase verbosity level)\n", 
      "   -w NUM,    --walltime=NUM              maximum wall time (in minutes) to use for input data staging (default depends on site)\n", 
      "   -x FILE,   --xmlfile=FILE              experiment suite XML configuration FILE (default is '$cwd/$xml')\n\n", 
      "  At least one experiment from the FILE must be listed as an argument.\n\n"
    );
  }
  
  sub Help()
  # ------ arguments: none
  {
    my @usage = frerun::Usage();
    my $tgts = join("', '", FRETargets::all());
    my $tgst = join("', '", FRETargets::starters());
    return
    (
      "\n",
      "   Synopsis: $self creates a tcsh script to run FRE experiment(s).\n",
      "@usage",
      "   Use --noarchive to disallow saving model output into archive (valid for regression tests only).\n",
      "      The (unpacked) model output will be kept in the disk cache (ptmp) only.\n",
      "   Use --nocombine-history to disallow combining history files (valid for regression tests only).\n",
      "      This option is on by default, so history files will be combined after each segment run.\n",
      "   Use --overwrite, --extend or --unique to manipulate the experiment output directory.\n",
      "      You can completely overwrite the output directory, you can extend the run of the same experiment,\n",
      "      or you can create another unique instance of the output directory for the same experiment.\n",
      "   Use --dual to automatically create a pair of runscripts - the main one and the dual one.\n",
      "      The dual runscript is functionally identical to runscripts with --unique and --check options enabled,\n",
      "      it will keep the model output in a separate directory and compare it with the data from the main model run.\n",
      "      The --dual option is recognized for production runs only.\n", 
      "   Use --regression to run a regression test instead of the <production> run.\n", 
      "      Regression tests have minimal treatment of output files.\n",
      "   Use --submit-chained to automatically submit all the created scripts in the chaining mode.\n",
      "      The script is submitted with parameters, which allow it to perform input data staging,\n",
      "      to submit the normal run script (provided that the input data staging was successful), and then exit.\n",
      "      This makes sense, when the input data staging script and the normal run script have to be executed\n",
      "      in different computing environments (different access to filesystems, etc).\n",
      "   Use --submit-staged to automatically submit all the created scripts in the input data staging mode.\n",
      "      The same script is submitted twice with different parameters, so it works as the input data stager at first,\n",
      "      then it works normally with input data, prepared by the stager.\n",  
      "   Use --platform to pick a platform for experiment(s).\n", 
      "      The <platform> node in the experiment suite configuration file is used\n", 
      "      to set platform-specific data and instructions.\n",
      "   Use --target to define compilation and linkage directives for experiment(s).\n",
      "      Predefined targets refer to groups of directives, existing in the 'mkmf' template file.\n",
      "      Possible predefined targets are: '$tgts'.\n",
      "      Any number of targets from this list can be used here, and you can also add your own target (but not more than one).\n",
      "      Targets '$tgst' are mutually exclusive - not more than one of them is allowed in the target list.\n",
      "      Your own target should refer to a <compile> node with the corresponding value of its 'target' attribute.\n", 
      "      Multiple targets are separated by comma or dash. All the directives, referred by multiple targets, are merged.\n", 
      "   Use --execute to run the created script right away.\n",
      "      If the target platform is not where $self is being run, do not specify --execute.\n", 
      "      Submit as a batch job or run by hand on the right platform.\n",
      "   Use --submit to automatically submit all the created scripts as batch jobs.\n\n"
    );
  }

  sub regressionRunScriptName($$)
  # ------ arguments: $exp $extension
  {
    my ($z, $x) = @_;
    my ($expName, $scriptsDir) = ($z->name(), $z->scriptsDir());
    return "$scriptsDir/run/${expName}_$x"; 
  }

  sub productionRunScriptName($$)
  # ------ arguments: $exp $extension
  {
    my ($z, $x) = @_;
    my ($expName, $scriptsDir) = ($z->name(), $z->scriptsDir());
    return "$scriptsDir/run/$expName$x"; 
  }

  sub stdoutMainDir($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my $stdoutDir = $z->stdoutDir();
    return "$stdoutDir/run";
  }

  sub stdoutName($$)
  # ------ arguments: $exp $scriptName
  {
    my ($z, $n) = @_;
    my ($basename, $stdoutTmpDir, $jobId) = (File::Basename::basename($n), $z->stdoutTmpDir(), FREUtil::jobID());
    return "$stdoutTmpDir/run/$basename.o$jobId";
  }

  sub createDirectory($$)
  # ------ arguments: $fre $directory
  # ------ create a directory 
  {
    my ($fre, $d) = @_;
    if (-d $d)
    {
      if (-w $d)
      {
        return 1;
      }
      else
      {
        $fre->out(FREMsg::FATAL, "The directory '$d' exists, but it's not writable");
	return 0;
      }
    }
    else
    {
      return FREUtil::createDir($d);
    }
  }

  sub getTemplate($$)
  # ------ arguments: $fre $filename
  # ------ returns a script template from the site directory
  # ------ return ($sript, $status)
  {
    my ($fre, $n) = @_;
    my $pathname = $fre->siteDir() . '/' . $n;
    if (open my $templateHandle, '<', $pathname)
    {
      $/ = undef;
      my $s = <$templateHandle>;
      $s =~ s/^# ?$//mg;
      $s =~ s/^# .*$//mg;
      $s =~ s/\n{2,}/\n\n/sg;
      close $templateHandle;
      return ($s, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(FREMsg::FATAL, "The main runscript template '$pathname' isn't found");
      return (0, FREDefaults::STATUS_FRE_RUN_NO_TEMPLATE);
    }
  }
  
  sub execName($)
  # ------ arguments: $exp
  {
    my $z = shift;
    my ($value, $exp) = $z->extractExecutable();
    if ($value)
    {
      return $value;
    }
    elsif ($exp)
    {
      return $exp->executable();
    }
    else
    {
      return undef;
    }
  }

  sub getRemoteDirs($$$)
  # ------ arguments: $exp $platform $user
  {
    my ($z, $p, $u) = @_;
    my ($fre, $expName) = ($z->fre(), $z->name());
    my ($target, $xmlfile) = ($fre->target(), $fre->configFileAbsPathName());
    my $cmd = "frelist --xmlfile=$xmlfile --platform=$p --target=$target --directory=stdout,stmp,archive $expName";
    $cmd .= " --remote-user=$u" if $u;
    my $res = qx($cmd);
    if ($? == 0)
    {
      my @res = ();
      foreach my $dir (split(/\n/, $res))
      {
        $dir =~ s/^\w+: //;
	push @res, $dir;
      }
      return @res;
    }
    else
    {
      return ();
    }
  }
  
  sub getRemotePlatformCsh($$)
  # ------ arguments: $exp $platform
  {
    my ($z, $p) = @_;
    my $fre = $z->fre();
    my ($target, $xmlfile) = ($fre->target(), $fre->configFileAbsPathName());
    my $cmd = "frelist --xmlfile=$xmlfile --platform=$p --target=$target --platform-csh";
    my $res = qx($cmd);
    if ($? == 0)
    {
      $res =~ s/^\s*//mg;
      $res =~ s/ +/ /mg;
      $res =~ s/\$/\\\$/mg;
      $res =~ s/\t+/\t/mg;
      $res =~ s/\n+/\n/sg;
      $res =~ s/(?: |\t)/+/sg;
      $res =~ s/\n/:/sg;
      return $res;
    }
    else
    {
      return '';
    }
  }  

  sub init($%)
  # ------ arguments: $exp %options
  # ------ return ($sript, $status)
  {

    my ($z, %o) = @_;
    my $fre = $z->fre();
    
    my ($s, $status) = frerun::getTemplate($fre, frerun::RUNSCRIPT_TEMPLATE_MAIN);
    if ($s)
    {

      # ------------------------------------- executable

      my $execName = frerun::execName($z);
      if ($execName)
      {
	if (-f $execName)
	{
	  if (-x $execName)
	  {
	    $fre->out(FREMsg::NOTE, "Using executable '$execName'...");
	  }
	  else
	  {
	    $fre->out(FREMsg::FATAL, "Your executable '$execName' exists, but you don't have permissions to run it");
            return (0, FREDefaults::STATUS_FS_PERMISSION_PROBLEM);
	  }
	}
	else
	{
	  $fre->out(FREMsg::WARNING, "Your executable '$execName' doesn't exist");
	}
      }
      else
      {
	$fre->out(FREMsg::FATAL, "Can't determine the executable pathname");
        return (0, FREDefaults::STATUS_FRE_GENERIC_PROBLEM);
      }

      # ------------------------------------------------------------------------ output data staging and transfer

      my @flagOutputStagingTypes = split(/;/, $fre->property('FRE.output.staging'));
      my $flagOutputStagingTypeDefault = $flagOutputStagingTypes[0];
      my $flagOutputStagingType = $o{'output-staging'} || $z->extractValue('postProcess/@combine');
      my $flagOutputTransfer = ($o{transfer}) ? 'On' : 'Off';

      if ($flagOutputStagingType)
      {
	if (scalar(grep($_ eq $flagOutputStagingType, @flagOutputStagingTypes)) > 0)
	{
          $fre->out(FREMsg::NOTE, "The '$flagOutputStagingType' output staging type will be used...");
	}
	else
	{
	  $fre->out(FREMsg::WARNING, "The '$flagOutputStagingType' output staging type isn't supported at this site - using the '$flagOutputStagingTypeDefault' one...");
	  $flagOutputStagingType = $flagOutputStagingTypeDefault;
	}
      }
      else
      {
        $fre->out(FREMsg::WARNING, "The output staging type isn't defined - using the '$flagOutputStagingTypeDefault' one...");
        $flagOutputStagingType = $flagOutputStagingTypeDefault;
      }
      
      my $roots = $fre->property("FRE.output.staging.$flagOutputStagingType.transfer$flagOutputTransfer.archive.roots");
      if ($roots)
      {
        my ($archiveDir, $rootsForMatch) = ($z->archiveDir(), $roots);
	$rootsForMatch =~ s/\$/\\\$/g;
	if (scalar(grep("$archiveDir/" =~ m/^$_\//, split(';', $rootsForMatch))) == 0)
	{
	  my ($msg, @roots) = ('', split(';', $roots));
	  if (scalar(@roots) > 1)
	  {
	    my $rootsForOut = join(', ',  @roots);
	    $msg = "one of ($rootsForOut) filesystems";
	  }
          else
	  {
	    $msg = "the '$roots[0]' filesystem";
	  }
	  my $flagOutputTransferMsg = ($flagOutputTransfer eq 'On') ? '--transfer' : '--notransfer';
	  $fre->out(FREMsg::FATAL, "Combination of options --output-staging=$flagOutputStagingType and $flagOutputTransferMsg requires the archive directory to be on $msg");
          return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	}
      }
      else
      {
	$fre->out(FREMsg::FATAL, "The 'FRE.output.staging.$flagOutputStagingType.transfer$flagOutputTransfer.archive.roots' external property is absent or empty!!!");
        return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
      }
      
      if ($flagOutputTransfer eq 'On')
      {
	if (scalar(@flagOutputStagingTypes) == 1 or $flagOutputStagingType ne 'online')
	{
          $fre->out(FREMsg::NOTE, "The model output will be transferred to the post-processing site...");
	}
	else
	{
          $flagOutputTransfer = 'Off';
          $fre->out(FREMsg::WARNING, "You can use the --transfer option only when the staging type isn't online - ignored...");
	}
      }
      
      # --------------------------------------------------------------------------------------- history combining

      my $flagOutputCombineHistory = ($o{'combine-history'}) ? 'On' : 'Off';
      if ($flagOutputCombineHistory eq 'Off')
      {
        if ($o{regression})
	{
          $fre->out(FREMsg::NOTE, "The history won't be combined...");
	}
	else
        {
	  $flagOutputCombineHistory = 'On';
	  $fre->out(FREMsg::WARNING, "You can use the --nocombine-history option for regression tests only - ignored...");
	}
      }

      # -------------------------------------------------------------------------------- output archiving

      my $flagOutputArchive = ($o{archive}) ? 'On' : 'Off';
      if ($flagOutputArchive eq 'Off')
      {
	if ($o{regression})
	{
          $fre->out(FREMsg::NOTE, "The model output will be kept in the disk cache only...");
	}
	else
	{
          $flagOutputArchive = 'On';
          $fre->out(FREMsg::WARNING, "You can use the --noarchive option for regression tests only - ignored...");
	}
      }
      
      # ------------------------------------------------------------------------------ output post-processing
      
      my $flagOutputPostProcess = (!$o{regression} && !$o{unique}) ? 'On' : 'Off';
      
      # ------------------------------------------------------------------------- getFmsData and its parameters

      my @getFmsData = ($fre->getFmsData() || '$freCommandsHomeDir/bin/get_fms_data');
      my $fmsRelease = $fre->fmsRelease();
      push @getFmsData, ('-r', $fmsRelease) if $fmsRelease;
      
      # ----------------------------------------------------------------------------------------- remote platform
      
      my $remotePlatform = FREPlatforms::siteReplace($fre->platform(), 'gfdl');
      
      # --------------------------------------------------------------------------------------- remote directories
      
      my @remoteDirs = ('', '', '');
      if ($flagOutputTransfer eq 'On')
      {
	@remoteDirs = frerun::getRemoteDirs($z, $remotePlatform, $o{'remote-user'});
	if (scalar(@remoteDirs) > 0)
	{
          $fre->out(FREMsg::NOTE, "Remote directories to be used:", "stdout  = $remoteDirs[0]", "stmp    = $remoteDirs[1]", "archive = $remoteDirs[2]");
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to determine remote directories - please check your platform '$remotePlatform'");
          return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	}  
      }
      
      # --------------------------------------------------------------------------------------- remote platform csh
      
      my $remotePlatformCsh = '';
      if ($flagOutputTransfer eq 'On' && $flagOutputPostProcess eq 'On')
      {
        $remotePlatformCsh = frerun::getRemotePlatformCsh($z, $remotePlatform);
	if ($remotePlatformCsh)
	{
          $fre->out(FREMsg::NOTE, "Remote platform csh to be used - '$remotePlatformCsh'");
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to determine remote platform csh - please check your platform '$remotePlatform'");
          return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	}
      }

      # ------------------------------------------------------------------------- setting constants/variables 

      FRETemplate::setFlag(\$s, 'flagRunType', ($o{regression}) ? 'Regression' : 'Production');
      FRETemplate::setFlag(\$s, 'flagCheckSum', ($o{checksum}) ? 'On' : 'Off');
      FRETemplate::setFlag(\$s, 'flagWorkDirClean', ($o{free}) ? 'On' : 'Off');
      FRETemplate::setFlag(\$s, 'flagOutputType', ($o{extend}) ? 'Extend' : (($o{overwrite}) ? 'Overwrite' : (($o{unique}) ? 'Unique' : 'Initial')));
      FRETemplate::setFlag(\$s, 'flagOutputFormat', (FRETargets::containsHDF5($fre->target())) ? 'HDF5' : '64Bit');
      FRETemplate::setFlag(\$s, 'flagOutputStagingType', ucfirst $flagOutputStagingType);
      FRETemplate::setFlag(\$s, 'flagOutputCacheHistory', ($o{'cache-history'}) ? 'On' : 'Off');
      FRETemplate::setFlag(\$s, 'flagOutputCombineHistory', $flagOutputCombineHistory);
      FRETemplate::setFlag(\$s, 'flagOutputCompressAscii', ($o{compress} =~ m/ascii/) ? 'On' : 'Off');
      FRETemplate::setFlag(\$s, 'flagOutputCompressRestart', ($o{compress} =~ m/restart/) ? 'On' : 'Off');
      FRETemplate::setFlag(\$s, 'flagOutputCompressHistory', ($o{compress} =~ m/history/) ? 'On' : 'Off');
      FRETemplate::setFlag(\$s, 'flagOutputArchive', $flagOutputArchive);
      FRETemplate::setFlag(\$s, 'flagOutputPostProcess', $flagOutputPostProcess);
      FRETemplate::setFlag(\$s, 'flagOutputXfer', $flagOutputTransfer);
      FRETemplate::setFlag(\$s, 'flagOutputCheck', ($o{check}) ? 'On' : 'Off');

      FRETemplate::setVariable(\$s, 'windfallFlagInit', ($o{windfall}) ? '1' : '0');
      
      FRETemplate::setVariable(\$s, 'platform', $fre->platform());
      FRETemplate::setVariable(\$s, 'target', $fre->target());
      FRETemplate::setVariable(\$s, 'name', $z->name());
      FRETemplate::setVariable(\$s, 'rtsxml', $fre->configFileAbsPathName());
      FRETemplate::setVariable(\$s, 'modulesHomeDir', $fre->property('FRE.tool.modules.home'));
      FRETemplate::setVariable(\$s, 'freModuleFilesDir', $fre->property('FRE.tool.modules.use'));
      FRETemplate::setVariable(\$s, 'freCommandsHomeDir', FRE::home());
      FRETemplate::setVariable(\$s, 'stdoutDir', frerun::stdoutMainDir($z));
      FRETemplate::setVariable(\$s, 'workDir', $z->workDir());
      FRETemplate::setVariable(\$s, 'ptmpDir', $z->ptmpDir());
      FRETemplate::setVariable(\$s, 'archiveDir', $z->archiveDir());
      FRETemplate::setVariable(\$s, 'executable', $execName);
      FRETemplate::setVariable(\$s, 'mailMode', $fre->mailMode());
      FRETemplate::setVariable(\$s, 'project', $fre->project());
      
      FRETemplate::setVariable(\$s, 'stdoutDirRemote', "'$remoteDirs[0]'");
      FRETemplate::setVariable(\$s, 'stmpDirRemote', "'$remoteDirs[1]'");
      FRETemplate::setVariable(\$s, 'archiveDirRemote', "'$remoteDirs[2]'");
      FRETemplate::setVariable(\$s, 'userRemote', "'$o{'remote-user'}'"); 
      FRETemplate::setVariable(\$s, 'platformRemote', "'$remotePlatform'");
      FRETemplate::setVariable(\$s, 'envRemote', "'$remotePlatformCsh'");
      
      FRETemplate::setVariable(\$s, 'outputStagerPartition', $fre->property('FRE.scheduler.outputStager.partition'));
      FRETemplate::setVariable(\$s, 'outputStagerQueue', $fre->property('FRE.scheduler.outputStager.queue'));
      FRETemplate::setVariable(\$s, 'outputStagerCoreSpec', $fre->property('FRE.scheduler.outputStager.coreSpec'));
      FRETemplate::setVariable(\$s, 'outputStagerRuntimeAscii', $fre->property('FRE.scheduler.outputStager.runtime.ascii') || $fre->property('FRE.scheduler.runtime.max'));
      FRETemplate::setVariable(\$s, 'outputStagerRuntimeRestart', $fre->property('FRE.scheduler.outputStager.runtime.restart') || $fre->property('FRE.scheduler.runtime.max'));
      FRETemplate::setVariable(\$s, 'outputStagerRuntimeHistory', $fre->property('FRE.scheduler.outputStager.runtime.history') || $fre->property('FRE.scheduler.runtime.max'));
      
      FRETemplate::setVariable(\$s, 'outputStagerSavePartition', $fre->property('FRE.scheduler.outputStager.save.partition'));
      FRETemplate::setVariable(\$s, 'outputStagerSaveQueue', $fre->property('FRE.scheduler.outputStager.save.queue'));
      FRETemplate::setVariable(\$s, 'outputStagerSaveCoreSpec', $fre->property('FRE.scheduler.outputStager.save.coreSpec'));
      FRETemplate::setVariable(\$s, 'outputStagerSaveRuntimeAscii', $fre->property('FRE.scheduler.outputStager.save.runtime.ascii') || $fre->property('FRE.scheduler.runtime.max'));
      FRETemplate::setVariable(\$s, 'outputStagerSaveRuntimeRestart', $fre->property('FRE.scheduler.outputStager.save.runtime.restart') || $fre->property('FRE.scheduler.runtime.max'));
      FRETemplate::setVariable(\$s, 'outputStagerSaveRuntimeHistory', $fre->property('FRE.scheduler.outputStager.save.runtime.history') || $fre->property('FRE.scheduler.runtime.max'));
      
      FRETemplate::setVariable(\$s, 'outputStagerXferPartition', $fre->property('FRE.scheduler.outputStager.transfer.partition'));
      FRETemplate::setVariable(\$s, 'outputStagerXferQueue', $fre->property('FRE.scheduler.outputStager.transfer.queue'));
      FRETemplate::setVariable(\$s, 'outputStagerXferCoreSpec', $fre->property('FRE.scheduler.outputStager.transfer.coreSpec'));
      FRETemplate::setVariable(\$s, 'outputStagerXferRuntimeAscii', $fre->property('FRE.scheduler.outputStager.transfer.runtime.ascii') || $fre->property('FRE.scheduler.runtime.max'));
      FRETemplate::setVariable(\$s, 'outputStagerXferRuntimeRestart', $fre->property('FRE.scheduler.outputStager.transfer.runtime.restart') || $fre->property('FRE.scheduler.runtime.max'));
      FRETemplate::setVariable(\$s, 'outputStagerXferRuntimeHistory', $fre->property('FRE.scheduler.outputStager.transfer.runtime.history') || $fre->property('FRE.scheduler.runtime.max'));
      
      FRETemplate::setVariable(\$s, 'workDirCleanerPartition', $fre->property('FRE.scheduler.workDirCleaner.partition'));
      FRETemplate::setVariable(\$s, 'workDirCleanerQueue', $fre->property('FRE.scheduler.workDirCleaner.queue'));
      FRETemplate::setVariable(\$s, 'workDirCleanerCoreSpec', $fre->property('FRE.scheduler.workDirCleaner.coreSpec'));
      FRETemplate::setVariable(\$s, 'workDirCleanerRuntime', $fre->property('FRE.scheduler.workDirCleaner.runtime') || $fre->property('FRE.scheduler.runtime.max'));
      
      FRETemplate::setVariable(\$s, 'finisherPartition', $fre->property('FRE.scheduler.finisher.partition'));
      FRETemplate::setVariable(\$s, 'finisherQueue', $fre->property('FRE.scheduler.finisher.queue'));
      FRETemplate::setVariable(\$s, 'finisherCoreSpec', $fre->property('FRE.scheduler.finisher.coreSpec'));
      FRETemplate::setVariable(\$s, 'finisherRuntime', $fre->property('FRE.scheduler.finisher.runtime') || $fre->property('FRE.scheduler.runtime.max'));
      
      FRETemplate::setVariable(\$s, 'ppStarterPartition', $fre->property('FRE.scheduler.ppStarter.partition'));
      FRETemplate::setVariable(\$s, 'ppStarterQueue', $fre->property('FRE.scheduler.ppStarter.queue'));
      FRETemplate::setVariable(\$s, 'ppStarterCoreSpec', $fre->property('FRE.scheduler.ppStarter.coreSpec'));
      FRETemplate::setVariable(\$s, 'ppStarterRuntime', $fre->property('FRE.scheduler.ppStarter.runtime') || $fre->property('FRE.scheduler.runtime.max'));
      
      FRETemplate::setList(\$s, 'windfallOptionsSet', FRETemplate::schedulerAccountAsString($z, 1));
      FRETemplate::setList(\$s, 'windfallOptionsUnset', FRETemplate::schedulerAccountAsString($z, 0));
      FRETemplate::setList(\$s, 'ppRefineDiagScriptNames', $z->extractPPRefineDiagScripts());
      FRETemplate::setList(\$s, 'getFmsData', @getFmsData);

      # ------------------------------------------ normal return

      return ($s, FREDefaults::STATUS_OK);

    }
    else
    {
    
      return (0, $status);
      
    }

  }

  sub prepareInputFile($$$)
  # ------ arguments: $exp $source $target
  # ------ internal helper to setup an input file
  # ------ return ($sript, $status)
  {

    my ($z, $s, $t) = @_;
    my $fre= $z->fre();

    if (File::Spec->file_name_is_absolute($s))
    {

      if (!File::Spec->file_name_is_absolute($t))
      {

	my $csh = '';

        my $sName = substr($s, 1);
	my $sArchiveFlag = FREUtil::fileIsArchive($s);
	$sName = FREUtil::fileArchiveExtensionStrip($sName) if $sArchiveFlag;

	my ($tFileName, $tDirName) = File::Basename::fileparse($t);
	my $tDirectoryFlag = ($tDirName ne './');
	
	if ($sArchiveFlag and $tDirectoryFlag and !$tFileName)
	{
	  $csh .= 'hsmget ' . $sName . '/\* && \\' . "\n";
          $csh .= 'if (! -d $workDir/' . $tDirName . ') mkdir -p $workDir/' . $tDirName . ' && \\' . "\n";
	  $csh .= 'ls $hsmDir/' . $sName . '/* | xargs ln -f -t $workDir/' . $tDirName . "\n";
	}
	elsif ($sArchiveFlag and $tFileName)
	{
	  $fre->out(FREMsg::FATAL, "The source archive '$s' can't be linked to the non-directory target '$t'");
	  return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
	}
	elsif (!$sArchiveFlag and ($tDirectoryFlag or $tFileName))
	{
	  $csh .= 'hsmget ' . $sName . ' && \\' . "\n";
          $csh .= 'if (! -d $workDir/' . $tDirName . ') mkdir -p $workDir/' . $tDirName . ' && \\' . "\n" if $tDirectoryFlag;
	  $csh .= 'ln -f $hsmDir/' . $sName . ' $workDir/' . $tDirName . (($tFileName) ? $tFileName : '.') . "\n";
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The target pathname is empty");
	  return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
	}

	if ($csh)
	{
	  $csh .= 'if ( $status != 0 ) then' . "\n";
	  $csh .= '  set dataFilesNotOK = ( $dataFilesNotOK ' . $s . ' )' . "\n";
	  $csh .= 'endif' . "\n";
	}

	return ($csh, FREDefaults::STATUS_OK);
	  
      }
      else
      {
	$fre->out(FREMsg::FATAL, "The target pathname '$t' isn't relative");
	return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "The source pathname '$s' isn't absolute");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

  }

  sub setInputVariableFile($$$)
  # ------ arguments: $refToScript $exp $variableName
  # ------ internal helper to setup an input file, defined via a shell variable
  {
    my ($r, $z, $n) = @_;
    my ($fre, $fileName) = ($z->fre(), $z->extractVariableFile($n));
    if ($fileName)
    {
      $fre->out(FREMsg::NOTE, "name='$n' value='$fileName'");
      FRETemplate::setVariable($r, $n, $fileName);
    }
    else
    {
      $fre->out(FREMsg::WARNING, "Variable '$n' has no value");
      FRETemplate::setVariable($r, $n, "''");
    }
  }

  sub setInputInitialConditions($$)
  # ------ arguments: $refToScript $exp
  {
    my ($r, $z) = @_;
    frerun::setInputVariableFile($r, $z, 'initCond');
  }

  sub setInputGridSpecification($$)
  # ------ arguments: $refToScript $exp
  {
    my ($r, $z) = @_;
    frerun::setInputVariableFile($r, $z, 'gridSpec');
  }

  sub setInputDatasets($$)
  # ------ arguments: $script $exp
  # ------ return ($sript, $status)
  {

    my ($s, $z) = @_;
    my ($fre, @results) = ($z->fre(), $z->extractDatasets());
    my $dataSets;
    my $csh;

    while (scalar(@results) > 0)
    {
      my $source = shift @results;
      my $target = shift @results;
      if ($source =~ m/\//)
      {
	my ($cshSnippet, $status) = frerun::prepareInputFile($z, $source, $target);
	if ($cshSnippet)
	{
          $csh .= $cshSnippet . "\n";
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The pathname '$source' can't be setup in the runscript");
	  return (0, $status);
	}
      }
      else
      {
        $dataSets .= ' ' . $source;
      }
    }

    if ($dataSets)
    {
      $fre->out(FREMsg::WARNING, "The usage of 'get_fms_data' datasets is deprecated - please list your input files explicitly in the XML file");
      $s =~ s/#fmsDataSets_from_xml/get_fms_data$dataSets/;
    }
    else
    {
      $s =~ s/#fmsDataSets_from_xml//;
    }
    
    $s =~ s/#dataFiles_from_xml/$csh/;

    return ($s, FREDefaults::STATUS_OK);

  }

  sub setShellCommands($$)
  # ------ arguments: $refToScript $exp
  {
  
    my ($r, $z) = @_;

    my %adjustment =
    (
      init	=> ['if ( $irun == 1 && $ireload == 1 ) then'."\n", "\n".'endif'."\n"],
      postInit	=> ['if ( $irun != 1 || $ireload != 1 ) then'."\n", "\n".'endif'."\n"]
    );
    
    my $expand = sub($$)
    {
      my ($k, $v) = @_;
      my $prefix = frerun::PRAGMA_PREFIX;
      my $placeholder = qr/^[ \t]*$prefix[ \t]+$k[ \t]*$/m;
      chomp ($v);
      ${$r} =~ s/$placeholder/$v/;
    };

    $expand->(frerun::PRAGMA_SETUP_PLATFORM_CSH, $z->fre()->platformValue('csh'));
    $expand->(frerun::PRAGMA_EXPERIMENT_RUNTIME_CSH, $z->extractShellCommands('runtime/csh'));
    $expand->(frerun::PRAGMA_EXPERIMENT_INPUT_CSH_INIT, $z->extractShellCommands('input/csh[not(@type="always") and not(@type="postInit")]', %adjustment));
    $expand->(frerun::PRAGMA_EXPERIMENT_INPUT_CSH_ALWAYS_OR_POSTINIT, $z->extractShellCommands('input/csh[@type="always" or @type="postInit"]', %adjustment));
    $expand->(frerun::PRAGMA_EXPERIMENT_POSTPROCESS_CSH, $z->extractShellCommands('postProcess/csh'));
    
  }

  sub calendarType($)
  # ------ arguments: $refToNamelistsHash
  {
    my $l = shift;
    my $calendarType;
    foreach my $key (sort keys %{$l})
    {
      my $value = $l->{$key};
      $value =~ s/^\s*!.*$//mg;
      if ($value =~ m/calendar\s*=\s*(?:'(.*)'|"(.*)")/m)
      {
        $calendarType = $1;
	last;
      }
    }
    return $calendarType;
  }

  sub baseDate($)
  # ------ arguments: $namelist
  {
    my $l = shift;
    my $baseDate = ($l =~ m/current_date\s*=\s*(\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+)/s) ? $1 : '0,0,0,0,0,0';
    $baseDate =~ s/,/ /g;
    return $baseDate;
  }

  sub setTables($$$)
  # ------ arguments: $script $exp $namelist
  # ------ return ($sript, $status)
  {
  
    my ($s, $z, $l) = @_;
    my $fre = $z->fre();
    $l =~ s/^\s*!.*$//mg;
    
    $fre->out(FREMsg::NOTE, "Extracting tables...");

    # --------------------------------------------------------------------- dataTable
    
    my $dataTable = $z->extractTable('dataTable');
    if ($dataTable != -1)
    {
      $dataTable = "cat >> data_table <<EOF\n$dataTable\nEOF\n" if $dataTable;
      $s =~ s/#dataTable_from_xml/$dataTable/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the data table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------------- fieldTable

    my $fieldTable = $z->extractTable('fieldTable');
    if ($fieldTable != -1)
    {
      if ($l)
      {
	if ($fieldTable !~ /^\s*"TRACER"\s*,\s*"atmos_mod"\s*,\s*"sphum".*/im)
	{
          $fieldTable .= '# added by FRE: sphum must be present in atmos' . "\n";
	  $fieldTable .= ' "TRACER", "atmos_mod",    "sphum"' . "\n";
	  $fieldTable .= '           "longname",     "specific humidity"' . "\n";
	  $fieldTable .= '           "units",        "kg/kg" /'. "\n";
	}
	if ($fieldTable !~ /^\s*"TRACER"\s*,\s*"land_mod"\s*,\s*"sphum".*/im)
	{
          $fieldTable .= '# added by FRE: sphum must be present on land' . "\n";
	  $fieldTable .= ' "TRACER", "land_mod",     "sphum"' . "\n";
	  $fieldTable .= '           "longname",     "specific humidity"' . "\n";
	  $fieldTable .= '           "units",        "kg/kg" /' . "\n";
	}
      }
      $fieldTable = "cat >> field_table <<EOF\n$fieldTable\nEOF\n" if $fieldTable; 
      $s =~ s/#fieldTable_from_xml/$fieldTable/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the field table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------------------- diagTable
    
    my $diagTable = $z->extractTable('diagTable');
    if ($diagTable != -1)
    {
      my $baseDate = frerun::baseDate($l);
      FRETemplate::setVariable(\$s, 'baseDate', "'$baseDate'");
      $diagTable =~ s/^\s*\$baseDate\s*$/$baseDate/m;
      $diagTable = "cat >> diag_table <<EOF\n$diagTable\nEOF\n" if $diagTable; 
      $s =~ s/#diagTable_from_xml/$diagTable/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the diagnostic table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # ------------------------------------------------------------------------ tracerTreeTable
    
    my $tracerTreeTable = $z->extractTable('tracerTreeTable');
    if ($tracerTreeTable != -1)
    {
      $tracerTreeTable = "cat >> ocean_tracer_tree <<EOF\n$tracerTreeTable\nEOF\n" if $tracerTreeTable;
      $s =~ s/#tracerTreeTable_from_xml/$tracerTreeTable/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the tracer tree table");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # -------------------------------------------------------------------- tracerTreeInit
    
    my $tracerTreeInit = $z->extractTable('tracerTreeInit');
    if ($tracerTreeInit != -1)
    {
      $tracerTreeInit = "cat >> ocean_tracer_tree_init <<EOF\n$tracerTreeInit\nEOF\n" if $tracerTreeInit;
      $s =~ s/#tracerTreeInit_from_xml/$tracerTreeInit/;
    }
    else
    {
      $fre->out(FREMsg::FATAL, "A problem with the tracer tree initialization");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
    }

    # ------------------- normal return
    
    return ($s, FREDefaults::STATUS_OK);

  }

  sub setRegressionParameters($$$$$$)
  # ------ arguments: $script $exp $runNode $partition $queue $dualFlag
  # ------ return ($sript, $extension, $status)
  {

    my ($s, $z, $n, $p, $q, $f) = @_;
    my $fre = $z->fre();

    # -------------------------------------------- extract parameter values

    my $np = $z->nodeValue($n, '@npes');
    my $ml = $z->nodeValue($n, '@months');
    my $dl = $z->nodeValue($n, '@days');
    my $hl = $z->nodeValue($n, '@hours');
    my $rt = $z->nodeValue($n, '@runTimePerJob');

    # ----------------------------------------------- adjust months/days/hours lists 

    my @ma = split(' ', $ml);
    my @da = split(' ', $dl);
    my @ha = split(' ', $hl);

    my $nr = List::Util::max(scalar(@ma), scalar(@da), scalar(@ha));

    while (@ma < $nr) {push(@ma, '0');}
    while (@da < $nr) {push(@da, '0');}
    while (@ha < $nr) {push(@ha, '0');}

    # ------------------------------------------------------ check and adjust regression model time

    if ($np > 0)
    {
      if ($nr > 0)
      {
	my $patternRunTime = qr/^\d\d:\d\d:\d\d$/;
	if ($rt =~ m/$patternRunTime/)
	{
	  # ----------------------------------------------------------------- set parameters in the script
	  FRETemplate::setVariable(\$s, 'npes', $np);
	  FRETemplate::setVariable(\$s, 'segmentsPerSimulation', $nr);
	  FRETemplate::setVariable(\$s, 'segmentsPerPPCall', 0);
	  FRETemplate::setVariable(\$s, 'segmentsPerJob', $nr);
	  FRETemplate::setVariable(\$s, 'jobsPerSimulation', 1);
	  FRETemplate::setList(\$s, 'monthslist', @ma);
	  FRETemplate::setList(\$s, 'dayslist', @da);
	  FRETemplate::setList(\$s, 'hourslist', @ha);
	  # ------------------------------------------------------------------------------- set scheduler resources
	  FRETemplate::setSchedulerResources(\$s, $z, 'run', $np, $rt, $p, $q, $f);
	  # ------------------------------------------------------------------------------- generate extension string
	  my $x =
	  (
	    ($z->nodeValue($n, '@hours'))
	    ?
	    $nr . 'x' . $ma[0] . 'm' . $da[0] . 'd' . $ha[0] . 'h_' . $np . 'pe'
	    :
	    $nr . 'x' . $ma[0] . 'm' . $da[0] . 'd_' . $np . 'pe'
	  );
	  # ------------------------------------------------------------------------------------------ normal return
	  return ($s, $x, FREDefaults::STATUS_OK);
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Regression running time '$rt' must be nonempty and have the HH:MM:SS format");
	  return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	}
      }
      else
      {
	$fre->out(FREMsg::FATAL, "Model running time (months, days or hours) must be defined");
	return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Number of cores must be a positive integer");
      return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
    }

  }
  
  sub productionParametersExist($)
  # ------ arguments: $exp
  # ------ return 1 if production runtime parameters exist
  {
    my $z = shift;
    my $simTime = $z->extractValue('runtime/production/@simTime');
    return ($simTime) ? 1 : 0;
  }
  
  sub setProductionParameters($$$$$)
  # ------ arguments: $script $exp $partition $queue $dualFlag
  # ------ return ($sript, $status)
  {

    my ($s, $z, $p, $q, $f) = @_;
    my $fre = $z->fre();

    # --------------------------------------- extract timing parameters

    my $np	   = $z->extractValue('runtime/production/@npes');
    my $simTime    = $z->extractValue('runtime/production/@simTime');
    my $simUnits   = $z->extractValue('runtime/production/@units');
    my $simRunTime = $z->extractValue('runtime/production/@runTime') || $fre->runTime($np);
    my $segTime    = $z->extractValue('runtime/production/segment/@simTime');
    my $segUnits   = $z->extractValue('runtime/production/segment/@units');
    my $segRunTime = $z->extractValue('runtime/production/segment/@runTime');

    # ------------------------------------------------------ check and adjust simulation/segment model time

    if ($np > 0)
    {
      my $patternUnits = qr/^(?:years|year|months|month)$/;
      if (($simTime > 0) and ($simUnits =~ m/$patternUnits/))
      {
        if (($segTime > 0) and ($segUnits =~ m/$patternUnits/))
	{
	  my $patternYears = qr/^(?:years|year)$/;
	  $simTime *= 12 if $simUnits =~ m/$patternYears/;
	  $segTime *= 12 if $segUnits =~ m/$patternYears/;
	  if ($segTime <= $simTime)
	  {
	    my $patternRunTime = qr/^\d\d:\d\d:\d\d$/;
	    if ($simRunTime =~ m/$patternRunTime/)
	    {
	      if ($segRunTime =~ m/$patternRunTime/)
	      {
		my ($simRunTimeMinutes, $segRunTimeMinutes) = (FREUtil::makeminutes($simRunTime), FREUtil::makeminutes($segRunTime));
		if ($segRunTimeMinutes <= $simRunTimeMinutes)
		{
		  # ---------------------------------------------------------------------------- print original values
		  $fre->out(FREMsg::NOTE, "simTime = $simTime months, segTime = $segTime months");
		  $fre->out(FREMsg::NOTE, "simRunTimeMin = $simRunTimeMinutes minutes, segRunTimeMin = $segRunTimeMinutes minutes");
		  # --------------------------------------------------------------------------------- calculate major timing parameters
		  my $segPerSim = POSIX::ceil($simTime / $segTime);
		  $fre->out(FREMsg::NOTE, "segPerSim ($segPerSim) = simTime ($simTime) / segTime ($segTime) (rounded up)");
		  my $segPerJob = POSIX::floor($simRunTimeMinutes / $segRunTimeMinutes);
		  $fre->out(FREMsg::NOTE, "segPerJob ($segPerJob) = simRunTimeMin ($simRunTimeMinutes) / segRunTimeMin ($segRunTimeMinutes) (rounded down)");
		  my $jobPerSim = POSIX::ceil($segPerSim / $segPerJob);  
		  $fre->out(FREMsg::NOTE, "jobPerSim ($jobPerSim) = segPerSim ($segPerSim) / segPerJob ($segPerJob) (rounded up)");
		  # ------------------------------------------------------------------------------------------------ create months/days lists
		  my @ma = ($segTime) x $segPerJob;
		  my @da = ('0') x $segPerJob; 
		  my @ha = ('0') x $segPerJob; 
		  # ------------------------------------------------------------------------ calculate the segments number per post-processor call 
		  my $segmentsPerPPCall = 0;
		  if ($simTime >= 12)
		  {
		    if (12 % $segTime == 0)
		    {
        	      $segmentsPerPPCall = 12 / $segTime;
		    }
		    else
		    {
        	      $fre->out(FREMsg::WARNING, "The segment length ($segTime months) is not a divisor of 12 - the postprocessor won't be called");
		    }
		  }
		  else
		  {
		    $fre->out(FREMsg::WARNING, "The production run length ($simTime months) < 1 year - the postprocessor won't be called");
		  }
		  # ------------------------------------------------------------------------------------------ set parameters in the script
		  FRETemplate::setVariable(\$s, 'npes', $np);
		  FRETemplate::setVariable(\$s, 'segmentsPerSimulation', $segPerSim);
		  FRETemplate::setVariable(\$s, 'segmentsPerPPCall', $segmentsPerPPCall);
		  FRETemplate::setVariable(\$s, 'segmentsPerJob', $segPerJob);
		  FRETemplate::setVariable(\$s, 'jobsPerSimulation', $jobPerSim);
		  FRETemplate::setList(\$s, 'monthslist', @ma);
		  FRETemplate::setList(\$s, 'dayslist', @da);
		  FRETemplate::setList(\$s, 'hourslist', @ha);
		  # ----------------------------------------------------------------------------------- set scheduler resources
		  FRETemplate::setSchedulerResources(\$s, $z, 'run', $np, $simRunTime, $p, $q, $f);
		  # ------------------------------------------------------------------------------- normal return
		  return ($s, FREDefaults::STATUS_OK);
		}
		else
		{
		  $fre->out(FREMsg::FATAL, "The segment running time '$segRunTimeMinutes' must not exceed the maximum job running time allowed '$simRunTimeMinutes'");
		  return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
		}
	      }
	      else
	      {
        	$fre->out(FREMsg::FATAL, "Segment running time '$segRunTime' must be nonempty and have the HH:MM:SS format");
		return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	      }
	    }
	    else
	    {
              $fre->out(FREMsg::FATAL, "Simulation running time '$simRunTime' must be nonempty and have the HH:MM:SS format");
	      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	    }
	  }
	  else
	  {
	    $fre->out(FREMsg::FATAL, "The segment time '$segTime' must not exceed the simulation time '$simTime'");
	    return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	  }
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Segment time '$segTime' must be nonempty and have one of (years|year|months|month) units defined");
	  return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Simulation time '$simTime' must be nonempty and have one of (years|year|months|month) units defined");
	return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Number of cores must be a positive integer");
      return (0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM); 
    }      

  }
  
  sub setRegressionDirectories($$$%)
  # ------ arguments: $script $exp $extension %options
  # ------ setups state and output directories and writes them in the script
  # ------ if the state directory exists and the "unique" option is on, then appends a number to the $extension
  # ------ if the state directory exists and the "overwrite" option is on, then removes both directories and recreates the state one
  # ------ return ($script, $extension, $status)
  {

    my ($s, $z, $x, %o) = @_;
    
    my ($fre, $sd, $od, $res) = ($z->fre(), $z->stateDir() . "/$x", $z->archiveDir() . "/$x", '');
    
    if (-d $sd)
    {
      if (-w $sd)
      {
	if ($o{unique})
	{
          {my $i = 1; while (-d "$sd$i") {$i++;} $sd .= $i; $od .= $i; $x .= $i;} 
          $res = FREUtil::createDir("$sd/run");
	}
	elsif ($o{overwrite})
	{
          qx(rm -rf $sd/run $od/ascii $od/restart $od/history);
          $res = FREUtil::createDir("$sd/run");
	}
	elsif (-d "$sd/run")
	{
          $fre->out(FREMsg::FATAL, "The state directory '$sd/run' exists, so you must specify either --overwrite or --unique");
	  return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
	}
	else
	{
          $res = FREUtil::createDir("$sd/run");
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "The state directory '$sd' is not writable");
      }
    }
    else
    {
      $res = FREUtil::createDir("$sd/run");
    }

    if ($res)
    {
      $fre->out(FREMsg::NOTE, "The state directory '$sd/run' has been created successfully");
      FRETemplate::setVariable(\$s, 'stateDir', "$sd/run");
      FRETemplate::setVariable(\$s, 'outputDir', $od);
      return ($s, $x, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to create the state directory '$sd/$x/run'");
      return (0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }

  }

  sub setProductionDirectories($$%)
  # ------ arguments: $script $exp %options
  # ------ setups state and output directories and writes them in the script
  # ------ if the state directory exists and the "unique" option is on, then returns non-empty extension
  # ------ if the state directory exists and the "overwrite" option is on, then removes both directories and recreates the state one
  # ------ return ($script, $extension, $status)
  {

    my ($s, $z, %o) = @_;
    
    my ($fre, $sd, $od, $x, $res) = ($z->fre(), $z->stateDir(), $z->archiveDir(), '', '');
    
    if (-d $sd)
    {
      if (-w $sd)
      {
	if ($o{unique})
	{
          $fre->out(FREMsg::NOTE, "Performing unique production run, no post-processing for this run");
          {my $i = 1; while (-d "$sd/$i") {$i++;} $sd .= "/$i"; $od .= "/$i"; $x = "__$i";}
          $res = FREUtil::createDir("$sd/run");
	}
	elsif ($o{overwrite})
	{
	  qx(rm -rf $sd/run $od/ascii $od/restart $od/history $od/postProcess $od/analysis);
          $res = FREUtil::createDir("$sd/run");
	}
	elsif ($o{extend})
	{
          $res = FREUtil::createDir("$sd/run");
	}
	elsif (-d "$sd/run")
	{
          $fre->out(FREMsg::FATAL, "The state directory '$sd/run' exists, so you must specify --extend, --overwrite or --unique");
	  return (0, 0, FREDefaults::STATUS_FRE_RUN_GENERIC_PROBLEM);
	}
	else
	{
          $res = FREUtil::createDir("$sd/run");
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "The state directory '$sd' is not writable");
      }
    }
    else
    {
      $res = FREUtil::createDir("$sd/run");
    }
    
    
    if ($res)
    {
      $fre->out(FREMsg::NOTE, "The state directory '$sd/run' has been created successfully");
      FRETemplate::setVariable(\$s, 'stateDir', "$sd/run");
      FRETemplate::setVariable(\$s, 'outputDir', $od);
      return ($s, $x, FREDefaults::STATUS_OK);
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to create the state directory '$sd/run'");
      return (0, 0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }
    
  }
  
  sub namelistsAsString($)
  # ------ arguments: $refToNameListsHash
  {
    my $r = shift;
    my $nmlString = '';
    foreach my $key (sort keys %{$r})
    {
      next unless $key;
      my $content = $r->{$key};
      $nmlString .= '<namelist name="' . $key . '">' . "\n";
      $nmlString .= $content . "\n";
      $nmlString .= '</namelist>' . "\n";
    }
    return $nmlString;
  }
  
  sub checkNamelists($$)
  # ------ arguments: $exp $refToNameListsHash
  {
    my ($z, $r) = @_;
    my $fre = $z->fre();
    my $targetListRepro = FRETargets::containsRepro($fre->target());
    if ($r->{xgrid_nml})
    {
      my @xgridNml = split(/\n/, $r->{xgrid_nml});
      my $nmlRepro = (scalar(grep($_ =~ /make_exchange_reproduce.+true/i, @xgridNml)) > 0);
      if ($nmlRepro and !$targetListRepro)
      {
        $fre->out(FREMsg::WARNING, "The 'make_exchange_reproduce' is .TRUE. in the 'xgrid_nml' namelist, which contradicts with absence of 'repro' in your targets");
      }
      elsif (!$nmlRepro and $targetListRepro)
      {
        $fre->out(FREMsg::WARNING, "The 'make_exchange_reproduce' is absent or isn't .TRUE. in the 'xgrid_nml' namelist, which contradicts with 'repro' in your targets");
      }
    }
    elsif ($targetListRepro)
    {
      $fre->out(FREMsg::WARNING, "The 'xgrid_nml' namelist isn't found, which contradicts with 'repro' in your targets");
    }
  }
  
  sub extractOverrideParams($$$)
  # ------ arguments: $exp $runNode $refToNamelistsHash 
  {

    my ($z, $n, $r) = @_;
    my $fre = $z->fre();

    my $res = $z->nodeValue($n, '@overrideParams');
    $res .= ';' if ($res and $res !~ /.*;$/);

    my $atmos_layout = $z->nodeValue($n, '@atmos_layout');
    if ($atmos_layout)
    {
      $res .= "bgrid_core_driver_nml:layout=$atmos_layout;" if $r->{bgrid_core_driver_nml};
      $res .= "fv_core_nml:layout=$atmos_layout;" if $r->{fv_core_nml};
      $fre->out
      (
        FREMsg::WARNING,
	"Usage of 'atmos_layout' is deprecated; instead, use",
	"<run overrideParams=\"fv_core_nml:layout=$atmos_layout\" ...>",
	"or <run overrideParams=\"bgrid_core_driver_nml:layout=$atmos_layout\" ...>"
      );
    }

    my $zetac_layout = $z->nodeValue($n, '@zetac_layout');
    if ($zetac_layout)
    {
      $res .= "zetac_layout_nml:layout=$zetac_layout;";
      $fre->out
      (
        FREMsg::WARNING,
	"Usage of 'zetac_layout' is deprecated; instead, use",
	"<run overrideParams=\"zetac_layout_nml:layout=$zetac_layout;namelist:var=val;...\" ...>"
      );
    }

    my $ice_layout = $z->nodeValue($n, '@ice_layout');
    if ($ice_layout)
    {
      $res .= "ice_model_nml:layout=$ice_layout;";
      $fre->out
      (
        FREMsg::WARNING,
	"Usage of 'ice_layout' is deprecated; instead, use",
	"<run overrideParams=\"ice_model_nml:layout=$ice_layout;namelist:var=val;...\" ...>"
      );
    }

    my $ocean_layout = $z->nodeValue($n, '@ocean_layout');
    if ($ocean_layout)
    {
      $res .= "ocean_model_nml:layout=$ocean_layout;";
      $fre->out
      (
        FREMsg::WARNING,
	"Usage of 'ocean_layout' is deprecated; instead, use",
	"<run overrideParams=\"ocean_model_nml:layout=$ocean_layout;namelist:var=val;...\" ...>"
      );
    }

    my $land_layout = $z->nodeValue($n, '@land_layout');
    if ($land_layout)
    {
      $res .= "land_model_nml:layout=$land_layout;";
      $fre->out
      (
        FREMsg::WARNING,
	"Usage of 'land_layout' is deprecated; instead, use",
	"<run overrideParams=\"land_model_nml:layout=$land_layout;namelist:var=val;...\" ...>"
      );
    }
    
    return $res;

  }

  sub overrideRegressionNamelists($$%)
  # ------ arguments: $exp $runNode %namelistsHash
  # ------ return overridden namelists hash
  {

    my ($z, $n, %l) = @_;
    my $fre = $z->fre();
    
    my $nmlOverrides = frerun::extractOverrideParams($z, $n, \%l);
    my @nmls = split(/;/, $nmlOverrides);

    foreach my $nml (@nmls)
    {

      my ($namelist, $var, $val) = split(/[:=]/, $nml);
      $namelist =~ s/\s*//g;
      $var =~ s/\s*//g;
      unless ($namelist and $var) {$fre->out(FREMsg::WARNING, "Got an empty namelist in overrideParams"); next;}

      $fre->out(FREMsg::NOTE, "overrideParams from xml: $namelist:$var=$val");

      if ($l{$namelist})
      {
        $fre->out(FREMsg::NOTE, "original namelist:  $namelist\n$l{$namelist}");
        if ($l{$namelist} =~ /\b($var\s*=\s*)(\S.*)(([,\n]\s*\w+\s*=\s*.*)*)/i)
	{
          $l{$namelist} =~ s/\b($var\s*=\s*)(\S.*)(([,\n]\s*\w+\s*=\s*.*)*)/$1$val$3/i;
        }
	else
	{
          $l{$namelist} =~ s/^(\s*)/$1$var = $val,\n$1/;
        }
      }
      else
      {
        $l{$namelist} = "	$var = $val";
      }

      $fre->out(FREMsg::NOTE, "overridden namelist: $namelist\n$l{$namelist}");

    }

    frerun::checkNamelists($z, \%l);

    return %l;

  }

  sub overrideProductionNamelists($%)
  # ------ arguments: $exp %namelistsHash
  # ------ return overridden namelists hash
  {

    my ($z, %l) = @_;

    my $setLayout = sub($$)
    {
      my ($n, $v) = @_;
      if ($l{$n})
      {
	if ($l{$n} =~ /\b(layout\s*=\s*)(\d+|\$\w+)\s*,\s*(\d+|\$\w+)\b(.*)/i)
	{
          $l{$n} =~ s/\b(layout\s*=\s*)(\d+|\$\w+)\s*,\s*(\d+|\$\w+)\b(.*)/$1$v$4/i;
	}
	else
	{ 
          $l{$n} =~ s/^(\s*)/$1layout = $v,\n$1/;
	}
      }
      else
      {
	$l{$n} = "	layout = $v";
      }
    };

    my $atmos_layout = $z->extractValue('runtime/production/peLayout/@atmos');
    $setLayout->('bgrid_core_driver_nml', $atmos_layout) if $atmos_layout;
    $setLayout->('fv_core_nml', $atmos_layout) if $atmos_layout;

    my $zetac_layout = $z->extractValue('runtime/production/peLayout/@zetac');
    $setLayout->('zetac_layout_nml', $zetac_layout) if $zetac_layout;

    my $ice_layout = $z->extractValue('runtime/production/peLayout/@ice');
    $setLayout->('ice_model_nml', $ice_layout) if $ice_layout;

    my $ocean_layout = $z->extractValue('runtime/production/peLayout/@ocean');
    $setLayout->('ocean_model_nml', $ocean_layout) if $ocean_layout;

    my $land_layout = $z->extractValue('runtime/production/peLayout/@land');
    $setLayout->('land_model_nml', $land_layout) if $land_layout;

    frerun::checkNamelists($z, \%l);

    return %l;

  }

  sub setRegressionTimeStampOptions($$$$)
  # ------ arguments: $refToScript $exp $runNode $refToNamelistsHash
  # ------ update timestamp options
  {
    my ($r, $z, $n, $l) = @_;
    my $calendarType = frerun::calendarType($l);
    my $timeStampOptions = ($calendarType eq 'no_calendar') ? '-f days' : (($z->nodeValue($n, '@hours')) ? '-hf digital' : '-f digital');
    FRETemplate::setList($r, 'timeStampOptions', $timeStampOptions);
  }

  sub setProductionTimeStampOptions($$)
  # ------ arguments: $refToScript $refToNamelistsHash
  # ------ update timestamp options
  {
    my ($r, $l) = @_;
    my $calendarType = frerun::calendarType($l);
    my $timeStampOptions = ($calendarType eq 'no_calendar') ? '-f days' : '-f digital';
    FRETemplate::setList($r, 'timeStampOptions', $timeStampOptions);
  }

  sub setNamelists($$)
  # ------ arguments: $refToScript $refToNamelistsHash
  # ------ update namelists
  {
    my ($r, $l) = @_;
    my $nmlString = "cat > input.nml.unexpanded <<\\EOF\n";
    foreach my $key (sort keys %{$l})
    {
      next unless $key;
      my $content = $l->{$key};
      $nmlString .= " \&$key\n$content\n\/\n\n";
    }
    $nmlString .= "\\EOF\n";
    ${$r} =~ s/#namelists_from_xml/$nmlString/;
  }

  sub setMPI($$$%)
  # ------ arguments: $refToScript $exp $runNode %options
  # ------ update MPI call
  {
    my ($r, $z, $n, %o) = @_;
    my $fre = $z->fre();
    my $runCommand = $fre->property('FRE.mpi.runCommand.default');
    $fre->out(FREMsg::NOTE, "Running executable with:", $runCommand);
    FRETemplate::setAlias($r, 'runCommand', $runCommand);
  }
  
  sub outputScriptJobId($$)
  # ------ arguments: $fre $string
  # ------ return $jobId
  {
    my ($fre, $s, $j) = @_;
    my $submitOutputPattern = $fre->property('FRE.scheduler.submit.output.pattern');
    return ($s =~ m/$submitOutputPattern/m) ? $1 : '';
  }
  
  sub outputScriptStartTime($)
  # ------ arguments: $fre
  # ------ return start time option (for dual run)
  {
    my $fre = shift;
    if (my $delay = $fre->property('FRE.scheduler.dual.delay'))
    {
      my $dateTime = Date::Manip::UnixDate(Date::Manip::DateCalc('now', "+$delay"), '%Y%m%d%H%M');
      return $fre->propertyParameterized('FRE.scheduler.option.startTime', $dateTime);
    }
    else
    {
      return '';
    }
  }
  
  sub outputScriptExecuteOrSubmit($$$$%)
  # ------ arguments: $script $exp $scriptAbsName $stdoutAbsName %options
  # ------ write $script to the $scriptAbsName file, chmod, and optionally execute or submit
  # ------ return ($script, $status)
  {
    my ($s, $z, $n, $o, %o) = @_;
    my $fre = $z->fre();
    my ($stdoutMainDir, $stdoutTmpDir) = (frerun::stdoutMainDir($z), File::Basename::dirname($o));
    if (frerun::createDirectory($fre, $stdoutMainDir))
    {
      if (frerun::createDirectory($fre, $stdoutTmpDir))
      {
	my $scriptsDir = File::Basename::dirname($n);
	if (frerun::createDirectory($fre, $scriptsDir))
	{
	  if (open my $scriptHandle, '>', $n)
	  {
	    print {$scriptHandle} $s;
	    close $scriptHandle;
	    if (chmod 0755, $n)
	    {
	      if ($o{execute})
	      {
		my $res = system("$n 2>&1 | tee $o");
		if ($res == 0)
		{
		  return ($s, FREDefaults::STATUS_OK);
		}
		else
		{
        	  $fre->out(FREMsg::FATAL, "The runscript '$n' failed! ($res)", "Please see the logfile '$o'...");
		  return (0, FREDefaults::STATUS_FRE_RUN_EXECUTION_PROBLEM);
		}
	      }
	      elsif ($o{submit}) 
	      {
		if ($fre->property('FRE.scheduler.enabled'))
		{
		  my $submitCommand = $fre->property('FRE.scheduler.submit.command');
		  $submitCommand .= ' ' . frerun::outputScriptStartTime($fre) if $o{dual};
		  $submitCommand .= ' ' . $n;
		  $fre->out(FREMsg::NOTE, "Executing '$submitCommand'...");
		  my $currentDir = Cwd::getcwd();
		  if (chdir $stdoutTmpDir)
		  {
		    print qx($submitCommand);
		    chdir $currentDir;
	            return ($s, FREDefaults::STATUS_OK);
		  }
		  else
		  {
		    $fre->out(FREMsg::FATAL, "Unable to switch to the stdout directory '$stdoutTmpDir'");
		    return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
		  }
        	}
		else
		{
                  $fre->out(FREMsg::WARNING, "The runscript '$n' can't be submitted as a batch job on this site");
	          return ($s, FREDefaults::STATUS_OK);
		}
	      }
	      elsif ($o{'submit-chained'})
	      {
		if ($fre->property('FRE.scheduler.enabled'))
		{
 	          my ($submitChainCommand, $scriptBasename) = ($fre->property('FRE.scheduler.submit.command'), File::Basename::basename($n));
		  $submitChainCommand .= ' ' . FRETemplate::schedulerResourcesAsString($z, 'inputStager', $o{ncores}, $o{walltime} * 60, undef, undef, undef);
		  $submitChainCommand .= ' ' . FRETemplate::schedulerNamesAsString($z, "$scriptBasename.input.stager", $stdoutMainDir);
		  $submitChainCommand .= ' ' . frerun::outputScriptStartTime($fre) if $o{dual};
		  $submitChainCommand .= ' ' . '-v FRE_STAGE=CHAIN';
		  $submitChainCommand .= ' ' .  $n;
		  $fre->out(FREMsg::NOTE, "Executing '$submitChainCommand'...");
		  my $currentDir = Cwd::getcwd();
		  if (chdir $stdoutTmpDir)
		  {
		    print qx($submitChainCommand);
		    chdir $currentDir;
	            return ($s, FREDefaults::STATUS_OK);
		  }
		  else
		  {
		    $fre->out(FREMsg::FATAL, "Unable to switch to the stdout directory '$stdoutTmpDir'");
		    return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
		  }
        	}
		else
		{
                  $fre->out(FREMsg::WARNING, "The runscript '$n' can't be submitted as a batch job on this site");
	          return ($s, FREDefaults::STATUS_OK);
		}
	      }
	      elsif ($o{'submit-staged'})
	      {
		if ($fre->property('FRE.scheduler.enabled'))
		{
 	          my ($submitInputCommand, $scriptBasename) = ($fre->property('FRE.scheduler.submit.command'), File::Basename::basename($n));
		  $submitInputCommand .= ' ' . FRETemplate::schedulerResourcesAsString($z, 'inputStager', $o{ncores}, $o{walltime} * 60, undef, undef, undef);
		  $submitInputCommand .= ' ' . FRETemplate::schedulerNamesAsString($z, "$scriptBasename.input.stager", $stdoutMainDir);
		  $submitInputCommand .= ' ' . frerun::outputScriptStartTime($fre) if $o{dual};
		  $submitInputCommand .= ' ' . '-v FRE_STAGE=INPUT';
		  $submitInputCommand .= ' ' .  $n;
		  $fre->out(FREMsg::NOTE, "Executing '$submitInputCommand'...");
		  my $currentDir = Cwd::getcwd();
		  if (chdir $stdoutTmpDir)
		  {
		    my $submitInputMsg = qx($submitInputCommand);
		    print split(/\n/, $submitInputMsg), "\n";
		    my $jobId = frerun::outputScriptJobId($fre, $submitInputMsg);
		    if ($jobId)
		    {
		      my $submitRunCommand = $fre->property('FRE.scheduler.submit.command');
		      $submitRunCommand .= ' ' . $fre->propertyParameterized('FRE.scheduler.option.dependsOn', $jobId);
		      $submitRunCommand .= ' ' . $n;
		      $fre->out(FREMsg::NOTE, "Executing '$submitRunCommand'...");
		      print qx($submitRunCommand);
		      chdir $currentDir;
		      return ($s, FREDefaults::STATUS_OK);
		    }
		    else
		    {
		      $fre->out(FREMsg::FATAL, "Unable to submit the input data staging job for '$scriptBasename'");
		      chdir $currentDir;
		      return ($s, FREDefaults::STATUS_FRE_RUN_EXECUTION_PROBLEM);
		    }
		  }
		  else
		  {
		    $fre->out(FREMsg::FATAL, "Unable to switch to the stdout directory '$stdoutTmpDir'");
		    return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
		  }
        	}
		else
		{
                  $fre->out(FREMsg::WARNING, "The runscript '$n' can't be submitted as a batch job on this site");
	          return ($s, FREDefaults::STATUS_OK);
		}
	      }
	      else
	      {
		if ($fre->property('FRE.scheduler.enabled'))
		{
	          my $submit = $fre->property('FRE.scheduler.submit.command');
	          print "TO SUBMIT => $submit $n\n";
	          return ($s, FREDefaults::STATUS_OK);
		}
		else
		{
                  print "The runscript '$n' is ready\n";
	          return ($s, FREDefaults::STATUS_OK);
		}
	      }
	    }
	    else
	    {
              $fre->out(FREMsg::FATAL, "Unable to change the script '$n' permissions");
	      return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	    }
	  }
	  else
	  {
	    $fre->out(FREMsg::FATAL, "Unable to save the script '$n'");
	    return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	  }
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to create scripts directory '$scriptsDir'");
	  return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
	}
      }
      else
      {
	$fre->out(FREMsg::FATAL, "Unable to create temporary stdout directory '$stdoutTmpDir'");
	return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to create main stdout directory '$stdoutMainDir'");
      return (0, FREDefaults::STATUS_FS_GENERIC_PROBLEM);
    }
  }
  
  sub processRegressionRun($$$$%)
  # ------ arguments: $script $exp $refToNamelists $runNode %options
  {
    my ($s, $z, $r, $n, %o) = @_;
    my ($rtScript, $extension, $status) = frerun::setRegressionParameters($s, $z, $n, $o{partition}, $o{queue}, $o{'dual'});
    if ($rtScript)
    {
      ($rtScript, $extension, $status) = frerun::setRegressionDirectories($rtScript, $z, $extension, %o);
      if ($rtScript)
      {
	my %nmlOverridden = frerun::overrideRegressionNamelists($z, $n, %{$r});
	frerun::setRegressionTimeStampOptions(\$rtScript, $z, $n, \%nmlOverridden);
        frerun::setNamelists(\$rtScript, \%nmlOverridden);
	frerun::setMPI(\$rtScript, $z, $n, %o);
	my $scriptName = frerun::regressionRunScriptName($z, $extension);
        my $stdoutName = frerun::stdoutName($z, $scriptName);
	my $stdoutTmpDir = File::Basename::dirname($stdoutName);
        FRETemplate::setVariable(\$rtScript, 'scriptName', $scriptName);
        FRETemplate::setVariable(\$rtScript, 'stdoutTmpDir', $stdoutTmpDir);
        FRETemplate::setSchedulerNames(\$rtScript, $z, File::Basename::basename($scriptName), $stdoutTmpDir);
        return frerun::outputScriptExecuteOrSubmit($rtScript, $z, $scriptName, $stdoutName, %o);
      }
      else
      {
	return (0, $status);
      }
    }
    else
    {
      return (0, $status);
    }
  }
  
  sub processRegression($$$%)
  # ------ arguments: $exp $refToNamelists $label %options
  {
    my ($z, $r, $l, %o) = @_;
    my ($expName, $fre, %nml) = ($z->name(), $z->fre(), %{$r});
    $fre->out(FREMsg::NOTE, "Creating runscripts for the regression test '$l'...");
    my ($runScript, $status) = frerun::init($z, %o);
    if ($runScript)
    {
      ($runScript, $status) = frerun::setInputDatasets($runScript, $z);
      if ($runScript)
      {
	($runScript, $status) = frerun::setTables($runScript, $z, $nml{coupler_nml});
	if ($runScript)
	{
	  frerun::setInputInitialConditions(\$runScript, $z);
	  frerun::setInputGridSpecification(\$runScript, $z);
 	  frerun::setShellCommands(\$runScript, $z);
	  FRETemplate::setVersionInfo(\$runScript, $z, $0, %o);	    
	  FRETemplate::setSchedulerAccount(\$runScript, $z, $o{windfall});
	  my $x = 'regression[@label="' . $l . '" or @name="' . $l . '"]';
	  my @regNodes = $z->extractNodes('runtime', $x);
	  if (scalar(@regNodes) == 1)
	  {
	    my @runNodes = $z->extractNodes('runtime/' . $x, 'run');
	    if (scalar(@runNodes) > 1)
	    {
	      for (my $i = 0; $i < scalar(@runNodes); $i++)
	      {
                $fre->out(FREMsg::NOTE, "Creating a runscript #$i for the regression test '$l'...");
	        (my $rc, $status) = frerun::processRegressionRun($runScript, $z, $r, $runNodes[$i], %o);
		if ($rc)
		{
	          $fre->out(FREMsg::NOTE, "A runscript #$i for the regression test '$l' in the experiment '$expName' has been created successfully");
		}
		else
		{
                  $fre->out(FREMsg::FATAL, "Unable to create a runscript #$i for the regression test '$l' in the experiment '$expName'");
		  return (0, $status);
		}
              }
	      return (1, FREDefaults::STATUS_OK);
	    }
	    elsif (scalar(@runNodes) == 1)
	    {
	      (my $rc, $status) = frerun::processRegressionRun($runScript, $z, $r, $runNodes[0], %o);
	      if ($rc)
	      {
	        $fre->out(FREMsg::NOTE, "A runscript for the regression test '$l' in the experiment '$expName' has been created successfully");
		return (1, FREDefaults::STATUS_OK);
	      }
	      else
	      {
                $fre->out(FREMsg::FATAL, "Unable to create a runscript for the regression test '$l' in the experiment '$expName'");
		return (0, $status);
	      }
	    }
	    else
	    {
	      $fre->out(FREMsg::FATAL, "The regression test '$l' doesn't have any runs in the experiment '$expName'");
	      return (0, FREDefaults::STATUS_FRE_GENERIC_PROBLEM);
	    }
	  }
	  else
	  {
	    $fre->out(FREMsg::FATAL, "The regression test '$l' doesn't exist or defined more than once in the experiment '$expName'");
	    return (0, FREDefaults::STATUS_FRE_GENERIC_PROBLEM);
	  }
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to setup tables for the experiment '$expName'");
	  return (0, $status);
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Unable to setup input data for the experiment '$expName'");
	return (0, $status);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to initialize the experiment '$expName'");
      return (0, $status);
    }
  }
  
  sub processRegressionSuite($$%)
  # ------ arguments: $exp $refToNamelists %options 
  {
    my ($z, $r, %o) = @_;
    my ($expName, $fre, %nml) = ($z->name(), $z->fre(), %{$r});
    $fre->out(FREMsg::NOTE, "Creating runscripts for the regression tests suite...");
    my ($runScript, $status) = frerun::init($z, %o);
    if ($runScript)
    {
      ($runScript, $status) = frerun::setInputDatasets($runScript, $z);
      if ($runScript)
      {
	($runScript, $status) = frerun::setTables($runScript, $z, $nml{coupler_nml});
	if ($runScript)
	{
	  frerun::setInputInitialConditions(\$runScript, $z);
	  frerun::setInputGridSpecification(\$runScript, $z);
 	  frerun::setShellCommands(\$runScript, $z);
	  FRETemplate::setVersionInfo(\$runScript, $z, $0, %o);	    
	  FRETemplate::setSchedulerAccount(\$runScript, $z, $o{windfall});
	  foreach my $regLabel (frerun::REGRESSION_SUITE)
	  {
            $fre->out(FREMsg::NOTE, "Creating runscripts for the regression test '$regLabel'...");
	    my $x = 'regression[@label="' . $regLabel . '" or @name="' . $regLabel . '"]';
	    my @regNodes = $z->extractNodes('runtime', $x);
	    if (scalar(@regNodes) == 1)
	    {
	      my @runNodes = $z->extractNodes('runtime/' . $x, 'run');
	      if (scalar(@runNodes) > 1)
	      {
		for (my $i = 0; $i < scalar(@runNodes); $i++)
		{
                  $fre->out(FREMsg::NOTE, "Creating a runscript #$i for the regression test '$regLabel'...");
	          (my $rc, $status) = frerun::processRegressionRun($runScript, $z, $r, $runNodes[$i], %o);
		  if ($rc)
		  {
	            $fre->out(FREMsg::NOTE, "A runscript #$i for the regression test '$regLabel' in the experiment '$expName' has been created successfully");
		  }
		  else
		  {
                    $fre->out(FREMsg::FATAL, "Unable to create a runscript #$i for the regression test '$regLabel' in the experiment '$expName'");
		    return (0, $status);
		  }
        	}
	      }
	      elsif (scalar(@runNodes) == 1)
	      {
	        (my $rc, $status) = frerun::processRegressionRun($runScript, $z, $r, $runNodes[0], %o);
		if ($rc)
		{
	          $fre->out(FREMsg::NOTE, "A runscript for the regression test '$regLabel' in the experiment '$expName' has been created successfully");
		}
		else
		{
                  $fre->out(FREMsg::FATAL, "Unable to create a runscript for the regression test '$regLabel' in the experiment '$expName'");
		  return (0, $status);
		}
	      }
	      else
	      {
		$fre->out(FREMsg::WARNING, "The suite is incomplete - the regression test '$regLabel' doesn't have any runs in the experiment '$expName'");
	      }
	    }
	    else
	    {
	      $fre->out(FREMsg::WARNING, "The suite is incomplete - the regression test '$regLabel' doesn't exist or defined more than once in the experiment '$expName'");
	    }
	  }
	  return (1, FREDefaults::STATUS_OK);
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to setup tables for the experiment '$expName'");
	  return (0, $status);
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Unable to setup input data for the experiment '$expName'");
	return (0, $status);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to initialize the experiment '$expName'");
      return (0, $status);
    }
  }
  
  sub processProduction($$%)
  # ------ arguments: $exp $refToNamelists %options 
  {
    my ($z, $r, %o) = @_;
    my ($expName, $fre, %nml) = ($z->name(), $z->fre(), %{$r});
    $fre->out(FREMsg::NOTE, "Creating a runcript for the experiment '$expName'...");
    my ($runScript, $status) = frerun::init($z, %o);
    if ($runScript)
    {
      ($runScript, $status) = frerun::setInputDatasets($runScript, $z);
      if ($runScript)
      {
	($runScript, $status) = frerun::setTables($runScript, $z, $nml{coupler_nml});
	if ($runScript)
	{
	  frerun::setInputInitialConditions(\$runScript, $z);
	  frerun::setInputGridSpecification(\$runScript, $z);
 	  frerun::setShellCommands(\$runScript, $z);
	  FRETemplate::setVersionInfo(\$runScript, $z, $0, %o);	    
	  FRETemplate::setSchedulerAccount(\$runScript, $z, $o{windfall});
	  ($runScript, $status) = frerun::setProductionParameters($runScript, $z, $o{partition}, $o{queue}, $o{'dual'});
	  if ($runScript)
	  {
	    ($runScript, my $extension, $status) = frerun::setProductionDirectories($runScript, $z, %o);
	    if ($runScript)
	    {
	      my %nmlOverridden = frerun::overrideProductionNamelists($z, %nml);
	      frerun::setProductionTimeStampOptions(\$runScript, \%nmlOverridden);
	      frerun::setNamelists(\$runScript, \%nmlOverridden);
	      frerun::setMPI(\$runScript, $z, '', %o);
	      my $scriptName = frerun::productionRunScriptName($z, $extension);
              my $stdoutName = frerun::stdoutName($z, $scriptName);
	      my $stdoutTmpDir = File::Basename::dirname($stdoutName);
              FRETemplate::setVariable(\$runScript, 'scriptName', $scriptName);
	      FRETemplate::setVariable(\$runScript, 'stdoutTmpDir', $stdoutTmpDir);
              FRETemplate::setSchedulerNames(\$runScript, $z, File::Basename::basename($scriptName), $stdoutTmpDir);
              ($runScript, $status) = frerun::outputScriptExecuteOrSubmit($runScript, $z, $scriptName, $stdoutName, %o);
	      if ($runScript)
	      {
		return (1, FREDefaults::STATUS_OK);
	      }
	      else
	      {
		$fre->out(FREMsg::FATAL, "Unable to create (or run) a runscript for the experiment '$expName'");
		return (0, $status);
	      }
	    }
	    else
	    {
	      $fre->out(FREMsg::FATAL, "Unable to setup output directories for the experiment '$expName'");
	      return (0, $status);
	    }
	  }
	  else
	  {
	    $fre->out(FREMsg::FATAL, "Unable to setup timing parameters for the experiment '$expName'");
	    return (0, $status);
	  }
	}
	else
	{
          $fre->out(FREMsg::FATAL, "Unable to setup tables for the experiment '$expName'");
	  return (0, $status);
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Unable to setup input data for the experiment '$expName'");
	return (0, $status);
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to initialize the experiment '$expName'");
      return (0, $status);
    }
  }

  sub skipExp($)
  # ------ arguments: $exp 
  {
    my $z = shift;
    my ($expName, $fre) = ($z->name(), $z->fre());
    $fre->out(FREMsg::FATAL, "Skipping the experiment '$expName'...");
  }

}

# //////////////////////////////////////////////////////////////////////////////
# ////////////////////////////////////////////////////////////////////// Main //
# //////////////////////////////////////////////////////////////////////////////

{

  my %opt =
  (
    'archive'		=> 1,
    'combine-history'	=> 1,
    'platform'		=> FREDefaults::Platform(),
    'target'		=> FREDefaults::Target(),
    'xmlfile'		=> FREDefaults::XMLFile()
  );

  Getopt::Long::GetOptions(\%opt, frerun::OPTLIST) or (print frerun::Usage() and exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM);
  if ($opt{version}) {print frerun::VERSION,"\n" and exit FREDefaults::STATUS_OK;}
  if ($opt{help}) {print frerun::Help() and exit FREDefaults::STATUS_OK;}
  
  unless (scalar(@ARGV) > 0)
  {
    my $self = File::Basename::basename($0);
    FREMsg::out($opt{verbose}, FREMsg::FATAL, "At least one experiment name is needed on the command line", "Try '$self --help' for more information");
    exit FREDefaults::STATUS_COMMAND_NO_EXPERIMENTS;
  }

  unless ($opt{extend} + $opt{overwrite} + $opt{unique} <= 1)
  {
    FREMsg::out($opt{verbose}, FREMsg::FATAL, "Options --extend, --overwrite and --unique are mutually exclusive - only one of them can be present");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }
  
  unless ($opt{submit} + $opt{'submit-chained'} + $opt{'submit-staged'} <= 1)
  {
    FREMsg::out($opt{verbose}, FREMsg::FATAL, "Options --submit, --submit-chained and --submit-staged are mutually exclusive - only one of them can be present");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }
  
  if (exists($opt{compress}))
  {
    ($opt{compress}, my @messages) = FREUtil::optionValuesListParse('compress', $opt{compress}, frerun::OUTPUT_COMPRESSION_TYPES);
    unless (scalar(@messages) == 0)
    {
      FREMsg::out($opt{verbose}, FREMsg::FATAL, @messages);
      exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }
  }
  
  if (exists($opt{regression}))
  {
    unless ($opt{regression} && substr($opt{regression}, 0, 1) ne '-')
    {
      FREMsg::out($opt{verbose}, FREMsg::FATAL, "The --regression option's value is missing");
      exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }
  }
  
  if (exists($opt{'remote-user'}))
  {
    unless ($opt{'remote-user'} && substr($opt{'remote-user'}, 0, 1) ne '-')
    {
      FREMsg::out($opt{verbose}, FREMsg::FATAL, "The --remote-user option's value is missing");
      exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }
  }
  
  if (exists($opt{platform}))
  {
    unless ($opt{platform} && substr($opt{platform}, 0, 1) ne '-')
    {
      FREMsg::out($opt{verbose}, FREMsg::FATAL, "The --platform option's value is missing");
      exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }
  }
  
  if (exists($opt{target}))
  {
    unless ($opt{target} && substr($opt{target}, 0, 1) ne '-')
    {
      FREMsg::out($opt{verbose}, FREMsg::FATAL, "The --target option's value is missing");
      exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }
  }
  
  if (exists($opt{xmlfile}))
  {
    unless ($opt{xmlfile} && substr($opt{xmlfile}, 0, 1) ne '-')
    {
      FREMsg::out($opt{verbose}, FREMsg::FATAL, "The --xmlfile option's value is missing");
      exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
    }
  }
  
  if ($opt{check} and !$opt{unique})
  {
    FREMsg::out($opt{verbose}, FREMsg::WARNING, "Option --check is allowed only when the option --unique is present, the --check option is ignored");
    delete $opt{check};
  }

  if ($opt{dual} and $opt{regression})
  {
    FREMsg::out($opt{verbose}, FREMsg::WARNING, "Options --dual and --regression are incompatible, the --dual option is ignored");
    delete $opt{dual};
  }
  
  if ($opt{dual} and $opt{unique})
  {
    FREMsg::out($opt{verbose}, FREMsg::WARNING, "Options --dual and --unique are incompatible, the --dual option is ignored");
    delete $opt{dual};
  }
  
  my $fre = FRE->new('frerun', %opt) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
  
  unless ($fre->property('FRE.tool.frerun.enabled'))
  {
    my $platformSite = $fre->platformSite();
    $fre->out(FREMsg::FATAL, "You are not supposed to call this tool on the '$platformSite' site");
    exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
  }
  
  if (scalar(my @types = split(/;/, $fre->property('FRE.output.staging'))) > 0)
  {
    my $typeDefault = $types[0];
    if (exists($opt{'output-staging'}))
    {
      if ($opt{'output-staging'} && substr($opt{'output-staging'}, 0, 1) ne '-')
      {
        if (scalar(grep($_ eq $opt{'output-staging'}, @types)) > 0)
	{
	  $fre->out(FREMsg::NOTE, "The '$opt{'output-staging'}' output staging type will be used");
	}
	elsif (scalar(@types) > 1)
	{
	  my $types = join("', '", @types);
	  $fre->out(FREMsg::FATAL, "The '$opt{'output-staging'}' output staging type isn't allowed", "Allowed types are '$types', the default one is '$typeDefault'");
	  exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The '$opt{'output-staging'}' output staging type isn't allowed", "Allowed type is '$typeDefault' only");
	  exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "The --output-staging option's value is missing");
        exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
      }
    }
  }
  else
  {
    $fre->out(FREMsg::FATAL, "The FRE output staging is configured incorrectly");
    exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
  }
  
  if (scalar(my @partitions = split(/;/, $fre->property('FRE.scheduler.partitions'))) > 0)
  {
    my $partitionDefault = $partitions[0];
    if (exists($opt{partition}))
    {
      if ($opt{partition} && substr($opt{partition}, 0, 1) ne '-')
      {
	if (scalar(grep($_ eq $opt{partition}, @partitions)) > 0)
	{
	  $fre->out(FREMsg::NOTE, "The '$opt{partition}' partition will be used");
	}
	elsif (scalar(@partitions) > 1)
	{
	  my $partitions = join("', '", @partitions);
	  $fre->out(FREMsg::FATAL, "The '$opt{partition}' partition isn't allowed", "Allowed partitions are '$partitions', the default one is '$partitionDefault'");
	  exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The '$opt{partition}' partition isn't allowed", "Allowed partition is '$partitionDefault' only");
	  exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
	}
      }
      else
      {
	$fre->out(FREMsg::FATAL, "The --partition option's value is missing");
	exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
      }
    }
    else
    {
      $fre->out(FREMsg::WARNING, "Option --partition=$partitionDefault has been automatically added");
      %opt = (%opt, 'partition' => $partitionDefault);
    }
  }
  elsif (exists($opt{partition}))
  {
    $fre->out(FREMsg::FATAL, "Option --partition is not supported on this site");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }

  if (scalar(my @queues = split(/;/, ($opt{partition}) ? $fre->property("FRE.scheduler.$opt{partition}.queues") : $fre->property("FRE.scheduler.queues"))) > 0)
  {
    my $queueDefault = $queues[0];
    if (exists($opt{queue}))
    {
      if ($opt{queue} && substr($opt{queue}, 0, 1) ne '-')
      {
	if (scalar(grep($_ eq $opt{queue}, @queues)) > 0)
	{
	  $fre->out(FREMsg::NOTE, "The queue '$opt{queue}' will be used");
	}
	elsif (scalar(@queues) > 1)
	{
	  my $queues = join("', '", @queues);
	  $fre->out(FREMsg::FATAL, "The '$opt{queue}' queue isn't allowed", "Allowed queues are '$queues', the default one is '$queueDefault'");
	  exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "The '$opt{queue}' queue isn't allowed", "Allowed queue is '$queueDefault' only");
	  exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
	}
      }
      else
      {
	$fre->out(FREMsg::FATAL, "The --queue option's value is missing");
	exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
      }
    }
    else
    {
      $fre->out(FREMsg::WARNING, "Option --queue=$queueDefault has been automatically added");
      %opt = (%opt, 'queue' => $queueDefault);
    }
  }
  elsif (exists($opt{queue}))
  {
    $fre->out(FREMsg::FATAL, "Option --queue is not supported on this site");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }

  if ($opt{windfall} and !$fre->property('FRE.scheduler.windfall.enabled'))
  {
    $fre->out(FREMsg::FATAL, "Option --windfall is not supported on this site");
    exit FREDefaults::STATUS_COMMAND_GENERIC_PROBLEM;
  }
  
  if (!exists($opt{dual}) and !$opt{regression} and !$opt{unique} and $fre->property('FRE.option.dual.default'))
  {
    $fre->out(FREMsg::WARNING, "Option --dual has been automatically added");
    %opt = (%opt, 'dual' => 1);
  }

  if ($opt{transfer} and !$opt{archive})
  {
    $fre->out(FREMsg::WARNING, "Option --transfer is not allowed when the option --noarchive is present, the --transfer option is ignored");
    delete $opt{transfer};
  }
  elsif ($opt{transfer} and $opt{check})
  {
    $fre->out(FREMsg::WARNING, "Option --transfer is not allowed when the option --check is present, the --transfer option is ignored");
    delete $opt{transfer};
  }
  elsif ($opt{transfer} and scalar(split(/;/, $fre->property('FRE.output.staging'))) > 1 and $opt{'output-staging'} eq 'online')
  {  
    $fre->out(FREMsg::WARNING, "Option --transfer is not allowed when the option --output-staging=online is present, the --transfer option is ignored");
    delete $opt{transfer};
  }
  elsif (!exists($opt{transfer}) and $opt{archive} and !$opt{check} and (scalar(split(/;/, $fre->property('FRE.output.staging'))) == 1 or $opt{'output-staging'} ne 'online') and $fre->property('FRE.option.transfer.default')) 
  {
    $fre->out(FREMsg::WARNING, "Option --transfer has been automatically added");
    %opt = (%opt, 'transfer' => 1);
  }
  
  if (!exists($opt{free}) and $fre->property('FRE.output.workDir.clean'))
  {
    $fre->out(FREMsg::WARNING, "Option --free has been automatically added");
    %opt = (%opt, 'free' => 1);
  }
  
  {
    my $ncores = $opt{ncores} || $fre->property('FRE.scheduler.inputStager.coresPerJob.default') || frerun::NCORES_DEFAULT;
    %opt = (%opt, 'ncores' => $ncores);
  }
  
  {
    my $walltime = $opt{walltime} || $fre->property('FRE.scheduler.inputStager.runtime.default') || frerun::WALLTIME_DEFAULT;
    %opt = (%opt, 'walltime' => $walltime);
  }
  
  my @exps = ();
  foreach my $expName (FREUtil::listUnique(@ARGV))
  {
    my $exp = FREExperiment->new($fre, $expName) or exit FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    push @exps, $exp;
  }

  my $status = FREDefaults::STATUS_OK;
  
  foreach my $exp (@exps)
  {

    # --------------------------------- set the experiment name
    
    my $expName = $exp->name();
    $fre->setCurrentExperimentName($expName);
    $fre->out(FREMsg::NOTE, "Setting up the experiment '$expName'...");

    # ---------------------------------------------------------------- process the experiment
    
    my %nml = $exp->extractNamelists();
    if (!exists($nml{-1}))
    {
      if ($opt{namelist})
      {
	if ($opt{regression})
	{
          # --------------------------------------------------------------- regression namelists output
	  my @regLabels = ($opt{regression} eq 'suite') ? frerun::REGRESSION_SUITE : $opt{regression};
	  foreach my $regLabel (@regLabels)
	  {
            $fre->out(FREMsg::NOTE, "Extracting namelists for the regression test '$regLabel'...");
	    my $x = 'regression[@label="' . $regLabel . '" or @name="' . $regLabel . '"]';
	    my @regNodes = $exp->extractNodes('runtime', $x);
	    if (scalar(@regNodes) == 1)
	    {
	      my @runNodes = $exp->extractNodes('runtime/' . $x, 'run');
	      if (scalar(@runNodes) > 0)
	      {
		for (my $i = 0; $i < scalar(@runNodes); $i++)
		{
		  my %nmlOverridden = frerun::overrideRegressionNamelists($exp, $runNodes[$i], %nml);
		  print frerun::namelistsAsString(\%nmlOverridden), "\n";
		}
              }
	      else
	      {
	        if ($opt{regression} eq 'suite')
		{
		  $fre->out(FREMsg::WARNING, "The suite is incomplete - the regression test '$regLabel' doesn't have any runs for the experiment '$expName'");
		}
		else
		{
		  $fre->out(FREMsg::FATAL, "The regression test '$regLabel' doesn't have any runs for the experiment '$expName'");
		  frerun::skipExp($exp) if scalar(@exps) > 1;
		  $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
		  last;
		} 
	      }
	    }
	    else
	    {
	      if ($opt{regression} eq 'suite')
	      {
		$fre->out(FREMsg::WARNING, "The suite is incomplete - the regression test '$regLabel' doesn't exist or defined more than once for the experiment '$expName'");
	      }
	      else
	      {
		$fre->out(FREMsg::FATAL, "The regression test '$regLabel' doesn't exist or defined more than once for the experiment '$expName'");
		frerun::skipExp($exp) if scalar(@exps) > 1;
		$status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
		last;
	      } 
	    }
	  }
	}
	else
	{
          # ------------------------------------------------- production namelists output
          $fre->out(FREMsg::NOTE, "Extracting namelists for the experiment '$expName'...");
          my %nmlOverridden = frerun::overrideProductionNamelists($exp, %nml);
	  print frerun::namelistsAsString(\%nmlOverridden), "\n";
	}
      }
      elsif ($opt{regression} eq 'suite')
      {
	# ----------------------------------------------------------------- regression scripts suite creation
        (my $rc, $status) = frerun::processRegressionSuite($exp, \%nml, %opt);
	if ($rc)
	{
	  $fre->out(FREMsg::NOTE, "The regression tests suite in the experiment '$expName' has been processed successfully");
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to process the regression tests suite in the experiment '$expName'");
	  frerun::skipExp($exp) if scalar(@exps) > 1;
	}
      }
      elsif ($opt{regression})
      {
	# ----------------------------------------------------------------- regression scripts creation
        (my $rc, $status) = frerun::processRegression($exp, \%nml, $opt{regression}, %opt);
	if ($rc)
	{
	  $fre->out(FREMsg::NOTE, "The regression test '$opt{regression}' in the experiment '$expName' has been processed successfully");
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to process the regression test '$opt{regression}' in the experiment '$expName'");
	  frerun::skipExp($exp) if scalar(@exps) > 1;
	}
      }
      elsif (frerun::productionParametersExist($exp))
      {
	# ----------------------------------------------------------------- production runscript creation
	my $dualOn = $opt{dual};
	(my $rc, $status) = frerun::processProduction($exp, \%nml, (%opt, 'dual' => 0));
	if ($rc)
	{
	  $fre->out(FREMsg::NOTE, "A runscript for the experiment '$expName' has been created successfully");
	  if ($dualOn)
	  {
	    (my $rc, $status) = frerun::processProduction($exp, \%nml, (%opt, 'check' => 1, 'extend' => 0, 'overwrite' => 0, 'transfer' => 0, 'unique' => 1));
	    if ($rc)
	    {
	      $fre->out(FREMsg::NOTE, "A dual runscript for the experiment '$expName' has been created successfully");
	    }
	    else
	    {
	      $fre->out(FREMsg::FATAL, "Unable to create a dual runscript for the experiment '$expName'");
	      frerun::skipExp($exp) if scalar(@exps) > 1;
	    }
	  } 
	}
	else
	{
	  $fre->out(FREMsg::FATAL, "Unable to create a runscript for the experiment '$expName'");
	  frerun::skipExp($exp) if scalar(@exps) > 1;
	}
      }
      else
      {
        $fre->out(FREMsg::FATAL, "Unable to find runtime production parameters for the experiment '$expName'");
	frerun::skipExp($exp) if scalar(@exps) > 1;
        $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
      }
    }
    else
    {
      $fre->out(FREMsg::FATAL, "Unable to extract namelists for the experiment '$expName'");
      frerun::skipExp($exp) if scalar(@exps) > 1;
      $status = FREDefaults::STATUS_FRE_GENERIC_PROBLEM;
    }
    
    # ------------------------------------ unset the experiment name
    
    $fre->unsetCurrentExperimentName();

  }
  
  exit $status;

}
