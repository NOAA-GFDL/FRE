#!/usr/bin/perl
# -*- cperl -*-
# $Id: frescrub,v 18.0.8.4.2.1.2.1 2012/11/26 13:33:56 Seth.Underwood Exp $
# ------------------------------------------------------------------------------
# frescrub: delete duplicate postprocessing files
# ------------------------------------------------------------------------------

use strict;
use Config;
use File::Spec;
use File::Find;
use Text::Wrap;
use Date::Manip;
use Getopt::Long(':config', 'no_ignore_case');
use XML::LibXML;
use Env qw/USER/;
use Cwd;

use FRE();
use FREExperiment();

use vars qw( $expt %nml %dtvars $err $rtsVersion $root $archivedir $rootdir );
use vars qw( $ppRootDir $component $analysisdir );

{
package frescrub;

use vars qw( $errors $ttlnc $ttlncsum $ttltmp $ttltmpsum $rmcsh );

use constant VERSION => '$Id: frescrub,v 18.0.8.4.2.1.2.1 2012/11/26 13:33:56 Seth.Underwood Exp $';

use constant OPTLIST =>
  (
   'individual|A',
   'raw|B',
   'scripts|C',
   'ptmp|T',
   'all|D',
   'force|f',
   'dir|d=s',
   'ppdir|P=s',
   'interval|i=s',
   'component|c=s',
   'help|h',
   'submit|s',
   'target|t=s',
   'platform|p=s',
   'verbose|v',
   'xmlfile|x=s',
   'after|a=s',
   'through=s'
   );

sub usage {
#getopts( 'ABCDa:c:d:fhi:qsp:t:vx:' ) || die "\aSyntax: $0 [ABCDa:c:d:fhi:qsp:t:vx:]\n";
   print <<EOF;
                                                                                  
Synopsis: frescrub writes a shell script to remove duplicate postprocessing data
          generated by FRE.  With no capitalized arguments, it will print a report of
          postprocessing cpio files, netcdf files, and their sizes.  You must choose one
          of the capitalized options to have frescrub write deletion commands into a
          shell script.  The shell script will not be executed automatically unless you
          use the -s option.  Also, frescrub will not delete any netcdf files if any
          errors were reported for their associated cpio file.  To override this, use the
          -f option.  You can specify year ranges between which to delete duplicate files
          with -i.

Usage:    frescrub [options] experiment [ experiment2 ... ]                 
         
          CHOOSE ONE OR MORE WAYS TO SCRUB YOUR POSTPROCESSING
          -A           = remove netcdf files when a cpio file exists
          -B           = remove redundant, uncombined 'raw' history files
          -C           = clean up \$root by deleting excess old scripts
          -T           = remove all ptmp history,restart,pp files for this expt
                           This option is not affected by -c at this time.
          -D or --all  = all of the above cleanup options that are applicable

          OTHER SCRUBBING OPTIONS                                                     
          -f           = force scrub, overriding warnings 
          -d dir       = path to history directory (default \$archive/\$name/history)
          -P dir       = path to pp directory (default \$archive/\$name/pp) 
          -i year-year = interval of dates to scrub: "-i 0001-0100" scrubs year 1-100
          -c component = delete files for one component only

          GENERAL RTS OPTIONS
          -h           = show this help message, then exit
          -t target    = use compilation directives associated with specific target
          -p platform  = specify the platform name
          -v           = verbose option
          -x xmlfile   = specify xml file (default: ./rts.xml)
          experiment   = experiment to create scripts for; must be found in xml file    

EOF
   exit 1;
} 

#undocumented features
#          -a year      = after date; ie, only scrub files after year [year]
#          -t year      = through date; ie, do not scrub files after year [year]
#other possibilities
#     *    -q           = quiet flag
#     *    -v           = verbose flag                                                   



#remove raw data if it exists
sub rm_raw_history {
   my $rawdir = $_[0];
   if ( -e $rawdir ) {
      $rmcsh .= <<EOF;
#Remove raw (uncombined) history data
rm -rf $rawdir

EOF
   }
}

#remove ptmp data if it exists
sub rm_ptmp_output {
   my $ptmpdir = $_[0];
   if ( $ptmpdir =~ /^\$TMPDIR/ or $ptmpdir =~ /^\$FTMPDIR/) {
      print STDERR "NOTE: ptmpdir is in fast scratch and does not need deleting ($ptmpdir)\n";
      return;
   }
   if ( -e $ptmpdir ) {
      print STDERR "NOTE: removing ptmpdir: $ptmpdir\n";
      $rmcsh .= <<EOF;
#Remove all ptmp history, restart, pp files for this expt
rm -rf $ptmpdir

EOF
   }
}

#remove all but the newest $max files.  good for cleaning up script dirs.
sub rm_old_scripts {
   my $checkdir = $_[0];
   my $max = 300;
   if ( -d $checkdir ) {
      chdir $checkdir;
      my $nf = `ls -1t | wc -l`;
      #just use rm -f so it doesn't delete directories.
      if ( $nf > $max ) {
         $rmcsh .= <<EOF;
#Remove excess scripts
cd $checkdir
@ nf = `ls -1t | wc -l`
if ( \$nf > $max ) then
@ num = \$nf - $max
rm -f `ls -1t | tail -\$num`

EOF
      }
   }
}

#make report of archive cpio and netcdf file sizes
sub scrubcheck {
   unless ( "$_" =~ /\.cpio$/ ) {return;}
   my $filename = $_;
   my $after = $_[0] or '';
   my $through = $_[1] or '';
   my $force = $_[2] or '';
   my $individual = $_[3] or '';

   my $fullpath = $File::Find::name;
   my $dir = $File::Find::dir;

   my $size=(stat("$filename"))[7];
   my @parts = split '\.',$filename;
   my $prefix = join ".", @parts[0..1];
   (my $firstyear, my $lastyear) = split(/-/,$parts[1]);
   $firstyear = substr($firstyear,0,4);
   $lastyear = substr($lastyear,0,4);
   my $errorsfound = 0;
   
   if( "$after" ne "" and $firstyear < $after ) {
      print "$fullpath\n      before year $after, keep all\n";
      return;
   }
   if( "$through" ne "" and $lastyear > $through ) {
      print "$fullpath\n      past year $through, keep all\n";
      return;
   }

   #count nc files associated with cpio
   my $sum=0;
   my @ncfiles=();
   File::Find::find sub { if ( /$prefix\..*\.nc$/ ) { $sum += -s; push @ncfiles,"$_"; } }, $dir;
   my $numnc = scalar @ncfiles;
   my $space = $numnc;
   $space =~ s/./ /g;

   #count ncrcat.tmp files associated with cpio
   my $tmpncsum=0;
   my @tmpncfiles=();
   File::Find::find sub { if ( /$prefix\..*\.ncrcat\.tmp$/ ) { $tmpncsum += -s; push @tmpncfiles,"$_"; } }, $dir;
   my $numtmpnc = scalar @tmpncfiles;

   my $diff = $size-$sum;
   if ( $size == 0 ) {
      if ( $numnc == 0 ) {
         my $err  = "WARNING: Empty cpio file, but no netcdf files ($prefix".".*.nc) exist:\n         $fullpath\n";
         push @ncfiles,"$filename";
         $errors .= $err;
         print $err;
      } else {
         my $err  = "ERROR: Empty cpio file, and $numnc netcdf files ($prefix".".*.nc) exist with total size: $sum:\n         $fullpath\n";
         $errors .= $err;
         print $err;
         unless($force) { $errorsfound++; }
      }
   } else {
      unless ( $size % 65536.0 == 0 ) {
         my $err  = "ERROR: cpio size ($size) is not a multiple of 65536 (64x1024):\n         $fullpath\n";
         $errors .= $err;
         print $err;
         unless($force) { $errorsfound++; }
      }
      if ( $diff < 0 ) {
         my $err = "ERROR: Sum of netcdf file sizes > cpio file size for \n         $fullpath\n";
         $errors .= $err;
         print $err;
         unless($force) { $errorsfound++; }
      }
   }
   if ( $errorsfound == 0 ) {
      $ttlnc += $numnc;
      $ttltmp += $numtmpnc;
      $ttlncsum += $sum;
      $ttltmpsum += $tmpncsum;
      if ( $individual and ($numnc or $numtmpnc) ) {
         $rmcsh .= "#Remove files for $fullpath\ncd $dir\n";
         foreach my $f ( @ncfiles ) {
            $rmcsh .= "rm -f $f\n";
         }
         foreach my $f ( @tmpncfiles ) {
            $rmcsh .= "rm -f $f\n";
         }
         $rmcsh .= "sleep 30\n\n";
      }
   }

   print "$fullpath\n";
   print "  $space size of cpio file: $size\n";
   print "    size of $numnc ncfiles: $sum        difference: $diff\n";
   if ( $numtmpnc ) {
   print "    size of $numtmpnc ncrcat.tmp files: $tmpncsum\n";
   }
}

#round to 3 significant digits
sub round_to_3 {
   my ($num) = @_;
   my ($lg,$round);
   if ($num == 0) {
      return 0;
   }
   $lg = int(log(abs($num)) / log(10.0));      # log base 10 of num
   $round = 10 ** ($lg - 2);
   return int($num / $round + 0.5) * $round;
}


#write c-shell runscript, chmod, and optionally submit
#batchCmd = "qsub -pe $defaultQueue $npes -o $stdoutPath -r y -P $project -l h_cpu=$maxRunTime"
#writescript($cshscript,$outscript,$batchCmd,$defaultQueue,$npes,$stdoutPath,$project,$maxRunTime);
sub writescript {
   #my $script = $_[0];
   my $outscript = $_[1];
   my $batchCmd = $_[2];
   my $defaultQueue = $_[3];
   my $npes = $_[4];
   my $stdoutPath = $_[5];
   my $project = $_[6];
   my $maxRunTime = $_[7];

   #if($::opt_v){print "$batchCmd\n";}

   if("$defaultQueue" ne "") { $batchCmd =~ s/\$defaultQueue/$defaultQueue/g; }
      else { $batchCmd =~ s/\$defaultQueue//g; }
   if("$npes" ne "") { $batchCmd =~ s/\$npes/$npes/g; }
      else { $batchCmd =~ s/\$npes//g; }
   if("$stdoutPath" ne "") { $batchCmd =~ s/\$stdoutPath/$stdoutPath/g; }
      else { $batchCmd =~ s/\$stdoutPath//g; }
   if("$project" ne "") { $batchCmd =~ s/\$project/$project/g; }
      else { $batchCmd =~ s/\$project//g; }
   if("$maxRunTime" ne "") { $batchCmd =~ s/\$maxRunTime/$maxRunTime/g; }
      else { $batchCmd =~ s/\$maxRunTime//g; }

   #if($::opt_v){print "$batchCmd\n";}

   (my $volume,my $directory,my $filename) = File::Spec->splitpath( $outscript );
   if( ! -e $directory ) { mkdir $directory || die "Cannot make directory $directory\n"; }

   open(OUT,"> $outscript");
   print OUT $_[0];
   close(OUT);

   my $status = system("chmod 755 $outscript");
   if( $status ) { die "Sorry, I couldn't chmod $outscript"; }

   #if( $::opt_s ) {
   #   if($::opt_v){print "\nExecuting '$batchCmd $outscript'\n";}
   #   my $qsub_msg = `$batchCmd $outscript`;
   #   print "\n$qsub_msg";
   #} else {
   #   print "\nTO SUBMIT: $batchCmd $outscript\n";
   #}

   print "\nTo scrub, run this script interactively on an analysis node:\n$outscript\n";
}

} #end package frescrub


##############################################
# main program
##############################################
{

my %opt =
   (
     'platform'  => FREDefaults::Platform(),
     'xmlfile'   => FREDefaults::XMLFile(),
     'target'    => FREDefaults::Target()
   );

Getopt::Long::GetOptions(\%opt, frescrub::OPTLIST) or (die "bad options\n");


if( $opt{help} or "$#ARGV" eq "-1" ) {
   frescrub::usage();
   exit 1;
}

if( $opt{interval} ) {
   (my $fyear, my $lyear) = split(/-/,$opt{interval} );
   $fyear = substr($fyear,0,4);
   $lyear = substr($lyear,0,4);
   if( "$lyear" eq "" ) {
      print "ERROR: opt_i format must include two years separated by a dash\n";
      exit 1;
   }
   if( "$opt{after}" ne "" and $fyear != $opt{after} ) {
      print "ERROR: Both opt_i and opt_a are specified, using opt_i ($fyear)\n";
   }
   if( "$opt{through}" ne "" and $lyear != $opt{through} ) {
      print "ERROR: Both opt_i and opt_t are specified, using opt_i ($lyear)\n";
   }
   $opt{after} = $fyear;
   $opt{through} = $lyear;
}

if ( $opt{all} ) {
   $opt{individual} = 1;
   $opt{raw} = 1;
   $opt{scripts} = 1;
   $opt{ptmp} = 1;
}



#begin generating version string
my $abs_xml_path = File::Spec->rel2abs($opt{xmlfile});
my $createdate = &Date::Manip::ParseDate('now');
my $createdateiso = &Date::Manip::UnixDate('now',"%q");
my $version_head = "FMS postprocessing script created at $createdate via:\n# $0 ";
$version_head .= "-x $abs_xml_path ";

if( ! -f "/home/$USER/.rhosts" ) {
   print STDERR "WARNING: You need to create a ~/.rhosts file containing the name of the linux machine\n";
   print STDERR "         from which you use the RTS.  (This allows the RTS to create archive directories.)\n";
}


#-------------- SET UP PARSER FOR XML DOCUMENT -------------------------
(my $user, my $useretc) = getpwuid( (stat($opt{xmlfile}))[4] );
#print "NOTE: owner of xmlfile: $user\n";

#if ( $opt{individual} or $opt{raw} or $opt{scripts} ) {
#  if( "$user" eq "$ENV{USER}" ) {
#     if( (! -d $rootdir) or (! -w $rootdir) ) { die "ERROR: Can't write to your root directory $rootdir\n"; }
#  }
#}

my $fre = '';
my $exp = '';

#------------ LOOP OVER EXPTS GIVEN AS SCRIPT ARGUMENTS ----------------
foreach $expt ( @ARGV ) {
   if ($opt{verbose}) { print "Setting up experiment '$expt'...\n"; }

   my $outscriptdir = '';
   my $jobout = '';
   if ( $opt{ppdir} and $opt{individual} and not $opt{raw} and not $opt{scripts} and not $opt{ptmp} ) {
      $ppRootDir = $opt{ppdir};
      $outscriptdir = getcwd();
      $jobout = getcwd();
   } else {
      $fre = FRE->new('frescrub', %opt) or exit(1);
      $exp = FREExperiment->new($fre, $expt) or exit(1);
      $fre->setCurrentExperimentName($expt);

      if ( $opt{ppdir} ) {
         $ppRootDir = $opt{ppdir};
      } else {
         $ppRootDir = $exp->postProcessDir();
      }

      $outscriptdir = $exp->scriptsDir()."/scrub";
      $jobout = $exp->stdoutDir()."/scrub";
   }

      my $version_info = "$version_head";
      if ( $opt{force} ) { $version_info .= "-f "; }
      $version_info .= "$expt";
      my $runtime = "08:00:00";  #needs work
      my $outscript = "$outscriptdir/scrub_$expt"."_$createdateiso";

   if ( ! -d $jobout ) { mkdir $jobout; }

   my $rmcshhead = <<EOF;
#!/bin/csh -f
#PBS -N frescrub_$expt
#PBS -l walltime=20:00:00
#PBS -l size=1
#PBS -j oe
#PBS -o $jobout/
#PBS -r y
#
#$version_info
unalias *
set echo

EOF
   $frescrub::rmcsh = "";
   $frescrub::errors = "";
   $frescrub::ttlnc = 0;
   $frescrub::ttlncsum = 0;
   $frescrub::ttltmp = 0;
   $frescrub::ttltmpsum = 0;

   my $dir_to_search = "$ppRootDir";
   if( $opt{component} ) { $dir_to_search = "$ppRootDir/$opt{component}"; }

   File::Find::find({wanted=>sub{ frescrub::scrubcheck($opt{after},$opt{through},$opt{force},$opt{individual}) }},$dir_to_search );
      
   if ( "$frescrub::errors" eq "" ) {
      print "\nNo warnings or errors were found.\n";
   } else {
      print "\nSummary of warnings found:\n$frescrub::errors\n";
   }
   print "Total number of netcdf files to be deleted: $frescrub::ttlnc\n";
   print "Total size of netcdf files to be deleted: $frescrub::ttlncsum\n";
   print "Total number of ncrcat.tmp files to be deleted: $frescrub::ttltmp\n";
   print "Total size of ncrcat.tmp files to be deleted: $frescrub::ttltmpsum\n\n";

   if ( $opt{raw} ) {
      if(!$opt{dir}) { $opt{dir} = $exp->archiveDir()."/history"; } 
      frescrub::rm_raw_history("$opt{dir}/raw");
   }

   if ( $opt{ptmp} ) {
      my $archivedir = $exp->archiveDir();
      my $ptmpDir = $exp->ptmpDir();
      $ptmpDir .= $archivedir;
      frescrub::rm_ptmp_output("$ptmpDir");
   }

   if ( $opt{scripts} ) {
      frescrub::rm_old_scripts($exp->scriptsDir()."/run");
      frescrub::rm_old_scripts($exp->scriptsDir()."/postProcess");
      frescrub::rm_old_scripts($exp->scriptsDir()."/scrub");
   }

   if ( $opt{individual} or $opt{raw} or $opt{scripts} ) {
      if ( $frescrub::rmcsh ne "" ) {
        if( "$user" eq "$ENV{USER}" ) {
            frescrub::writescript("$rmcshhead"."$frescrub::rmcsh",$outscript,"msub -d \$HOME");
        } else {
           print STDERR "WARNING: Not creating a delete script, you do not own the xml file\n";
        }
      } else {
         print "Nothing to delete\n";
      }
   }
   next;

}




} #end main program
